[
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.01-workshop-overview/",
	"title": "Workshop Overview",
	"tags": [],
	"description": "",
	"content": "EveryoneCook Architecture EveryoneCook is a modern social cooking platform built entirely on AWS serverless technologies. The architecture follows best practices for scalability, security, and cost optimization, with a focus on Vietnamese ingredient support and AI-powered recipe suggestions.\nKey Components Frontend: Next.js 15 application with Flowbite React components hosted on AWS Amplify Backend: Serverless API using API Gateway with API Router pattern and 6 Lambda modules Database: DynamoDB Single Table Design with username-based PK and 5 GSI indexes Storage: S3 buckets with Intelligent-Tiering and CloudFront CDN with OAC Authentication: Cognito User Pool with Lambda triggers for custom flows AI Integration: Amazon Bedrock (Claude 3 Haiku - anthropic.claude-3-haiku-20240307-v1:0) for ingredient translation, nutrition lookup, and recipe generation Security: WAF for API Gateway, Shield Standard for CloudFront, KMS encryption Monitoring: CloudWatch dashboards, alarms, and X-Ray distributed tracing Architecture Diagram Workshop Flow This workshop follows a practical application development workflow:\nSetup Environment - Install tools (Node.js, AWS CLI, CDK CLI) CDK Bootstrap - Prepare AWS account for CDK deployments Configure Stacks - Set up infrastructure configuration (DNS, Certificate, Core, Auth, Backend, Observability) Deploy Infrastructure - Deploy all CDK stacks to AWS Configure API \u0026amp; Lambda - Set up API Gateway routes and Lambda functions Deploy Backend - Deploy API and Lambda code Test Endpoints - Verify all endpoints work end-to-end Push to GitLab - Version control and CI/CD setup Deploy to Amplify - Deploy frontend to AWS Amplify Monitor \u0026amp; Maintain - Use CloudWatch and X-Ray for monitoring What You\u0026rsquo;ll Learn Infrastructure as Code with AWS CDK (TypeScript) Serverless architecture with API Router pattern DynamoDB Single Table Design with PROVISIONED billing mode CloudFront CDN with Origin Access Control (OAC) - PriceClass 200 Cognito authentication with Lambda triggers Lambda function modular organization (6 modules: API Router, Auth/User, Social, Recipe/AI, Admin, Upload) SQS-based async processing with 4 queues and workers Bedrock AI integration (Claude 3 Haiku) with dictionary-first caching strategy WAF security for API Gateway (REGIONAL scope) CloudWatch monitoring with structured logging (X-Ray disabled for cost optimization) Cost optimization strategies for low-traffic scenarios Realistic Cost Estimate (Low Traffic Scenarios) Scenario 1: 100-500 Active Users/Day (2 hours usage)\nMonthly Active Users: ~3,000-15,000 Daily Requests: ~5,000-25,000 API calls Estimated Monthly Cost: $12-18/month ($0.40-0.60/day) Scenario 2: 1,000 Active Users/Day (2 hours usage)\nMonthly Active Users: ~30,000 Daily Requests: ~50,000 API calls Estimated Monthly Cost: $25-35/month ($0.83-1.17/day) Key Cost Factors:\nDynamoDB: PROVISIONED mode (2 RCU/WCU) with auto-scaling ‚Üí $1.25/month base + $0.50-3/month scaling Lambda: 6 functions (512MB-1GB memory) ‚Üí $2-8/month (first 1M requests free) CloudFront: PriceClass 200 (Asia/US/Europe) ‚Üí $1-5/month (first 1TB free, then $0.085/GB) API Gateway: Regional endpoint ‚Üí $1-3/month (first 1M free, then $3.50/million) Cognito: Standard security (no Advanced Security Mode) ‚Üí $0-1.50/month (first 50K MAU free) S3: Intelligent-Tiering ‚Üí $0.50-2/month (first 50GB free) Bedrock AI: Claude 3 Haiku ($0.25/1M input tokens) ‚Üí $2-8/month with 99% dictionary cache hit rate SQS: 4 queues (AI, Image, Analytics, Notification) ‚Üí $0-0.40/month (first 1M requests free) CloudWatch Logs: 3-day retention ‚Üí $0.50-2/month WAF: API Gateway only (no CloudFront WAF) ‚Üí $5/month base + $0.60/million requests Cost Optimization Applied:\nX-Ray tracing disabled (saves $5-10/month) CloudFront WAF removed, using Shield Standard (saves $6/month) DynamoDB PROVISIONED mode with low baseline (2 RCU/WCU) instead of ON_DEMAND CloudWatch log retention reduced to 3 days for dev (saves $2-5/month) API Gateway caching disabled for dev (saves $14.60/month) Bedrock dictionary-first strategy (99% cache hit rate, reduces AI costs by 70%) Lambda Shared Dependencies Layer (reduces deployment size 90%, faster cold starts) Key Features Vietnamese Support: Vietnamese analyzer for ingredient search AI-Powered: Bedrock Claude 3 Haiku for recipe generation Dictionary-First Translation: 80% coverage target with intelligent caching Social Platform: Posts, comments, reactions, friends, notifications Field-Level Privacy: Granular control over profile visibility Content Moderation: Automated and manual moderation workflows Advanced Search: Full-text search with Vietnamese normalization Cost Optimized: Intelligent-Tiering, caching, and resource optimization "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/",
	"title": "Internship Report",
	"tags": [],
	"description": "",
	"content": "Internship Report Student Information: Full Name: Nguy·ªÖn VƒÉn Tr∆∞·ªùng\nPhone Number: 0764648648\nEmail: truongnvse182034@fpt.edu.vn\nUniversity: FPT University Ho Chi Minh\nMajor: Cyber Security\nClass: AWS092025\nInternship Company: Amazon Web Services Vietnam Co., Ltd.\nInternship Position: FCJ Cloud Intern\nInternship Duration: From 8/9/2025 to 12/11/2025\nReport Content Worklog Proposal Translated Blogs Events Participated Workshop Self-evaluation Sharing and Feedback "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/1.1-week1/",
	"title": "Week 1 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 1 Objectives: Connect and get acquainted with members of First Cloud Journey. Understand basic AWS services, how to use the console \u0026amp; CLI. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 - Get acquainted with FCJ members\n- Read and take note of internship unit rules and regulations 08/09/2025 08/09/2025 3 - Learn about AWS and its types of services + Compute + Storage + Networking + Database - Learn to draw AWS architecture on draw.io - How to do AWS workshop¬†09/09/2025 09/09/2025 https://cloudjourney.awsstudygroup.com/ https://www.youtube.com/watch?v=l8isyDe-GwY\u0026list=PLahN4TLWtox2a3vElknwzU_urND8hLn1i\u0026index=2 https://www.youtube.com/watch?v=mXRqgMr_97U\u0026list=PLahN4TLWtox2a3vElknwzU_urND8hLn1i\u0026index=3 4 - Create new AWS Account - Manage usage costs on AWS with AWS Budgets - Request support with AWS Support -Practice: + Set up the first AWS account, enable MFA, create Admin group/user, configure the Console, and manage Support Cases + Create a budget by template, including Cost Budget, Usage Budget, RI Budget, and Savings Plans Budget. + Change the support package and create a support request. 10/09/2025 10/09/2025 https://000001.awsstudygroup.com/ https://000007.awsstudygroup.com/ https://000009.awsstudygroup.com/ 5 - Access Management with AWS Identity and Access Management (AWS IAM) - Deploy network infrastructure with Amazon Virtual Private Cloud (Amazon VPC) + Firewall in VPC + Deploying Amazon EC2 Instances + Setting Up Site-to-Site VPN Connection in AWS Practice: + Create a VPC with subnet, internet gateway, route table, security group, EC2 server, NAT gateway, and a VPN environment. 11/09/2025 11/09/2025 https://000002.awsstudygroup.com/ https://000003.awsstudygroup.com/ 6 - Getting Started and Deploying Applications on Amazon Compute Cloud (Amazon EC2) + Launch Microsoft Windows Server 2022 Instance + Deploying an AWS User Management Application on Amazon Linux 2 + Deploying Node.js Applications on Amazon EC2 Windows + Cost \u0026amp; Usage Governance with IAM - Grant application permissions to access AWS services through IAM Role (AWS IAM) -Practice: + Connect to Windows Server 2022 and Amazon Linux instances, install LAMP/XAMPP web servers, and implement cost governance with AWS IAM. + Create S3 bucket 12/09/2025 12/09/2025 https://000004.awsstudygroup.com/ https://000048.awsstudygroup.com/ Week 1 Achievements Orientation \u0026amp; Onboarding Got acquainted with FCJ members Read and noted internship unit rules and regulations Understanding AWS Fundamentals Learned about AWS and its main service groups: Compute, Storage, Networking, Database Practiced drawing AWS architectures using draw.io Explored AWS workshops through study group resources and video tutorials Account Setup \u0026amp; Cost Management Successfully created and configured an AWS Free Tier account Enabled Multi-Factor Authentication (MFA) for enhanced security Created Admin group and Admin user, and configured access through the AWS Management Console Practiced managing costs using AWS Budgets: Cost Budget Usage Budget RI Budget Savings Plans Budget Changed the AWS support package and created support requests Gained experience in Support Case management with AWS Support IAM \u0026amp; VPC Deployment Practiced Access Management with AWS Identity and Access Management (IAM) Deployed network infrastructure with Amazon VPC: Created subnet, internet gateway, route table, and security groups Launched EC2 instances inside VPC Configured NAT Gateway and set up a Site-to-Site VPN connection EC2 \u0026amp; Application Deployment Launched and connected to Microsoft Windows Server 2022 and Amazon Linux 2 instances Installed and configured LAMP on Linux and XAMPP on Windows Deployed test applications including Node.js on Amazon EC2 Implemented cost and usage governance using IAM policies and roles Granted application permissions to access AWS services through IAM Roles Successfully created and managed S3 buckets for storage "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/4-eventparticipated/4.1-event1/",
	"title": "Event 1",
	"tags": [],
	"description": "",
	"content": "Event Report: ‚ÄúThe First Cloud Journey (FCJ) Program Kick-off‚Äù Event Objectives Officially introduce the 12-week First Cloud Journey (FCJ) program. Foster connections between participants, Mentors, and the Organizing Committee (OC). Provide a high-level overview of the organization, learning outcomes, and project roadmap. Explain the team workflow and begin the process of forming project teams. Speaker List Organizing Committee Representative ‚Äì Presented the program‚Äôs mission and direction. Mentors ‚Äì Shared career paths and practical experiences in the Cloud industry. Alumni ‚Äì Offered insights and lessons learned from previous cohorts. Key Highlights Program Framework and 12-Week Roadmap Introduced the complete 12-week learning plan, covering foundational AWS knowledge (VPC, EC2) to building a full Serverless application. Clarified learning goals and expectations for the Minimum Viable Product (MVP). Working Rules and Organizational Culture Participation and discipline guidelines: Emphasized responsibility and consistency throughout the program. Community-oriented culture: Highlighted the supportive and collaborative environment. Team Formation and Project Orientation Explained steps for effective team formation, including role delegation and communication channels. Provided initial directions for team projects and research topics. AWS Account Security Guided participants on enabling Two-Factor Authentication (2FA) and setting up cost monitoring (Budget) from the beginning. Key Takeaways Mindset and Commitment Discipline is crucial: Understood the level of dedication required to keep up with the program. Community matters: Recognized the value of mentor support and peer collaboration. Organizational Understanding Gained clarity on the program‚Äôs overall objectives and expected outcomes. Understood the full 12-week learning path and major focus areas. Initial Practical Skills Completed team formation and coordinated with new members. Learned essential security practices for AWS accounts, including 2FA and cost controls. Application to Work Formed the project team and assigned initial tasks. Started researching organizational information and foundational AWS concepts. Performed essential operations on the AWS account‚Äî2FA configuration and Budget setup (as recorded in Week 1 Worklog). Event Experience Participating in the Kick-off provided both motivation and a clear starting direction for the journey ahead.\nConnection and Atmosphere Warm welcome: Engaged with fellow FCJ members, creating a supportive learning environment. Sense of seriousness: The OC‚Äôs message made the expectations and commitment level very clear. Roadmap and Goals Clear visibility: Saw the entire 12-week roadmap outlined, helping me proactively plan my study schedule. Understood that the final objective is not only to learn but also to build a real Cloud product. Initial Practical Insights Security and cost management: Gained important early knowledge on 2FA and budget management when using AWS. Teamwork: Quickly formed a team and initiated discussions on workflow and collaboration. Conclusion The Kick-off was not just an orientation‚Äîit served as a complete preparation session that equipped me with the mindset, information, and confidence needed to begin the 12-week Cloud learning journey.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/3-blogstranslated/3.1-blog1/",
	"title": "Blog 1: AWS Named as a Leader in 2025 Gartner Magic Quadrant for Strategic Cloud Platform Services for 15 Years in a Row",
	"tags": [],
	"description": "",
	"content": "Overview: 15 Years of Industry Leadership On August 4, 2025, Gartner published its latest Magic Quadrant for Strategic Cloud Platform Services (SCPS) report. Amazon Web Services (AWS) was once again recognized as a Leader marking the 15th consecutive year AWS has held the top position in this report.\nNotably, Gartner placed AWS highest on the \u0026ldquo;Ability to Execute\u0026rdquo; axis, reflecting AWS\u0026rsquo;s ongoing commitment to providing the broadest and deepest set of capabilities to accelerate innovation, along with unparalleled security, reliability, and performance that customers can trust for their most critical applications.\n1. Three Core Strengths Recognized by Gartner 1.1. Largest Cloud Community Worldwide AWS has built a strong global community of cloud professionals, providing significant opportunities for learning and engagement.\nKey Community Initiatives:\nAWS Builder Center: Platform to connect directly with AWS Heroes and AWS Community Builders AWS User Groups: Global network of user groups for knowledge exchange Millions of active customers and tens of thousands of partners worldwide This is the most common feedback from customers: AWS has the largest and most dynamic cloud community, making it easy to ask questions and learn from the community.\n1.2. Cloud-Inspired Custom Silicon AWS has leveraged its cloud computing experience to develop custom silicon designs:\nAWS Graviton: Processors optimized for performance and cost AWS Inferentia: Dedicated chips for AI/ML inference AWS Trainium: Machine learning model training chips Benefits:\nTighter integration between hardware and software Improved energy efficiency Greater control over supply chains 1.3. Global Scale and Operational Execution AWS\u0026rsquo;s significant share of global cloud market revenue has enabled it to build a larger and more robust network of integration partners than other providers in this analysis. This helps organizations successfully adopt cloud.\n2. Enterprise Support Programs AWS focuses on facilitating digital transformation for enterprise customers through several programs:\n2.1. AWS Migration Acceleration Program An acceleration program that helps enterprises migrate workloads to the cloud faster and more efficiently.\n2.2. AWS Transform Using generative AI to support migration and modernization of critical workloads:\n.NET applications Mainframe environments VMware deployments 3. Report Methodology and Evaluation The full Gartner report outlines the methodology and evaluation criteria used to develop their assessments of each cloud service provider.\nThis report can serve as a guide when choosing a cloud provider that helps you innovate on behalf of your customers.\nConclusion AWS being recognized as a Leader in Gartner\u0026rsquo;s Magic Quadrant for 15 consecutive years is not just a proud achievement but also demonstrates:\nContinuous Innovation: From custom silicon to generative AI Customer Commitment: Largest community, comprehensive support programs Superior Execution Capability: Global scale, strong partner network Enterprises can trust AWS as a long-term strategic partner to build, operate, and innovate in the cloud.\nImportant Legal Notice:\nGartner does not endorse any vendor, product or service depicted in its research publications and does not advise technology users to select only those vendors with the highest ratings or other designation. Gartner research publications consist of the opinions of Gartner\u0026rsquo;s research organization and should not be construed as statements of fact.\nAuthor Channy Yun (Ïú§ÏÑùÏ∞¨)\rChanny is a Lead Blogger of AWS News Blog and Principal Developer Advocate for AWS Cloud. As an open web enthusiast and blogger at heart, he loves community-driven learning and sharing of technology.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/",
	"title": "Worklog",
	"tags": [],
	"description": "",
	"content": "On this page, you will need to introduce your worklog. How did you complete it? How many weeks did you take to complete the program? What did you do in those weeks?\nTypically, and as a standard, a worklog is carried out over about 3 months (throughout the internship period) with weekly contents as follows:\nWeek 1: Getting familiar with AWS and basic AWS services\nWeek 2: Core Compute and Storage Services on AWS\nWeek 3: Designing Highly Available and Scalable Architectures\nWeek 4: Implementing Data Storage, Backup, and Security\nWeek 5: Optimizing Performance and Cost on AWS\nWeek 6: Building Serverless Systems with Automation\nWeek 7: Monitoring Cloud Resources and Cost Efficiency\nWeek 8: Advanced Networking and Hybrid Cloud\nWeek 9: Strengthened core backend concepts and practiced essential AWS services.\nWeek 10: Improved backend security and implemented authentication with Cognito and API Gateway.\nWeek 11: Optimized backend logic, enhanced API performance, and refined database access patterns.\nWeek 12: Built CI/CD pipelines and completed deployment integration for the backend system.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.04-configure-stacks/5.4.1-dns-stack/",
	"title": "5.4.1 DNS Stack",
	"tags": [],
	"description": "",
	"content": " DNS Stack - Route 53 Hosted Zone Overview The DNS Stack is the foundation layer (Phase 1) of the EveryoneCook infrastructure. It manages the Route 53 Hosted Zone for the everyonecook.cloud domain, providing DNS infrastructure that all other stacks depend on.\nDeployment Order: This stack MUST be deployed first before any other stacks.\nKey Responsibilities Create and manage Route 53 Public Hosted Zone Export Hosted Zone ID and name for cross-stack references Provide nameservers for domain delegation from Hostinger What This Stack Does NOT Include SES Email Identity (managed by Auth Stack - Phase 3) DKIM/SPF/DMARC records (managed by Auth Stack - Phase 3) ACM Certificates (managed by Certificate Stack - Phase 1.5) Application DNS records (managed by respective stacks) Architecture ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ Hostinger Domain ‚îÇ\r‚îÇ everyonecook.cloud ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ Domain Registrar Settings ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚Ä¢ Update Nameservers to Route 53 NS records ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ DNS Delegation\r‚ñº\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ AWS Route 53 Hosted Zone ‚îÇ\r‚îÇ everyonecook.cloud ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ Resources Created: ‚îÇ\r‚îÇ ‚Ä¢ Public Hosted Zone ‚îÇ\r‚îÇ ‚Ä¢ 4 Nameserver (NS) Records ‚îÇ\r‚îÇ ‚Ä¢ SOA Record (automatic) ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ Exports: ‚îÇ\r‚îÇ ‚Ä¢ Hosted Zone ID ‚Üí Used by Certificate Stack ‚îÇ\r‚îÇ ‚Ä¢ Hosted Zone Name ‚Üí Used by other stacks ‚îÇ\r‚îÇ ‚Ä¢ Nameservers ‚Üí Configure at Hostinger ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Stack Configuration File Structure infrastructure/lib/stacks/\r‚îî‚îÄ‚îÄ dns-stack.ts # DNS Stack implementation Code Implementation File: infrastructure/lib/stacks/dns-stack.ts\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import { BaseStack, BaseStackProps } from \u0026#39;../base-stack\u0026#39;; export class DnsStack extends BaseStack { public readonly hostedZone: cdk.aws_route53.IHostedZone; constructor(scope: Construct, id: string, props: BaseStackProps) { super(scope, id, props); // Add stack-specific tags cdk.Tags.of(this).add(\u0026#39;StackType\u0026#39;, \u0026#39;DNS\u0026#39;); cdk.Tags.of(this).add(\u0026#39;Layer\u0026#39;, \u0026#39;Foundation\u0026#39;); cdk.Tags.of(this).add(\u0026#39;CostCenter\u0026#39;, `DNS-${this.config.environment}`); // Create Route 53 Hosted Zone this.hostedZone = this.createHostedZone(); // Export stack outputs this.exportOutputs(); } private createHostedZone(): cdk.aws_route53.IHostedZone { // Extract root domain from environment config const rootDomain = this.config.domains.frontend .replace(/^(dev\\.|staging\\.)/, \u0026#39;\u0026#39;); // everyonecook.cloud const hostedZone = new cdk.aws_route53.PublicHostedZone( this, \u0026#39;HostedZone\u0026#39;, { zoneName: rootDomain, comment: `Hosted Zone for Everyone Cook ${this.config.environment} environment`, } ); cdk.Tags.of(hostedZone).add(\u0026#39;Component\u0026#39;, \u0026#39;DNS\u0026#39;); cdk.Tags.of(hostedZone).add(\u0026#39;ManagedBy\u0026#39;, \u0026#39;CDK\u0026#39;); return hostedZone; } private exportOutputs(): void { // Export Hosted Zone ID new cdk.CfnOutput(this, \u0026#39;HostedZoneId\u0026#39;, { value: this.hostedZone.hostedZoneId, exportName: this.exportName(\u0026#39;HostedZoneId\u0026#39;), description: \u0026#39;Route 53 Hosted Zone ID\u0026#39;, }); // Export Hosted Zone Name new cdk.CfnOutput(this, \u0026#39;HostedZoneName\u0026#39;, { value: this.hostedZone.zoneName, exportName: this.exportName(\u0026#39;HostedZoneName\u0026#39;), description: \u0026#39;Domain name managed by Route 53\u0026#39;, }); // Export Nameservers (for Hostinger configuration) new cdk.CfnOutput(this, \u0026#39;NameServers\u0026#39;, { value: cdk.Fn.join(\u0026#39;, \u0026#39;, this.hostedZone.hostedZoneNameServers || []), description: \u0026#39;‚ö†Ô∏è Update these nameservers at Hostinger\u0026#39;, }); } } Key Configuration Details 1. Domain Extraction Logic The stack automatically extracts the root domain from the environment configuration:\n// Environment config: dev.everyonecook.cloud // Extracted domain: everyonecook.cloud const rootDomain = this.config.domains.frontend.replace(/^(dev\\.|staging\\.)/, \u0026#39;\u0026#39;); Environments:\nDev: dev.everyonecook.cloud ‚Üí Hosted Zone: everyonecook.cloud Staging: staging.everyonecook.cloud ‚Üí Hosted Zone: everyonecook.cloud Prod: everyonecook.cloud ‚Üí Hosted Zone: everyonecook.cloud 2. Resource Naming Convention All resources follow a consistent naming pattern:\n// Resource name format: everyonecook-{env}-{resource} protected resourceName(name: string): string { return `everyonecook-${this.config.environment}-${name}`; } // Export name format: EveryoneCook-{Env}-{Export} protected exportName(name: string): string { return `EveryoneCook-${this.config.environment}-${name}`; } Example:\nStack name: EveryoneCook-dev-DNS Export: EveryoneCook-dev-HostedZoneId 3. Resource Tags Every resource is tagged for cost tracking and management:\n{ Stack: \u0026#39;EveryoneCook-dev-DNS\u0026#39;, Environment: \u0026#39;dev\u0026#39;, StackType: \u0026#39;DNS\u0026#39;, Layer: \u0026#39;Foundation\u0026#39;, CostCenter: \u0026#39;DNS-dev\u0026#39;, Component: \u0026#39;DNS\u0026#39;, ManagedBy: \u0026#39;CDK\u0026#39;, Project: \u0026#39;EveryoneCook\u0026#39; } Stack Outputs After deployment, the stack exports the following values:\nOutput Name Value Usage HostedZoneId Z0123456789ABCDEFGHIJ Used by Certificate Stack for DNS validation HostedZoneName everyonecook.cloud Used by other stacks to create DNS records NameServers ns-1.awsdns-01.com, ns-2.awsdns-02.org, ... Configure at Hostinger for DNS delegation Deployment Steps Step 1: Review Configuration Navigate to the infrastructure directory:\ncd D:\\Project_AWS\\everyonecook\\infrastructure Verify the environment configuration in config/environment.ts:\ndev: { environment: \u0026#39;dev\u0026#39;, account: \u0026#39;YOUR_AWS_ACCOUNT_ID\u0026#39;, region: \u0026#39;ap-southeast-1\u0026#39;, domains: { frontend: \u0026#39;dev.everyonecook.cloud\u0026#39;, api: \u0026#39;api-dev.everyonecook.cloud\u0026#39;, cdn: \u0026#39;cdn-dev.everyonecook.cloud\u0026#39;, }, // ... other configs } Step 2: Deploy DNS Stack Deploy the DNS stack to AWS:\n# Deploy DNS Stack only npx cdk deploy EveryoneCook-dev-DNS --context environment=dev Expected output:\n‚ú® Synthesis time: 5.23s\rEveryoneCook-dev-DNS: deploying...\rEveryoneCook-dev-DNS: creating CloudFormation changeset...\r‚úÖ EveryoneCook-dev-DNS\r‚ú® Deployment time: 45.67s\rOutputs:\rEveryoneCook-dev-DNS.HostedZoneId = Z0123456789ABCDEFGHIJ\rEveryoneCook-dev-DNS.HostedZoneName = everyonecook.cloud\rEveryoneCook-dev-DNS.NameServers = ns-123.awsdns-45.com, ns-678.awsdns-90.net, ns-1234.awsdns-56.org, ns-5678.awsdns-01.co.uk\rStack ARN:\rarn:aws:cloudformation:ap-southeast-1:123456789012:stack/EveryoneCook-dev-DNS/... Step 3: Verify in AWS Console Navigate to Route 53 in the AWS Console Go to Hosted zones Verify the hosted zone everyonecook.cloud is created Expected view:\nDomain name: everyonecook.cloud Type: Public hosted zone Records: 2 (NS and SOA records - automatically created) Route 53 Hosted Zone showing domain details, NS records (4 nameservers), and SOA record\nStep 4: Copy Nameservers From the CloudFormation Outputs or Route 53 console, copy all 4 nameserver records:\nns-123.awsdns-45.com\rns-678.awsdns-90.net\rns-1234.awsdns-56.org\rns-5678.awsdns-01.co.uk Location of nameserver records in Route 53 console\nHostinger Configuration Critical Post-Deployment Step ‚ö†Ô∏è IMPORTANT: After deploying the DNS Stack, you MUST update nameservers at Hostinger to delegate DNS management to Route 53.\nUpdate Nameservers at Hostinger Login to Hostinger hPanel\nNavigate to https://hpanel.hostinger.com Login with your Hostinger credentials Access Domain Management\nGo to Domains section Select everyonecook.cloud domain Change Nameservers\nClick on DNS/Nameservers Select Change nameservers Choose Custom nameservers Enter Route 53 Nameservers\nNameserver 1: ns-123.awsdns-45.com Nameserver 2: ns-678.awsdns-90.net Nameserver 3: ns-1234.awsdns-56.org Nameserver 4: ns-5678.awsdns-01.co.uk Save Configuration\nClick Change nameservers button Wait for confirmation Hostinger hPanel showing custom nameservers configuration with Route 53 NS records\nPropagation Time Initial propagation: 15-30 minutes Full global propagation: Up to 48 hours (typically within 2-4 hours) Verify DNS Delegation After updating nameservers, verify the delegation:\n# Check nameservers for the domain nslookup -type=NS everyonecook.cloud # Or using dig (if available) dig NS everyonecook.cloud Expected output:\neveryonecook.cloud nameserver = ns-123.awsdns-45.com\reveryonecook.cloud nameserver = ns-678.awsdns-90.net\reveryonecook.cloud nameserver = ns-1234.awsdns-56.org\reveryonecook.cloud nameserver = ns-5678.awsdns-01.co.uk Cost Breakdown Monthly Costs Resource Cost Notes Route 53 Hosted Zone $0.50/month Fixed cost per hosted zone DNS Queries $0.40 per million queries First 1 billion queries/month Total (Estimated) ~$0.50-1.00/month Very low traffic in dev environment Cost Optimization Notes ‚úÖ Single hosted zone for all environments (dev, staging, prod) ‚úÖ Use subdomain prefixes to distinguish environments ‚úÖ No additional cost for NS, SOA, or other DNS records ‚úÖ Pay-per-query pricing is very cost-effective for low-medium traffic Cross-Stack Dependencies Exports Used By Other Stacks The DNS Stack exports values that are imported by:\nCertificate Stack (Phase 1.5)\nImports: HostedZoneId Purpose: Create DNS validation records for ACM certificates Core Stack (Phase 2)\nImports: HostedZoneId, HostedZoneName Purpose: Create CloudFront A/AAAA alias records Backend Stack (Phase 4)\nImports: HostedZoneId Purpose: Create API Gateway custom domain DNS records Dependency Flow DNS Stack (Route 53)\r‚îÇ\r‚îú‚îÄ‚ñ∫ Certificate Stack (ACM certificates)\r‚îÇ\r‚îú‚îÄ‚ñ∫ Core Stack (CloudFront DNS records)\r‚îÇ\r‚îî‚îÄ‚ñ∫ Backend Stack (API Gateway DNS records) Validation Checklist Before proceeding to Certificate Stack deployment:\nDNS Stack successfully deployed to AWS Route 53 Hosted Zone visible in AWS Console 4 nameserver records obtained from stack outputs Nameservers updated at Hostinger hPanel DNS delegation verified with nslookup or dig Stack exports visible in CloudFormation console Tags applied correctly to all resources Next Steps After successfully deploying and configuring the DNS Stack:\n‚û°Ô∏è 5.4.2 Certificate Stack - Create ACM certificates with DNS validation\nThe Certificate Stack will:\nCreate ACM certificate for CloudFront (cdn.everyonecook.cloud) Create wildcard ACM certificate for API Gateway (*.everyonecook.cloud) Automatically create DNS validation records in Route 53 Must be deployed to us-east-1 region (CloudFront requirement) References Source Code: infrastructure/lib/stacks/dns-stack.ts Base Stack: infrastructure/lib/base-stack.ts Environment Config: infrastructure/config/environment.ts AWS Documentation: Route 53 Hosted Zones Hostinger Guide: How to Change Nameservers "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.02-setup-environment/",
	"title": "Setup Environment",
	"tags": [],
	"description": "",
	"content": "Overview In this step, you will install all the necessary tools to develop and deploy the EveryoneCook application.\nRequired Tools 1. Node.js 20.x\n# Download from https://nodejs.org/ # Or use nvm (recommended) nvm install 20 nvm use 20 # Verify installation node --version # Should be v20.x npm --version Screenshot: Terminal showing Node.js 20.x installed\n2. AWS CLI v2\n# Windows: Download from https://aws.amazon.com/cli/ # macOS: brew install awscli # Linux: curl \u0026#34;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\u0026#34; -o \u0026#34;awscliv2.zip\u0026#34; unzip awscliv2.zip sudo ./aws/install # Verify installation aws --version Screenshot: Terminal showing AWS CLI v2 installed\n3. AWS CDK CLI\n# Install CDK globally npm install -g aws-cdk # Verify installation cdk --version Screenshot: Terminal showing CDK CLI installed\n4. Git\n# Download from https://git-scm.com/ # Or use package manager # Verify installation git --version 5. Code Editor\nRecommended: Visual Studio Code with extensions:\nAWS Toolkit GitLab Workflow ESLint Prettier AWS Account Setup 1. Create AWS Account\nIf you don\u0026rsquo;t have an AWS account:\nGo to https://aws.amazon.com/ Click \u0026ldquo;Create an AWS Account\u0026rdquo; Follow the registration process Add payment method 2. Create IAM User\nFor security, don\u0026rsquo;t use root account\nGo to IAM Console ‚Üí Users ‚Üí Create user Create user and save credentials Screenshot: IAM console showing user created with AdministratorAccess\n3. Configure AWS CLI\n# Configure AWS credentials aws configure # Enter: # AWS Access Key ID: [Your Access Key] # AWS Secret Access Key: [Your Secret Key] # Default region name: us-east-1 # Default output format: json Screenshot: Terminal showing aws configure completed\n4. Verify AWS Access\n# Test AWS credentials aws sts get-caller-identity # Should return your account ID and user ARN Domain Setup (Optional) If you want to use a custom domain:\n1. Register Domain\nBuy domain name on hpanel.hostinger Route 53 creates dns record to hostinger For this workshop, we use: everyonecook.cloud\n2. Note Domain Registrar\nYou\u0026rsquo;ll need access to domain registrar to update nameservers later.\nGitLab Setup Create GitLab Repo\nScreenshot: GitLab showing personal access token created\n3. Configure Git\n# Set your name and email git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;your.email@example.com\u0026#34; # Verify configuration git config --list Project Setup 1. Clone or Create Project\nOption A: Clone existing project\ngit clone https://gitlab.com/your-username/everyonecook.git cd everyonecook Option B: Create new project\nmkdir everyonecook cd everyonecook git init 2. Install Dependencies\n# Install all dependencies npm install # This installs: # - Infrastructure dependencies (CDK) # - Backend dependencies (Lambda modules) # - Shared dependencies 3. Copy Environment Variables\n# Copy example env file cp .env.example .env # Edit .env with your values # Key variables: # - AWS_REGION=us-east-1 # - AWS_ACCOUNT_ID=your-account-id # - DOMAIN_NAME=everyonecook.cloud # - GITLAB_TOKEN=your-gitlab-token Verification Check that everything is installed correctly:\n# Check Node.js node --version # v20.x # Check npm npm --version # 10.x # Check AWS CLI aws --version # aws-cli/2.x # Check CDK cdk --version # 2.x # Check Git git --version # 2.x # Check AWS credentials aws sts get-caller-identity # Check project dependencies npm list --depth=0 Troubleshooting Issue: Node.js version mismatch\n# Use nvm to switch versions nvm install 20 nvm use 20 Issue: AWS CLI not found\nRestart terminal after installation Check PATH environment variable Issue: CDK command not found\n# Reinstall CDK globally npm uninstall -g aws-cdk npm install -g aws-cdk Issue: AWS credentials invalid\n# Reconfigure AWS CLI aws configure # Enter correct credentials Next Steps Once your environment is set up, proceed to CDK Bootstrap to prepare your AWS account for CDK deployments.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/4-eventparticipated/4.2-event2/",
	"title": "Event 2",
	"tags": [],
	"description": "",
	"content": "Event Report: AWS Cloud Mastery Series #1 ‚Äî AI/ML/GenAI on AWS Event Purpose Provide an overview of the AI/ML landscape in Vietnam. Introduce core AWS AI/ML services, with a strong focus on Amazon SageMaker. Explore Generative AI using Amazon Bedrock, covering foundation models and modern techniques such as RAG and Prompt Engineering. Highlights Morning Session: Overview of AWS AI/ML Services Introduction to the AI/ML context in Vietnam and objectives of the workshop. Amazon SageMaker: AWS‚Äôs end-to-end platform for building and operating ML solutions. Machine learning workflow: data preparation, labeling, training, tuning, and model deployment. Built-in MLOps features within SageMaker. Live demonstration: guided walkthrough of SageMaker Studio. Afternoon Session: Generative AI with Amazon Bedrock Foundation Models: comparison and guidelines for selecting models such as Claude, Llama, Titan, and others. Prompt Engineering: Advanced methods including Chain-of-Thought reasoning and Few-shot learning. Retrieval-Augmented Generation (RAG): RAG architecture and integration with external knowledge sources. Bedrock Agents: building multi-step workflows and enabling tool integrations. Guardrails: best practices for safety controls and content filtering. Live demo: creating a Generative AI chatbot using Bedrock. Key Takeaways SageMaker: gained a clear understanding of its role as a complete platform for the ML lifecycle (data preparation ‚Üí training ‚Üí deployment). Bedrock \u0026amp; GenAI: learned how Bedrock manages foundation models, how to evaluate different FM options, and the relevance of techniques such as Prompt Engineering and RAG. Project application: both RAG and Bedrock Agents provide valuable enhancements for the AI/chatbot features in the Travel-Guided project. Live demos offered practical insights into deployment flows and rapid prototyping with Bedrock. Event Experience The live demos‚Äîespecially the quick setup of a Bedrock-based chatbot‚Äîwere particularly impressive. The event provided excellent opportunities to network and exchange knowledge with AI/ML professionals in Vietnam. "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/3-blogstranslated/3.2-blog2/",
	"title": "Blog 2: Qwen Models are Now Available in Amazon Bedrock",
	"tags": [],
	"description": "",
	"content": "Overview: Expanding Model Choices with Qwen from Alibaba Cloud Amazon Bedrock continues to expand its Generative AI library by adding Qwen3 models from Alibaba Cloud. These are open-weight Foundation Models (FMs) that are fully managed and serverless.\nThis launch provides developers with more flexible options, from high-performance Mixture-of-Experts (MoE) models to cost-optimized Dense models, addressing diverse needs from programming and complex reasoning to edge device deployment.\n1. Qwen3 Variants Available on Bedrock This release includes 4 main model variants, each optimized for specific performance and cost requirements:\nQwen3-Coder-480B-A35B-Instruct: A massive MoE model with 480 billion parameters (35 billion activated). Optimized for programming and agentic tasks, handling large codebase analysis effectively. Qwen3-Coder-30B-A3B-Instruct: A more compact MoE model, specialized for code generation, debugging, and following multilingual programming instructions. Qwen3-235B-A22B-Instruct-2507: A balanced MoE model between capability and efficiency, highly competitive in general reasoning and mathematical tasks. Qwen3-32B (Dense): A dense architecture model, suitable for real-time or resource-constrained environments (such as mobile/edge devices) due to stable performance. 2. Notable Architectural Features Qwen3 models introduce several important technical improvements that help solve complex enterprise problems.\nHybrid Thinking Modes: Supports two problem-solving modes: Thinking mode: Step-by-step reasoning for complex problems. Non-thinking mode: Immediate responses for simple tasks, helping optimize costs. Agentic Capabilities \u0026amp; Tool Use: Models have multi-step planning capabilities and standardized communication with external APIs, ideal for building automated workflows. Ultra-long Context Window: The Qwen3-Coder line supports context up to 1 million tokens (through extrapolation methods), allowing processing of entire technical documentation repositories or long conversation histories in a single call. 3. Access and Integration Users can immediately experience Qwen models through the Amazon Bedrock Console in the Chat/Text Playground area or integrate into applications via AWS SDK.\nNotably, Amazon Bedrock has simplified the model access process. Account administrators have full control over enabling/disabling access through AWS IAM policies and Service Control Policies (SCPs), ensuring enterprise security compliance without manual activation of individual models.\nConclusion The addition of Qwen3 to Amazon Bedrock brings tremendous power to software engineers and data scientists. With superior code processing capabilities and flexible architecture, enterprises can:\nAutomate code analysis and refactoring workflows. Build intelligent AI assistants with optimized inference costs. Deploy diversely from cloud to edge devices without changing the management platform. Author Danilo Poccia\rDanilo is Chief Evangelist (EMEA) at Amazon Web Services. He works with startups and enterprises of all sizes to support creative innovation. He leverages his experience to help people realize their ideas, focusing on serverless architectures, event-driven programming, and the business impact of Machine Learning and Edge Computing. He is also the author of \"AWS Lambda in Action\" published by Manning.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/1.2-week2/",
	"title": "Week 2 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 2 Objectives: Master the usage of AWS Cloud9 IDE and AWS CLI for interacting with AWS services. Deep dive into AWS Storage services (S3) including Static Website Hosting, Versioning, Replication, and Content Delivery Network (CloudFront). Deploy and manage Relational Databases with Amazon RDS, including backup and restoration strategies. Implement High Availability and Scalability architectures using Launch Templates, Elastic Load Balancing (ELB), and Auto Scaling Groups (ASG). Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 Interaction with AWS Services (Cloud9 \u0026amp; CLI) - Create AWS Cloud9 environment - Explore Basic Features: Command line usage, Working with text files - Practice using AWS CLI to interact with services - Resource cleanup 15/09/2025 15/09/2025 https://000049.awsstudygroup.com/ 3 Storage \u0026amp; Content Delivery (S3 \u0026amp; CloudFront) - Create S3 Bucket \u0026amp; Upload Data - Configure Static Website Hosting on S3 - Manage Public Access Block \u0026amp; Public Object policies - Accelerate website with Amazon CloudFront integration - Implement S3 Bucket Versioning for data protection - Practice Move Objects \u0026amp; Cross-Region Replication (CRR) 16/09/2025 16/09/2025 https://000057.awsstudygroup.com/ 4 Database Management (Amazon RDS) - Prepare Network: VPC, Security Groups for EC2 \u0026amp; RDS, DB Subnet Group - Launch EC2 instance for application - Provision Amazon RDS database instance - Deploy application and connect to RDS - Perform Backup and Restore operations for RDS 17/09/2025 17/09/2025 https://000005.awsstudygroup.com/ 5 High Availability Architecture - Part 1 - Prepare Infrastructure: Network, EC2, RDS, Web Server Deployment - Create Launch Template for standardized instance launches - Configure Application Load Balancer (ALB) + Create Target Group + Setup Load Balancer listeners - Test Load Balancing traffic distribution 18/09/2025 18/09/2025 https://000006.awsstudygroup.com/ 6 High Availability Architecture - Part 2 (Auto Scaling) - Create Auto Scaling Group (ASG) attached to the Load Balancer - Test Scaling Solutions: + Manual Scaling: Manually adjusting capacity + Scheduled Scaling: Scaling based on time + Dynamic Scaling: Scaling based on metrics (CPU, etc.) + Predictive Scaling: Review metrics - Clean up all resources 19/09/2025 19/09/2025 https://000006.awsstudygroup.com/ Week 2 Achievements Development Tools \u0026amp; CLI Successfully set up AWS Cloud9 as a cloud-based IDE. Gained proficiency in using AWS CLI for service management without the Console. Understood the workflow of editing, debugging, and running scripts directly on Cloud9. Storage \u0026amp; CDN Mastery Deployed a Static Website using Amazon S3. Secured and optimized content delivery globally using Amazon CloudFront. Implemented data protection strategies using S3 Versioning. Configured Cross-Region Replication (CRR) for disaster recovery and data locality. Database Management Deployed a fully managed relational database using Amazon RDS. Successfully connected a web application hosted on EC2 to the RDS instance. Practiced database maintenance tasks including taking Snapshots and performing Point-in-Time Recovery. Managed network security for databases using Security Groups and DB Subnet Groups. High Availability \u0026amp; Scalability Designed a fault-tolerant architecture using Elastic Load Balancing (ALB) and Auto Scaling Groups (ASG). Created Launch Templates to define instance configurations for auto-scaling. Implemented and tested various scaling policies: Manual Scaling for hands-on control. Scheduled Scaling for predictable traffic patterns. Dynamic Scaling for reacting to real-time load changes. Verified traffic distribution and application availability during scaling events. "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/2-proposal/",
	"title": "Proposal",
	"tags": [],
	"description": "",
	"content": "AWS First Cloud AI Journey ‚Äì Project Plan Hello World ‚Äì FPT University ‚Äì EveryoneCook\nDate: 30/11/2025\nüì• Download Full Proposal (DOCX)\nTABLE OF CONTENTS 1. BACKGROUND AND MOTIVATION\n1.1 executive summary\n1.2 PROJECT SUCCESS CRITERIA\n1.3 Assumptions\n2. SOLUTION ARCHITECTURE / ARCHITECTURAL DIAGRAM\n2.1 Technical Architecture Diagram\n2.2 Technical Plan\n2.3 Project Plan\n2.4 Security Considerations\n3. ACTIVITIES AND DELIVERABLES\n3.1 Activities and deliverables\n3.2 OUT OF SCOPE\n3.3 PATH TO PRODUCTION\n4. EXPECTED AWS COST BREAKDOWN BY SERVICES\n5. TEAM\n6. RESOURCES \u0026amp; COST ESTIMATES\n7. ACCEPTANCE\n1.BACKGROUND and motivation 1.1 Executive summary Customer background\nThe customer is a startup focused on building a modern social network platform where users can share cooking recipes, upload food photos, exchange culinary experiences, and explore meals recommended by AI. The organization aims to deliver a highly interactive platform capable of serving a large and growing user base.\nBusiness and technical objectives \u0026ndash; drivers for moving to the AWS cloud\nEnable rapid development and deployment using AWS managed services Ensure high scalability as the user base and media storage grow Provide a reliable, low-latency environment for AI computation and content delivery Reduce upfront infrastructure cost and move toward a pay-as-you-go model Improve data security, backup, and compliance through AWS-native capabilities Use cases\nUsers upload recipes, photos, and cooking videos to the platform System recommends dishes using AI based on available ingredients provided by the user Users interact socially through liking, commenting, sharing, and following AI processes text and images to generate recipe suggestions Admins manage content, monitor platform activity, and track performance analytics To meet the customer\u0026rsquo;s objectives of building a scalable social cooking platform with AI-powered recipe recommendations, the partner will deliver a full end-to-end cloud implementation on AWS. The services provided include:\nCloud Architecture Design: Define a secure, highly scalable, serverless architecture using AWS best practices (Route 53, API Gateway, Lambda, DynamoDB, S3, CloudFront, Cognito) AI Integration: Implement AWS Bedrock (Claude 3.5 Sonnet) for intelligent recipe suggestions, image analysis, and natural language processing features Infrastructure Deployment: Build and deploy all backend, frontend, authentication, and data layers using Infrastructure as Code (IaC) with fully automated CI/CD pipelines Security \u0026amp; Compliance: Configure IAM roles, encryption (KMS), WAF, logging, monitoring, and compliance guardrails to ensure platform security Observability Setup: Enable CloudWatch dashboards, alarms, X-Ray tracing, and log centralization for real-time monitoring and performance insights DevOps \u0026amp; Automation: Implement automated build/deploy workflows via GitLab + Amplify, operational pipelines, and auto-scaling configurations Performance Optimization: Configure CDN caching, DynamoDB capacity scaling, search indexing, and asynchronous SQS-based background processing Knowledge Transfer \u0026amp; Documentation: Provide technical documentation, best practices, architectural guides, and handover training to the customer\u0026rsquo;s engineering team 1.2 Project Success Criteria Project Success Criteria\nSystem availability ‚â• 99.9% uptime across all production services (API Gateway, Lambda, DynamoDB, CloudFront).\nPage load time \u0026lt; 2.5 seconds for the main user interface delivered through CloudFront and Amplify.\nAPI response time \u0026lt; 300 ms for 90% of all user-facing API requests under normal traffic conditions.\nAI processing latency \u0026lt; 5 seconds for recipe suggestions generated by AWS Bedrock.\nUser authentication success rate ‚â• 98% with Cognito handling registration, login, and email verification.\nZero critical security vulnerabilities after security review and WAF rules deployment.\nData durability of 99.999999999% (11 nines) ensured through S3 object storage and DynamoDB.\nScalability to support 10,000+ concurrent users without degradation in performance due to serverless infrastructure.\nOperational cost control within target budget: monthly AWS usage not exceeding $200 for production.\nImage upload \u0026amp; processing success rate ‚â• 99%, supported by S3, Lambda Workers, and SQS.\nSearch performance under 1 second (if OpenSearch is enabled) for recipe/content search queries.\nMonitoring coverage of 100% critical services using CloudWatch dashboards, alarms, and X-Ray tracing.\nCI/CD deployment time \u0026lt; 5 minutes via GitHub ‚Üí Amplify and IaC automation.\nZero data loss events, ensured by DynamoDB PITR and S3 versioning.\n1.3 Assumptions The customer will provide full access to their domain registrar (Hostinger) to configure DNS delegation to Route 53.\nThe customer will provide valid AWS account access with Administrator privileges for deployment and configuration.\nAll required AWS services (Amplify, API Gateway, Lambda, DynamoDB, CloudFront, Cognito, Bedrock, SES) are available and supported in the chosen region.\nSES will be successfully moved out of the sandbox and approved for production email sending.\nThird-party integrations (GitHub for CI/CD, external email clients, image upload sources) will remain available and stable.\nThe development team will maintain source code quality and follow the architectural guidelines provided by the partner.\nThe customer will provide timely feedback and approvals during design, testing, and deployment phases.\nDependencies\nReliable internet connectivity is required for all users accessing the web application and APIs.\nThe system depends on AWS Bedrock (Claude 3.5 Sonnet) for AI recipe generation and may experience performance fluctuations if the model becomes rate-limited.\nImage upload and processing workflows depend on S3, Lambda, and SQS processing reliability.\nIf OpenSearch is enabled, search features rely on the availability of the OpenSearch domain.\nGitHub Actions and Amplify depend on GitHub service availability.\nConstraints\nThe project will be fully deployed in a single AWS region, which may impact latency for users outside the region.\nThe solution is designed using serverless patterns; custom EC2-based workloads are outside the project scope.\nSES domain reputation may affect email deliverability during initial weeks.\nOpenSearch is deployed as a single-node cluster for cost efficiency, which means no high availability for search indexing.\nThe system must stay within the customer\u0026rsquo;s cost target (\u0026lt; $200/month), limiting the use of large compute resources.\nRisks\nSES production approval may be delayed, impacting user onboarding emails and notifications.\nIf traffic grows unexpectedly, DynamoDB provisioned capacity may throttle without timely scaling adjustments.\nAI model cost or latency changes by AWS may impact application performance or cost control.\nMisconfigured CloudFront caching could lead to higher latency or increased data transfer cost.\nAny incorrect IAM configuration could lead to security risks or service disruption.\nCustomer team turnover or lack of DevOps skills may slow down future maintenance or deployments.\n2. SOLUTION ARCHITECTURE / ARCHITECTURAL DIAGRAM 2.1 Technical Architecture Diagram The proposed solution architecture for the AI-powered cooking social network platform is designed using a fully serverless and scalable AWS cloud-native stack. The architecture ensures high availability,security, and seamless integration between the web frontend, backend APIs, authentication, data storage, and AI recommendation services. Below is a description of the key components and how data flows across the system: 1. Network \u0026amp; Edge Layer\nAmazon Route 53 (6\u0026ndash;7)\nProvides DNS routing for the custom domain used by the platform. Incoming HTTPS requests from users are resolved and forwarded to CloudFront. Amazon CloudFront (9)\nActs as a global CDN distributing frontend content with low latency while caching static files. AWS WAF (8)\nProtects the application from common web exploits such as SQL injection, XSS, and bot attacks. 2. Frontend Hosting \u0026amp; Deployment\nAWS Amplify Hosting (4)\nHosts and deploys the Next.js frontend application. Integrated with GitLab CI/CD (3) for automated deployments from the development workflow. 3. Application Layer\nAmazon Cognito (10)\nHandles user authentication and authorization, supporting email/password and social logins. Amazon API Gateway (11)\nServes as the main entry point for backend APIs, exposing REST endpoints used by the frontend. AWS Lambda (12, 15)\nContains the backend business logic, including:\nuser management\npost and recipe operations\ningredient analysis\nconnecting to Bedrock for AI recommendations\nThis serverless architecture ensures automatic scaling and pay-per-use cost efficiency.\n4. AI Recommendation Layer\nAmazon Bedrock (16\u0026ndash;17)\nProvides generative AI capabilities to suggest recipes based on user-provided ingredients.\nLambda invokes Bedrock models (e.g., Claude, Titan) to:\nanalyze ingredient lists\ngenerate recipe suggestions\nclassify food categories\noptimize cooking steps.\n5. Data Storage Layer\nAmazon DynamoDB (13)\nStores structured application data such as:\nuser profiles\nposts/recipes\nlikes \u0026amp; comments\ningredient metadata.\nAmazon S3 (14)\nStores unstructured data:\nrecipe images\nuser-uploaded food photos\nstatic content.\nAn S3 bucket is integrated with CloudFront via OAI for secure access.\n6. Observability \u0026amp; Security Layer\nAmazon CloudWatch (Logs \u0026amp; Metrics)\nMonitors Lambda performance, API Gateway access logs, and system metrics.\nAWS X-Ray\nPerforms distributed tracing for API calls and debugging.\nIAM\nDefines permission boundaries between API, Lambda functions, Bedrock, DynamoDB, and S3.\nAmazon SES\nSends verification emails, notifications, and password recovery messages.\nAmazon SNS\nHandles system-level alerts and asynchronous messaging.\n7. Deployment \u0026amp; Infrastructure Management\nAWS CDK (1\u0026ndash;2)\nUsed by developers to define and provision the entire infrastructure via CloudFormation templates.\nEnsures consistent, reproducible, version-controlled deployments. 2.2 Technical Plan Partner will develop Infrastructure-as-Code (IaC) automation using AWS CDK (Cloud Development Kit) with TypeScript/Python to provision the entire cloud environment. This approach ensures quick, consistent, and repeatable deployments across multiple AWS accounts and environments (dev, staging, production). All resources such as API Gateway, Lambda functions, DynamoDB tables, S3 buckets, Cognito user pools, Bedrock integration policies, and CloudFront distributions will be fully automated via IaC.\nApplication build and deployment processes for the frontend (Next.js) will be automated using AWS Amplify Hosting, integrated with GitLab pipelines. Backend components will be deployed through CDK pipelines to ensure controlled, versioned, and repeatable releases.\nSome additional configuration such as custom domain setup, Route 53 DNS changes, SSL/TLS certificate issuance, and IAM permission approvals may require customer review and approval. These changes will follow the customer's existing change management process, including scheduled maintenance windows and documented approvals from the security/compliance teams.\nAll critical paths, including authentication flows, AI recipe suggestion APIs, data persistence logic, and image upload workflows, will undergo extensive test coverage. Automated tests (unit, integration, and API-level) will be executed in CI/CD pipelines, and manual validation will be performed in the staging environment before production deployment.\n2.3 Project Plan [Partner] will adopt the Agile Scrum framework across eight 2-week sprints. Stakeholders from the team are required to participate in Sprint Reviews and Sprint Retrospectives to ensure alignment and continuous improvement.\nThe proposed team responsibilities are as follows:\nProduct Owner: Define user stories, prioritize backlog, and ensure the product meets user needs.\nScrum Master**:** Facilitate Scrum ceremonies, remove blockers, and maintain team productivity.\nDevelopment Team: Implement features, conduct unit testing, and collaborate on integration.\nAI/ML Specialist: Develop and fine-tune the AI recommendation engine that suggests recipes based on user-provided ingredients.\nUI/UX Designer: Design intuitive interfaces and ensure a smooth user experience on both web and mobile platforms.\nQA/Testers**:** Validate feature functionality, conduct regression testing, and ensure system reliability.\nCommunication cadences will be established as follows:\nDaily Stand-ups**:** 15-minute meetings for progress updates and immediate blockers.\nSprint Planning**:** At the start of each sprint to prioritize tasks.\nSprint Review: At the end of each sprint to showcase completed features to stakeholders.\nSprint Retrospective**:** Following each sprint review to identify improvements for the next sprint.\nKnowledge transfer sessions will be conducted by the senior developers and AI specialists to ensure team members understand system architecture, AI integration, and deployment procedures.\n2.4 Security Considerations Partner will implement security best practices across the following five categories to ensure the confidentiality, integrity, and availability of the platform:\nAccess Enable Multi-Factor Authentication (MFA) for all user and administrative accounts.\nImplement role-based access control (RBAC) to limit permissions based on user roles (e.g., admin, moderator, contributor).\nEnforce strong password policies and periodic password rotation.\nInfrastructure Deploy the application on secure, managed cloud services (e.g., AWS) following AWS security best practices.\nUse Virtual Private Cloud (VPC), network segmentation, and security groups to isolate resources.\nRegularly patch operating systems and containerized services to mitigate vulnerabilities.\nData Encrypt all data at rest using AWS KMS-managed keys and data in transit using TLS/HTTPS.\nImplement data classification to protect sensitive user information (e.g., email, profile data, dietary preferences).\nApply secure data storage and backup procedures to ensure availability and integrity.\nDetection Enable AWS CloudTrail and AWS Config to monitor API activity and resource configurations.\nDeploy logging and alerting mechanisms to detect unusual or suspicious activities in real time.\nConduct periodic vulnerability scanning and penetration testing on the platform.\nIncident Management Establish a formal incident response plan including detection, containment, remediation, and communication.\nMaintain audit trails and logs to support forensic investigation if a security event occurs.\nEnsure [Customer] shares regulatory control validations to help [Partner] meet all compliance requirements (e.g., GDPR, local privacy regulations).\nBy adhering to these measures, Partner ensures that the social cooking platform remains secure, compliant, and resilient against potential threats.\n3. Activities AND Deliverables 3.1 Activities and deliverables [Provide project milestones with timeline and respective deliverables, corresponding to the items and activities described in the Scope of Work / Technical Project Plan section. Indicate plans on how to govern the project/ change management; communication plans; transition plans]\nProject Phase\rTimeline\rActivities\rDeliverables/Milestones\rTotal man-day\rInfrastructure Setup\rWeek 1-2\r- Learn all aws service\n- Practice Lab¬†- Worklog¬†2 week\rProject Foundation \u0026amp; Infrastructure Setup\rWeek 3\r-¬†Initialize monorepo structure\n- setup development environment¬†- Initialize Git repository and CI/CD\n- Initialize CDK project structure\n-Create environment configuration system\n-Setup CDK deployment scripts\n-¬†Setup Git repository with CI/CD pipelines and branch\rprotection\n-¬†Configure local testing scripts and Git hooks for code quality\n- Set up AWS CDK project structure with proper organization for\rinfrastructure as code\n-¬†Implement centralized configuration management for dev, staging,\rand prod environments\n1 week\r-DNS Infrastructure (Route 53 Hosted Zone) - DNS Stack\n- Side Quest: CloudFront y√™u c·∫ßu ACM certificate ·ªü us-east-1, nh∆∞ng\rstack ch√≠nh deploy ·ªü ap-southeast-1\nWeek 4 ,5\r- Create a Public Hosted Zone\n- Configure name server delegation\n- Architecture Design\n- Create DNS Stack in CDK project\n- Connect DNS , User Route 53 Alias targeting for AWS - managed¬†- Request ACM certificates, Configure DNS validation in Route 53\n- Configure MX records for email , add SPF,DKIM,DMARC for email\rauthentication\n- Create DNS structure , Validate DNS\n-npm run cdk deploy EveryoneCook-dev-Certificate¬†-¬†Domain \u0026amp; Hosted Zone Setup\n- Deploy DNS Stack\n- Route 53 Hosted Zone Status\n- Create Public Hosted Zone \u0026amp; NS Delegation Plan\n- ACM Certificates Automation\n- Test DNS\n- Link DNS to AWS Resources\n- Monitoring\n- Deploy Certificate Stack¬†2 weeks\rStructure Core Stack¬†Week 6,7\r-¬†Initialize Core Stack for DynamoDB, S3, CloudFront, and\rOpenSearch infrastructure\n-¬†Create DynamoDB table with Provisioned Mode and Auto-Scaling for\rcost optimization\n- Implement Global Secondary Indexes for diverse access patterns\n- Configure KMS encryption and security settings for DynamoDB\n- Create all 4 S3 buckets (content, logs, incoming emails, CDN logs)\rwith Intelligent-Tiering for cost optimization\n-¬†Configure CloudFront CDN with compression and caching\roptimization\n- Setup signed URLs for private content (avatars, backgrounds)\n- Create OpenSearch domain for advanced search with cost\roptimization\n- Create CoreStack class\n- Implement DynamoDB Single Table with cost optimization\n- Create 5 GSI indexes\n- Setup encryption and security for DynamoDB¬†- S3 Storage, CloudFront CDN,OpenSeach Domain\n- Deploy Core Stack\n2 week\rAuthentication Stack\rWeek 8\r- Initialize Authentication Stack for Cognito User Pool\n-¬†Create Cognito User Pool with production-grade security\rsettings\n- Setup SES for production email sending with Route 53 DNS\rautomation\n- Implement Lambda triggers for Cognito lifecycle events\n- Cognito User Pool Setup\n- Implement Cognito User Pool with production settings\n- Configure SES email integration (Production mode)\n- Setup Cognito Lambda triggers\n1 week\rBackend Stack (API Gateway + Lambda )\rWeek 9,10\r-¬†Create API Gateway REST API with production settings and\rCognito authorizer\n- Configure Cognito User Pool authorizer for API Gateway\n- Enable API Gateway caching for production to improve performance\rand reduce Lambda invocations\n-¬†Enable request validation at API Gateway level to reject invalid\rrequests early\n- Enable compression for API responses to reduce data transfer\rcosts\n-¬†Configure API Gateway custom domain for Everyone Cook project\n- Setup API Router Lambda directory structure\n- Implement routing logic for API Gateway requests\n-¬†Deploy API Router Lambda to AWS and implement JWT validation for\rCognito tokens\n- Setup Auth \u0026amp; User module directory structure\n- Create BackendStack class\n- Create API Gateway REST API\n- Setup Cognito Authorizer\n- Configure API Gateway caching\n-¬†Configure API Gateway request validation\n-¬†Enable API Gateway compression\n-¬†Configure API Gateway custom domain\n-¬†Create API Router Lambda structure\n-¬†Implement API Router handler\n-¬†Deploy API Router Lambda + Implement JWT Validation\n- Create Auth \u0026amp; User module structure\n- Implement authentication handlers\n- Implement user profile handlers,‚Ä¶\n- Social Module Lambda\n2 weeks\r3.2 OUT OF SCOPE Real-time Messaging / Chat System\nPrivate or group chat\nReal-time messaging infrastructure (WebSocket, SignalR, Firebase Realtime DB, etc.)\nMessage history storage \u0026amp; encryption\nFriends / Social Graph Management\nFriend requests, following/followers\nUser-to-user connection graph\nActivity feed, notifications tied to friend actions\nReal-time Voice \u0026amp; Video Calling\n1-to-1 or group voice call\nVideo call, screen sharing\nWebRTC signaling servers \u0026amp; TURN/STUN infrastructure\nAdvanced Social Interaction\nIn-app messaging reactions\nTyping indicators, online/offline status\nRead receipts, presence tracking\n3.3 PATH TO PRODUCTION 1. Project Foundation \u0026amp; Infrastructure\n- Initialize project structure\n- Set up core infrastructure baseline\n- Configure Route 53 Hosted Zone (DNS Stack)\n2. Cross-Region Certificate (Side Quest)\n- Handle CloudFront requirement for ACM certificate in us-east-1\n- Sync certificate usage with main stack in ap-southeast-1\n3. Core Application Stacks\n- Core Stack: Shared resources / environment setup\n- Authentication Stack: User auth, Cognito, permissions\n- Backend Stack: API Gateway + Lambda functions\n4. Frontend Deployment\n- Deploy frontend (S3 + CloudFront)\n- Bug fixes \u0026amp; QA testing\n4. EXPECTED AWS COST BREAKDOWN BY SERVICES Target workload: 100-500 Monthly Active Users (MAU)\nAverage Lambda duration: 200ms per invocation\nDynamoDB peak activity: ~8 hours per month\nS3 to CloudFront data transfer is FREE (same region)\nAll services leverage AWS Free Tier where applicable (Lambda 1M requests, SQS 1M requests, Cognito 50K MAU, Amplify 1000 build minutes)\nAPI Gateway caching enabled at 0.5GB ($14.60/month) - can be disabled to reduce costs\nCloudFront WAF removed to optimize costs (~$9/month savings), Shield Standard provides DDoS protection\nBedrock uses on-demand pricing with Claude 3 Haiku (lowest cost Anthropic model)\nhttps://calculator.aws/#/estimate?id=7a8833402a63e273357ddc71071bfc2cdce4be2c\n5. TEAM Partner Executive Sponsor\nName Title Description Email / Contact Info Nguyen Gia Hung Director of FCJ Vietnam Training Program As the Executive Sponsor, you are responsible for the overall oversight of the FCJ internship program. Ensure the project delivers learning value and adheres to AWS technical and career goals hunggia@amazon.com Project Stakeholders\nName Title Stakeholder for Email / Contact Info Van Hoang Kha Support Teams is the Executive Assistant responsible for overall oversight of the FCJ internship program Khab9thd@gmail.com Partner Project Team\nName Title Role Email / Contact Info Pham Minh Hoang Viet Leader Project Manager vietpmhse181851@gmail.com Nguyen Van Truong Member DevOps truongnvse182034@fpt.edu.vn Huynh Duc Anh Member Cloud Engineer anhhdse183114@fpt.edu.vn Nguyen Thanh Hong Member Tester hongntse183239@fpt.edu.vn Nguyen Quy Duc Member Frontend ducnqse182087@fpt.edu.vn Project Escalation Contacts\nName Title Role Email / Contact Info Pham Minh Hoang Viet Leader Project Manager vietpmhse181851@gmail.com 6. Resources \u0026amp; cost estimates Resource Responsibility Rate (USD) / Hour Solution Architects [[1]]{.mark} Architecture design, AWS service selection, security review, cost optimization $150 Engineers [[2]]{.mark} Frontend (Next.js), Backend (Lambda/Node.js), Infrastructure (CDK), Testing $100 Other . DevOps [1] CI/CD setup, monitoring, deployment automation $80 Project Phase\rSolution Architects\rEngineers\rOther\n(DevOps)\nTotal Hours\rDiscovery \u0026amp; Requirements\r16\r24\r8\r48\rArchitecture Design\r40\r16\r8\r64\rDevelopment\r16\r200\r40\r256\rTesting \u0026amp; QA\r8\r40\r16\r64\rDeployment \u0026amp; Go-Live\r8\r24\r24\r56\rDocumentation \u0026amp; Training\r8\r16\r8\r32\rTotal Hours\r96\r320\r104\r520\rTotal Cost\r$14,400 | $32,000\r$8,320 | $54,720\rMonthly AWS Infrastructure Cost\nBased on AWS Pricing Calculator estimate for 100-500 MAU:\nService Monthly Cost (USD) Description Amazon DynamoDB $13.06 Single-table design, 5 GSIs, provisioned capacity Amazon S3 $0.84 2 buckets, Intelligent-Tiering Amazon CloudFront $1.44 CDN, Price Class 200 Amazon Cognito $5.00 User authentication AWS Lambda $0.00 13 functions (Free Tier) Amazon API Gateway $20.65 REST API with 0.5GB cache Amazon SQS $0.00 8 queues (Free Tier) Amazon SES $0.02 Transactional emails AWS KMS $2.00 2 customer managed keys AWS WAF $10.00 Web ACL, 5 rules Amazon CloudWatch $21.25 Metrics, dashboards, alarms, logs Amazon Route 53 $0.93 DNS hosted zone AWS Amplify $4.58 Frontend hosting (Next.js) Amazon Bedrock $64.80 Claude 3 Haiku AI Total ~$144.54 Per month Cost Summary\nCost Type Amount (USD) Notes One-time Development Cost $54,720 Resource hours √ó rates Monthly AWS Infrastructure ~$145 Based on 100-500 MAU Annual AWS Infrastructure ~$1,740 Monthly √ó 12 Year 1 Total Cost ~$56,460 Development + 12 months AWS Cost Contribution Distribution\nParty Contribution (USD) % Contribution of Total Customer $54,720 100% Partner $0 $0 AWS $0 $0 7. Acceptance Since this project is currently at the presentation stage and has not yet been formally evaluated by a customer, the following acceptance process is proposed for future delivery phases:\n7.1 Acceptance Criteria (Proposed) A deliverable will be considered acceptable when it meets the following criteria:\nFunctional features work as specified (authentication, recipe management, social features, AI functions).\nAll APIs respond correctly and integrate with AWS services (Lambda, API Gateway, DynamoDB, S3).\nSecurity requirements are met (JWT verification, HTTPS, access control, data encryption).\nUI works as expected on supported devices.\nNo critical errors appear during test execution.\n7.2 Acceptance Process Review period: 8 business days for evaluation and testing.\nIf accepted ‚Üí Deliverable is signed off.\nIf issues are found ‚Üí A rejection notice will be issued with feedback.\nFixes will be applied and a revised version will be resubmitted for review.\nIf no response is received by the end of the review period ‚Üí Deliverable is deemed accepted.\nAfter completing each milestone, the team submits the deliverables and documentation.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.04-configure-stacks/5.4.2-certificate-stack/",
	"title": "5.4.2 Certificate Stack",
	"tags": [],
	"description": "",
	"content": " Certificate Stack - ACM Certificates for SSL/TLS Overview The Certificate Stack is the Phase 1.5 infrastructure layer of the EveryoneCook project. It manages AWS Certificate Manager (ACM) certificates for CloudFront CDN and API Gateway, providing SSL/TLS encryption for all HTTPS traffic.\nDeployment Order: This stack MUST be deployed after DNS Stack and before Core Stack and Backend Stack.\nCritical Region Requirement: This stack MUST be deployed in us-east-1 region because CloudFront is a global service that can only access ACM certificates from us-east-1.\nKey Responsibilities Create ACM certificate for CloudFront CDN (cdn.everyonecook.cloud or cdn-dev.everyonecook.cloud) Create wildcard ACM certificate for API Gateway (*.everyonecook.cloud) Automatic DNS validation via Route 53 Export certificate ARNs for Core Stack and Backend Stack What This Stack Does NOT Include DNS records (managed by DNS Stack - Phase 1) CloudFront distribution (managed by Core Stack - Phase 2) API Gateway custom domain (managed by Backend Stack - Phase 4) CloudFront WAF Web ACL (removed for cost optimization) Architecture ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ Route 53 Hosted Zone ‚îÇ\r‚îÇ everyonecook.cloud ‚îÇ\r‚îÇ (from DNS Stack) ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ DNS Validation\r‚ñº\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ AWS Certificate Manager (us-east-1) ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ Certificate 1: CloudFront Certificate ‚îÇ\r‚îÇ ‚îú‚îÄ Domain: cdn.everyonecook.cloud (or cdn-dev) ‚îÇ\r‚îÇ ‚îú‚îÄ Validation: DNS (Route 53) ‚îÇ\r‚îÇ ‚îú‚îÄ Status: Issued (5-10 minutes) ‚îÇ\r‚îÇ ‚îî‚îÄ Export: CloudFrontCertificateArn ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ Certificate 2: API Gateway Wildcard Certificate ‚îÇ\r‚îÇ ‚îú‚îÄ Domain: *.everyonecook.cloud ‚îÇ\r‚îÇ ‚îú‚îÄ SAN: everyonecook.cloud ‚îÇ\r‚îÇ ‚îú‚îÄ Covers: api.everyonecook.cloud, api-dev, api-staging ‚îÇ\r‚îÇ ‚îú‚îÄ Validation: DNS (Route 53) ‚îÇ\r‚îÇ ‚îú‚îÄ Status: Issued (5-10 minutes) ‚îÇ\r‚îÇ ‚îî‚îÄ Export: ApiGatewayCertificateArn ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ Cost Optimization: ‚îÇ\r‚îÇ CloudFront WAF removed (-$9/month) ‚îÇ\r‚îÇ Shield Standard (free, auto-enabled) ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ\r‚îÇ Certificate ARN Exports\r‚ñº\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨\r‚ñº ‚ñº Core Stack Backend Stack (CloudFront) (API Gateway) Stack Configuration File Structure infrastructure/lib/stacks/\r‚îî‚îÄ‚îÄ certificate-stack.ts # Certificate Stack implementation Code Implementation File: infrastructure/lib/stacks/certificate-stack.ts\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as acm from \u0026#39;aws-cdk-lib/aws-certificatemanager\u0026#39;; import * as route53 from \u0026#39;aws-cdk-lib/aws-route53\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import { BaseStack, BaseStackProps } from \u0026#39;../base-stack\u0026#39;; /** * Certificate Stack for CloudFront and API Gateway * * This stack creates ACM certificates for CloudFront and API Gateway. * * IMPORTANT REGION REQUIREMENTS: * - CloudFront certificate: MUST be in us-east-1 (CloudFront requirement) * - API Gateway certificate: Should be in same region as API Gateway (ap-southeast-1) * * This stack is deployed in us-east-1 to handle CloudFront\u0026#39;s cross-region requirements. * For API Gateway, we use a wildcard certificate that covers api.everyonecook.cloud. * * Responsibilities: * - Create ACM certificate for CloudFront in us-east-1 * - Create ACM wildcard certificate for API Gateway in us-east-1 (works globally) * - Validate certificates via Route 53 DNS * - Export certificate ARNs for Core Stack and Backend Stack to use * * COST OPTIMIZATION NOTE: * - CloudFront WAF removed to save $9/month ($108/year) * - CloudFront still protected by Shield Standard (free, auto-enabled) * - API Gateway has full WAF protection (BackendStack) */ export class CertificateStack extends BaseStack { public readonly cloudFrontCertificate: acm.ICertificate; public readonly apiGatewayCertificate: acm.ICertificate; constructor(scope: Construct, id: string, props: BaseStackProps) { super(scope, id, props); // Add stack-specific tags cdk.Tags.of(this).add(\u0026#39;StackType\u0026#39;, \u0026#39;Certificate\u0026#39;); cdk.Tags.of(this).add(\u0026#39;Layer\u0026#39;, \u0026#39;Infrastructure\u0026#39;); cdk.Tags.of(this).add(\u0026#39;CostCenter\u0026#39;, `Certificate-${this.config.environment}`); // Import Route 53 Hosted Zone from DNS Stack // Note: Cannot use Fn.importValue or SSM Parameter for cross-region references // Hosted Zone ID is stable and doesn\u0026#39;t change, so we hardcode it // This value comes from DNS Stack output: Z018823421GWCSYG5UMHV const hostedZoneId = \u0026#39;Z018823421GWCSYG5UMHV\u0026#39;; const hostedZone = route53.HostedZone.fromHostedZoneAttributes(this, \u0026#39;HostedZone\u0026#39;, { hostedZoneId: hostedZoneId, zoneName: \u0026#39;everyonecook.cloud\u0026#39;, }); // Create ACM certificate for CloudFront // This certificate MUST be in us-east-1 for CloudFront to use it this.cloudFrontCertificate = this.createCloudFrontCertificate(hostedZone); // Create ACM wildcard certificate for API Gateway // Wildcard *.everyonecook.cloud covers api.everyonecook.cloud // This certificate in us-east-1 can be used by API Gateway in any region this.apiGatewayCertificate = this.createApiGatewayCertificate(hostedZone); // COST OPTIMIZATION: CloudFront WAF removed // CloudFront is protected by Shield Standard (free, auto-enabled) // API Gateway has full WAF protection in BackendStack // Savings: $9/month ($108/year) // Export certificate ARNs this.exportOutputs(); } /** * Create ACM certificate for CloudFront CDN * * CRITICAL: This stack MUST be deployed in us-east-1 region. * CloudFront is a global service but its control plane is in us-east-1, * so it can only access certificates from us-east-1. * * DNS validation is automatic via Route 53. * Validation typically takes 5-10 minutes. * * @param hostedZone - Route 53 Hosted Zone for DNS validation * @returns ACM Certificate for CloudFront */ private createCloudFrontCertificate(hostedZone: route53.IHostedZone): acm.Certificate { const certificate = new acm.Certificate(this, \u0026#39;CloudFrontCertificate\u0026#39;, { domainName: this.config.domains.cdn, validation: acm.CertificateValidation.fromDns(hostedZone), certificateName: `EveryoneCook-CloudFront-${this.config.environment}`, }); // Add tags cdk.Tags.of(certificate).add(\u0026#39;Component\u0026#39;, \u0026#39;CloudFront\u0026#39;); cdk.Tags.of(certificate).add(\u0026#39;Purpose\u0026#39;, \u0026#39;CDN-SSL\u0026#39;); return certificate; } /** * Create ACM wildcard certificate for API Gateway * * Creates a wildcard certificate (*.everyonecook.cloud) that covers: * - api.everyonecook.cloud (API Gateway) * - api-dev.everyonecook.cloud (API Gateway dev) * - api-staging.everyonecook.cloud (API Gateway staging) * * This certificate is created in us-east-1 but can be used by API Gateway * in any region via cross-region certificate reference. * * DNS validation is automatic via Route 53. * Validation typically takes 5-10 minutes. * * @param hostedZone - Route 53 Hosted Zone for DNS validation * @returns ACM Certificate for API Gateway */ private createApiGatewayCertificate(hostedZone: route53.IHostedZone): acm.Certificate { const certificate = new acm.Certificate(this, \u0026#39;ApiGatewayCertificate\u0026#39;, { domainName: \u0026#39;*.everyonecook.cloud\u0026#39;, // Wildcard covers api.everyonecook.cloud subjectAlternativeNames: [\u0026#39;everyonecook.cloud\u0026#39;], // Also covers root domain validation: acm.CertificateValidation.fromDns(hostedZone), certificateName: `EveryoneCook-API-${this.config.environment}`, }); // Add tags cdk.Tags.of(certificate).add(\u0026#39;Component\u0026#39;, \u0026#39;APIGateway\u0026#39;); cdk.Tags.of(certificate).add(\u0026#39;Purpose\u0026#39;, \u0026#39;API-SSL\u0026#39;); return certificate; } /** * Export stack outputs for cross-stack references * * Exports: * - CloudFrontCertificateArn: ACM Certificate ARN for CloudFront (us-east-1) * - ApiGatewayCertificateArn: ACM Certificate ARN for API Gateway (us-east-1) * * REMOVED: CloudFrontWebAclArn (cost optimization) */ private exportOutputs(): void { // Export CloudFront certificate ARN for Core Stack new cdk.CfnOutput(this, \u0026#39;CloudFrontCertificateArn\u0026#39;, { value: this.cloudFrontCertificate.certificateArn, exportName: this.exportName(\u0026#39;CloudFrontCertificateArn\u0026#39;), description: \u0026#39;ACM Certificate ARN for CloudFront (us-east-1)\u0026#39;, }); // Export CloudFront certificate domain for verification new cdk.CfnOutput(this, \u0026#39;CloudFrontCertificateDomain\u0026#39;, { value: this.config.domains.cdn, description: \u0026#39;Domain name for CloudFront certificate\u0026#39;, }); // Export API Gateway certificate ARN for Backend Stack new cdk.CfnOutput(this, \u0026#39;ApiGatewayCertificateArn\u0026#39;, { value: this.apiGatewayCertificate.certificateArn, exportName: this.exportName(\u0026#39;ApiGatewayCertificateArn\u0026#39;), description: \u0026#39;ACM Wildcard Certificate ARN for API Gateway (us-east-1)\u0026#39;, }); // Export API Gateway certificate domain for verification new cdk.CfnOutput(this, \u0026#39;ApiGatewayCertificateDomain\u0026#39;, { value: \u0026#39;*.everyonecook.cloud\u0026#39;, description: \u0026#39;Domain name for API Gateway certificate (wildcard)\u0026#39;, }); } } Key Configuration Details 1. Region Requirements Critical: This stack MUST be deployed to us-east-1:\n// In infrastructure/bin/app.ts const certificateStack = new CertificateStack(app, `${stackPrefix}-Certificate`, { env: { account: config.account, region: \u0026#39;us-east-1\u0026#39;, // MUST be us-east-1 for CloudFront }, config, description: `ACM Certificate for CloudFront (${config.environment}) - us-east-1`, }); Why us-east-1?\nCloudFront is a global service with control plane in us-east-1 CloudFront can only access ACM certificates from us-east-1 API Gateway wildcard certificate in us-east-1 works globally 2. Certificate Domains The stack creates two certificates with environment-specific domains:\nCloudFront Certificate:\n// Dev environment domainName: \u0026#39;cdn-dev.everyonecook.cloud\u0026#39; // Staging environment domainName: \u0026#39;cdn-staging.everyonecook.cloud\u0026#39; // Production environment domainName: \u0026#39;cdn.everyonecook.cloud\u0026#39; API Gateway Wildcard Certificate:\ndomainName: \u0026#39;*.everyonecook.cloud\u0026#39; // Covers all subdomains subjectAlternativeNames: [\u0026#39;everyonecook.cloud\u0026#39;] // Also covers root domain // Covers: // - api.everyonecook.cloud // - api-dev.everyonecook.cloud // - api-staging.everyonecook.cloud // - Any future *.everyonecook.cloud subdomains 3. Automatic DNS Validation ACM automatically creates DNS validation records in Route 53:\nvalidation: acm.CertificateValidation.fromDns(hostedZone) What Happens:\nACM creates CNAME record in Route 53 for validation Route 53 immediately responds with the validation record ACM verifies the record and issues the certificate Validation completes in 5-10 minutes (typically faster) 4. Cross-Region Certificate Reference The certificate created in us-east-1 is used by other stacks in ap-southeast-1:\n// In Core Stack (ap-southeast-1) - imports CloudFront certificate from us-east-1 const certificate = acm.Certificate.fromCertificateArn( this, \u0026#39;ImportedCloudFrontCertificate\u0026#39;, \u0026#39;arn:aws:acm:us-east-1:616580903213:certificate/8d53776e-0480-47d2-a6ff-4fe9b2eb6534\u0026#39; ); 5. Cost Optimization - WAF Removed Decision: CloudFront WAF Web ACL removed to save costs:\n// REMOVED: CloudFront WAF Web ACL // Previous monthly cost: $9/month = $108/year // Protection Status: // Shield Standard: DDoS protection (free, auto-enabled) // CloudFront OAC: Blocks direct S3 access // Signed URLs: Private content protection // ‚ùå WAF: Removed (cost optimization) Rationale:\nCloudFront serves static content only (low attack surface) Shield Standard provides Layer 3/4 DDoS protection (free) API Gateway has full WAF protection for Layer 7 attacks Savings: $9/month = $108/year Stack Outputs After deployment, the stack exports the following values:\nOutput Name Value Usage CloudFrontCertificateArn arn:aws:acm:us-east-1:616580903213:certificate/8d53776e-... Used by Core Stack for CloudFront distribution CloudFrontCertificateDomain cdn.everyonecook.cloud (or cdn-dev) Verification only ApiGatewayCertificateArn arn:aws:acm:us-east-1:616580903213:certificate/a1b2c3d4-... Used by Backend Stack for API Gateway domain ApiGatewayCertificateDomain *.everyonecook.cloud Verification only (wildcard) Deployment Steps Step 1: Verify Prerequisites Before deploying Certificate Stack, ensure:\nDNS Stack successfully deployed Route 53 Hosted Zone exists with correct nameservers DNS delegation from Hostinger completed and propagated Verify DNS is working:\nnslookup -type=NS everyonecook.cloud Step 2: Deploy Certificate Stack Navigate to infrastructure directory:\ncd D:\\Project_AWS\\everyonecook\\infrastructure Deploy Certificate Stack to us-east-1:\n# Deploy Certificate Stack npx cdk deploy EveryoneCook-dev-Certificate --context environment=dev Important: Notice the region is us-east-1, not ap-southeast-1.\nExpected output:\n‚ú® Synthesis time: 6.12s\rEveryoneCook-dev-Certificate: deploying...\r[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] (3/3)\rEveryoneCook-dev-Certificate: creating CloudFormation changeset...\rEveryoneCook-dev-Certificate\r‚ú® Deployment time: 125.34s\rOutputs:\rEveryoneCook-dev-Certificate.CloudFrontCertificateArn = arn:aws:acm:us-east-1:616580903213:certificate/8d53776e-0480-47d2-a6ff-4fe9b2eb6534\rEveryoneCook-dev-Certificate.CloudFrontCertificateDomain = cdn-dev.everyonecook.cloud\rEveryoneCook-dev-Certificate.ApiGatewayCertificateArn = arn:aws:acm:us-east-1:616580903213:certificate/a1b2c3d4-5678-90ef-ghij-klmnopqrstuv\rEveryoneCook-dev-Certificate.ApiGatewayCertificateDomain = *.everyonecook.cloud\rStack ARN:\rarn:aws:cloudformation:us-east-1:616580903213:stack/EveryoneCook-dev-Certificate/... Step 3: Wait for Certificate Validation ACM certificates require DNS validation. This process takes 5-10 minutes:\nACM creates CNAME validation records in Route 53 Route 53 responds with validation data ACM verifies and issues certificates Status changes from \u0026ldquo;Pending validation\u0026rdquo; to \u0026ldquo;Issued\u0026rdquo; You can monitor the validation progress in AWS Console.\nStep 4: Verify in AWS Console Navigate to ACM (us-east-1 region) Open AWS Console IMPORTANT: Switch region to N. Virginia (us-east-1) Navigate to Certificate Manager Switch AWS Console to us-east-1 region before viewing certificates\nVerify CloudFront Certificate Find certificate with domain cdn-dev.everyonecook.cloud Check status is Issued Verify DNS validation records are present ACM Certificate for CloudFront showing \u0026ldquo;Issued\u0026rdquo; status, domain name, validation method (DNS), and CNAME validation record\nVerify API Gateway Wildcard Certificate Find certificate with domain *.everyonecook.cloud Check status is Issued Verify it covers wildcard and SAN (everyonecook.cloud) ACM Wildcard Certificate for API Gateway showing domain *.everyonecook.cloud, SAN everyonecook.cloud, and validation records\nVerify DNS Validation Records in Route 53 Navigate to Route 53 \u0026gt; Hosted zones Select everyonecook.cloud hosted zone Verify CNAME validation records are created Route 53 showing CNAME validation records automatically created by ACM for certificate validation\nExpected records:\n_abc123def456.cdn-dev.everyonecook.cloud CNAME _xyz789.acm-validations.aws.\r_ghi789jkl012.everyonecook.cloud CNAME _mno345.acm-validations.aws. Cost Breakdown Monthly Costs Resource Cost Notes ACM Certificates $0/month Free for certificates used with AWS services DNS Validation Records $0/month Included in Route 53 hosted zone cost Certificate Renewal $0/month Automatic renewal (free) Total $0/month 100% free (no ongoing costs) Cost Optimization ACM certificates are free when used with CloudFront, API Gateway, ALB, etc. Automatic renewal (no manual intervention required) CloudFront WAF removed to save $9/month ($108/year) Shield Standard provides free DDoS protection Annual Savings from WAF Removal: $108/year\nCross-Stack Dependencies Imports from DNS Stack The Certificate Stack imports from DNS Stack:\n// Hardcoded Hosted Zone ID (stable, doesn\u0026#39;t change) const hostedZoneId = \u0026#39;Z018823421GWCSYG5UMHV\u0026#39;; const hostedZone = route53.HostedZone.fromHostedZoneAttributes(this, \u0026#39;HostedZone\u0026#39;, { hostedZoneId: hostedZoneId, zoneName: \u0026#39;everyonecook.cloud\u0026#39;, }); Why Hardcoded?\nCannot use Fn.importValue for cross-region references (us-east-1 ‚Üê ap-southeast-1) Hosted Zone ID is stable and never changes Alternative: Use SSM Parameter Store (more complex, same result) Exports Used By Other Stacks The Certificate Stack exports are used by:\nCore Stack (Phase 2)\nImports: CloudFrontCertificateArn Purpose: Attach SSL certificate to CloudFront distribution Region: ap-southeast-1 (cross-region import) Backend Stack (Phase 4)\nImports: ApiGatewayCertificateArn Purpose: Create API Gateway custom domain with SSL Region: ap-southeast-1 (cross-region import) Dependency Flow DNS Stack (ap-southeast-1)\r‚îÇ\r‚îú‚îÄ Hosted Zone ID: Z018823421GWCSYG5UMHV\r‚îÇ\r‚ñº\rCertificate Stack (us-east-1) ‚Üê MUST be us-east-1\r‚îÇ\r‚îú‚îÄ CloudFront Certificate ARN\r‚îÇ ‚îî‚îÄ‚ñ∫ Core Stack (ap-southeast-1)\r‚îÇ\r‚îî‚îÄ API Gateway Certificate ARN\r‚îî‚îÄ‚ñ∫ Backend Stack (ap-southeast-1) Validation Checklist Before proceeding to Core Stack deployment:\nCertificate Stack deployed to us-east-1 region CloudFront certificate status is Issued API Gateway wildcard certificate status is Issued DNS validation CNAME records visible in Route 53 Certificate ARNs exported in CloudFormation outputs Region confirmed as us-east-1 in AWS Console Tags applied correctly to all resources Next Steps After successfully deploying the Certificate Stack:\n‚û°Ô∏è 5.4.3 Core Stack - Create DynamoDB, S3, and CloudFront infrastructure\nThe Core Stack will:\nCreate DynamoDB Single Table with encryption Create S3 buckets for content and CDN logs Create CloudFront distribution with SSL certificate Import CloudFrontCertificateArn from this stack Configure custom domain cdn.everyonecook.cloud References Source Code: infrastructure/lib/stacks/certificate-stack.ts Base Stack: infrastructure/lib/base-stack.ts App Configuration: infrastructure/bin/app.ts AWS Documentation: ACM Certificates DNS Validation CloudFront with ACM Cross-Region References: CloudFormation Cross-Region References "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.03-cdk-bootstrap/",
	"title": "CDK Bootstrap",
	"tags": [],
	"description": "",
	"content": "Overview AWS CDK Bootstrap prepares your AWS account for deploying CDK applications by creating essential infrastructure resources. This is a one-time setup process per AWS account/region combination that establishes the foundation for all CDK deployments.\nWhat CDK Bootstrap Creates The bootstrap process provisions the following AWS resources in your account:\n1. S3 Bucket (CDK Assets Bucket)\nStores Lambda function deployment packages Stores CloudFormation templates Stores file assets referenced by your CDK stacks Naming pattern: cdk-hnb659fds-assets-{ACCOUNT-ID}-{REGION} Versioning enabled for rollback support 2. CloudFormation Stack (CDKToolkit)\nMain infrastructure stack containing all bootstrap resources Stack name: CDKToolkit Manages lifecycle of bootstrap resources 3. IAM Roles\ncdk-hnb659fds-cfn-exec-role: CloudFormation execution role for deploying stacks cdk-hnb659fds-deploy-role: Role used by CDK CLI during deployment cdk-hnb659fds-file-publishing-role: Role for uploading assets to S3 cdk-hnb659fds-lookup-role: Role for reading environment context 4. SSM Parameters\n/cdk-bootstrap/hnb659fds/version: Stores bootstrap version number Used for compatibility checking Infrastructure Stacks Overview After bootstrapping, our project will deploy multiple CDK stacks defined in D:\\Project_AWS\\everyonecook\\infrastructure\\lib\\stacks:\nauth-stack.ts: Authentication and authorization infrastructure (Cognito) backend-stack.ts: Core backend services and Lambda functions certificate-stack.ts: SSL/TLS certificates management core-stack.ts: Core infrastructure resources dns-stack.ts: Route 53 DNS configuration observability-stack.ts: Monitoring, logging, and observability These stacks depend on the bootstrap infrastructure to deploy successfully.\nLab Instructions: Bootstrap Your AWS Account Prerequisites Before beginning this lab, ensure you have:\nAWS CLI installed and configured (see section 5.1) AWS CDK CLI installed (see section 5.2) Valid AWS credentials configured IAM user with AdministratorAccess permissions or equivalent Terminal/PowerShell access to the project directory Step 3: Verify on AWS Console Confirm resources in the AWS Management Console. 3.1. Verify CloudFormation Stack\nOpen CloudFormation Console Look for stack named CDKToolkit Status should be CREATE_COMPLETE Click on Resources tab to view created resources ** Screenshot Required:** 3.2. Verify S3 Bucket\nOpen S3 Console Find bucket: cdk-hnb659fds-assets-{ACCOUNT-ID}-us-east-1 Verify bucket properties: Versioning: Enabled ** Screenshot Required:** 3.3. Verify IAM Roles\nOpen IAM Roles Console Search for: cdk-hnb659fds Verify the following roles exist: cdk-hnb659fds-cfn-exec-role-{ACCOUNT-ID}-us-east-1 cdk-hnb659fds-deploy-role-{ACCOUNT-ID}-us-east-1 cdk-hnb659fds-file-publishing-role-{ACCOUNT-ID}-us-east-1 cdk-hnb659fds-lookup-role-{ACCOUNT-ID}-us-east-1 Understanding Bootstrap Resources S3 Bucket Details The CDK assets bucket serves as a central repository for all deployment artifacts:\nPurpose: Stores CloudFormation templates, Lambda deployment packages, and static assets Lifecycle: Persists across deployments, enabling rollback capabilities Security: Encrypted at rest, bucket policies restrict access to authorized roles Naming: Deterministic naming based on account ID and region 1. CloudFormation Execution Role (cfn-exec-role)\nUsed by CloudFormation to create/update/delete stack resources Has broad permissions to manage AWS resources Trust relationship with CloudFormation service 2. Deploy Role (deploy-role)\nUsed by CDK CLI during cdk deploy operations Can assume the CloudFormation execution role Has permissions to upload assets and initiate deployments 3. File Publishing Role (file-publishing-role)\n4. Image Publishing Role (image-publishing-role)\n5. Lookup Role (lookup-role)\nReads environment context (VPCs, subnets, etc.) Read-only permissions for resource lookups Used during synthesis for context queries Cost Analysis Bootstrap Resources Cost One-time Setup:\nCloudFormation stack creation: Free IAM roles creation: Free SSM parameters: Free Ongoing Monthly Costs:\nResource Usage Cost (Estimated) S3 Storage \u0026lt; 1 GB (typical) $0.023/GB = ~$0.02/month S3 Requests Minimal (GET/PUT) ~$0.01/month IAM Roles No charge $0.00 Total Estimated Cost: ~$0.03/month (negligible)\nNote: For serverless applications, costs remain minimal as we only store Lambda deployment packages in S3.\nLab Completion Checklist Ensure you have completed all steps and captured required screenshots:\nStep 1: Bootstrap command execution and success - [IMAGE HERE: bootstrap-success.png] Step 2: CLI verification results - [IMAGE HERE: bootstrap-verification-cli.png] Step 3.1: CloudFormation console - [IMAGE HERE: cloudformation-cdktoolkit.png] Step 3.2: S3 bucket console - [IMAGE HERE: s3-bucket-console.png] Step 3.3: IAM roles console - [IMAGE HERE: iam-roles-console.png] Verified AWS account bootstrap status\nRetrieved your AWS account ID\nExecuted CDK bootstrap command\nCreated CDKToolkit CloudFormation stack\nProvisioned CDK assets S3 bucket\nCreated necessary IAM roles for CDK deployments\nVerified bootstrap version in SSM Parameter Store\nUnderstood the purpose and cost of each bootstrap resource In this lab, you successfully:\nExecuted CDK bootstrap command for your AWS account\nCreated CDKToolkit CloudFormation stack\nProvisioned CDK assets S3 bucket for storing Lambda packages\nCreated necessary IAM roles for CDK deployments\nVerified all resources via CLI and AWS Console\nYour AWS account is now ready to deploy serverless CDK applications, including the infrastructure stacks for the EveryoneCook project.\nPrepare for infrastructure deployment "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/4-eventparticipated/4.3-event3/",
	"title": "Event 3",
	"tags": [],
	"description": "",
	"content": "Event Report: AWS Cloud Mastery Series #2 ‚Äî DevOps on AWS Event Purpose Strengthen understanding of the DevOps mindset, culture, and core principles. Introduce AWS services that support CI/CD workflows: CodeCommit, CodeBuild, CodeDeploy, and CodePipeline. Provide an in-depth look into Infrastructure as Code (IaC) using CloudFormation and AWS CDK. Explore container technologies (ECS, EKS, App Runner) and observability tools (CloudWatch, X-Ray). Highlights Morning Session: CI/CD Pipeline \u0026amp; Infrastructure as Code (08:30 ‚Äì 12:00) Revisited DevOps culture with emphasis on DORA metrics such as Deployment Frequency and Mean Time to Recovery. CI/CD components: CodeCommit for version control and Git workflow comparisons (GitFlow vs. trunk-based). CodeBuild for automated building and testing. CodeDeploy for deployment strategies (Blue/Green, Canary, Rolling). CodePipeline for end-to-end automation and orchestration. Live demo showcasing a complete CI/CD pipeline from source to deployment. IaC topics: CloudFormation: templates, stack management, drift detection. AWS CDK: constructs, reusable patterns, multi-language support. Demo + discussion about choosing between CloudFormation and CDK for different use cases. Afternoon Session: Containers, Observability \u0026amp; Best Practices (13:00 ‚Äì 17:00) Container services overview: Docker fundamentals and best practices. Amazon ECR for container image storage, security scanning, and lifecycle policies. ECS \u0026amp; EKS: orchestration, autoscaling, and deployment strategies. App Runner: simplified PaaS-style container deployment. Observability: CloudWatch for metrics, logs, alarms, and dashboards. AWS X-Ray for distributed tracing and microservice debugging. Best practices: Feature flags and A/B testing approaches. Incident management and effective postmortems. Demo \u0026amp; case study comparing microservice deployment patterns and trade-offs. Key Takeaways Solidified understanding of DevOps culture, DORA metrics, and automation-driven workflows. Learned how AWS Code services integrate to form a complete CI/CD pipeline, along with modern deployment strategies (Blue/Green, Canary). Gained foundational expertise in CloudFormation and AWS CDK, enabling better template optimization and multi-stack architecture design. Recognized the importance of monitoring and observability with CloudWatch and X-Ray for diagnosing issues such as CORS errors and Lambda failures. Container technologies (ECS/EKS) provide a strong base for designing more scalable architectures in future projects. Hands-on demos improved practical understanding of CI/CD and IaC implementation. Event Experience The workshop offered a full day of structured, practical learning with a strong emphasis on real-world application. Demonstrations and case studies made the concepts easy to map directly into ongoing project work. The event also provided valuable opportunities to connect with industry experts and the AWS community. "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/1.3-week3/",
	"title": "Week 3 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 3 Objectives: Implement comprehensive monitoring and observability strategies using Amazon CloudWatch (Metrics, Logs, Alarms, Dashboards). Establish Hybrid DNS architectures to integrate on-premises networks with AWS using Route 53 Resolver and Microsoft Active Directory. Achieve proficiency in AWS CLI for advanced resource management (Infrastructure as Code basics) and automation across Storage, Networking, Identity, and Compute services. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 Monitoring \u0026amp; Observability (CloudWatch) - Configure CloudWatch Metrics: Viewing, Search expressions, Math expressions - Analyze logs with CloudWatch Logs Insights \u0026amp; Metric Filters - Set up CloudWatch Alarms for proactive monitoring - Create unified CloudWatch Dashboards - Practice: Visualize EC2 performance and set up alerts for high CPU usage. 22/09/2025 22/09/2025 https://000008.awsstudygroup.com/ 3 Hybrid Connectivity \u0026amp; DNS - Deploy Microsoft Active Directory (AD) - Configure Remote Desktop Gateway (RDGW) for secure access - Setup Hybrid DNS with Route 53 Resolver: + Create Outbound/Inbound Endpoints + Configure Resolver Rules - Test DNS resolution between simulated on-prem and AWS environments. 23/09/2025 23/09/2025 https://000010.awsstudygroup.com/ 4 AWS CLI Mastery - Part 1 (Setup \u0026amp; Storage) - Install and Configure AWS CLI v2 - S3 Automation: Manage buckets, perform multipart uploads via CLI - Messaging: Manage Amazon SNS topics and subscriptions via CLI - Explore CLI output formats (json, table, text) and filtering. 24/09/2025 24/09/2025 https://000011.awsstudygroup.com/ https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-troubleshooting.html 5 AWS CLI Mastery - Part 2 (Compute \u0026amp; Network) - IAM Security: Manage users, roles, and assume roles via CLI + Handle MFA tokens with CLI - Network Infrastructure: Deploy VPC, Subnets, and Internet Gateways via CLI - Compute: Launch and configure EC2 instances entirely through command line. 25/09/2025 25/09/2025 https://000011.awsstudygroup.com/ Deep Dive: AWS Command Line Interface 6 AWS CLI Mastery - Part 3 (Troubleshoot \u0026amp; Cleanup) - Troubleshooting: Diagnose common CLI errors (credentials, permissions, formatting) - Advanced Auth: Store SAML credentials - Perform full resource cleanup using CLI commands to ensure no lingering costs. 26/09/2025 26/09/2025 https://000011.awsstudygroup.com/ AWS re:Invent 2019: Introduction to the AWS CLI v2 Week 3 Achievements Observability \u0026amp; Monitoring Successfully deployed a monitoring stack using Amazon CloudWatch. Created custom Dashboards to visualize critical metrics (CPU, Memory, Disk I/O) in real-time. Configured CloudWatch Alarms to trigger automated notifications via SNS when thresholds were breached. Mastered Logs Insights to query and analyze application log data effectively. Hybrid Networking Designed and implemented a Hybrid DNS solution bridging on-premises and cloud environments. Deployed Microsoft Active Directory on AWS and integrated it with Route 53. Configured Route 53 Resolver Endpoints (Inbound/Outbound) and Forwarding Rules to resolve domain names across the hybrid network. Verified secure connectivity using Remote Desktop Gateway (RDGW). Advanced Infrastructure Management (CLI) Transitioned from Console-based management to Command Line Interface (CLI) operations. Automating resource provisioning: Storage: Created S3 buckets and managed object lifecycles/uploads. Security: Managed IAM users, policies, and practiced Assuming Roles for cross-account access. Networking: Built a complete VPC stack (VPC, Subnets, IGW, Route Tables) using CLI commands. Compute: Launched EC2 instances with user-data scripts via CLI. Gained troubleshooting skills for CLI configuration, credential management (MFA/SAML), and API error handling. "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/3-blogstranslated/3.3-blog3/",
	"title": "Blog 3: Centralized AWS Firewall Policy Management with AlgoSec",
	"tags": [],
	"description": "",
	"content": "Overview: Challenges of Hybrid Environments As enterprises migrate workloads from on-premise to AWS, maintaining consistent security policies becomes a major challenge. AWS Firewall Manager helps centrally manage security rules in the cloud, but organizations often struggle to synchronize these rules with traditional on-premise firewall infrastructure.\nA new solution from AlgoSec (available on AWS Marketplace) integrates directly with AWS Firewall Manager, providing unified visibility and management across the entire Hybrid Cloud environment.\n1. Introduction to AlgoSec Horizon and ACE AlgoSec\u0026rsquo;s solution consists of two integrated main components:\nAlgoSec Horizon: Focuses on visibility, application mapping, and providing business context for network flows. AlgoSec Cloud Enterprise (ACE): Manages security policies, risk analysis, and change automation. Benefits of deploying through AWS Marketplace:\nSimple procurement: Direct integration into AWS billing (Unified billing). Fast deployment: Streamlined onboarding for immediate time-to-value. Scalability: Easy to extend policy control across all environments. 2. Unified Firewall Policy Visibility After logging into the ACE console, the AWS Firewall Policies tab displays all deployed AWS firewalls along with their associated policies. Users can view detailed information for each firewall, including VPC, Availability Zones, and Subnets.\n[Figure 1] The main page displays the list of Firewalls, Policy Sets, and Rules.\nContextual visibility is a key strength of the solution. When hovering over a firewall name, the system immediately displays VPC context and related applications.\n[Figure 2] VPC context displayed when hovering over the Firewall name, helping administrators immediately understand location and scope of impact.\n3. Detailed Rule and Application Analysis AWS Firewall policies typically include two rule groups: Stateless and Stateful. AlgoSec allows you to expand and view details of each rule group.\n[Figure 3] The expanded view displays detailed Stateless and Stateful rule groups within a policy set.\nMore importantly, AlgoSec Horizon links this technical information with business context. Users can view Application Diagrams, Application Owners, and connection status from on-premise to cloud.\n[Figure 4] Application View displays connection diagrams, contact information, and compliance status of business applications.\nConclusion The combination of AWS Firewall Manager and AlgoSec provides a \u0026ldquo;single pane of glass\u0026rdquo; for security teams. Instead of fragmented management, they can now:\nAnalyze AWS configurations like traditional firewalls. Perform change simulation before applying to avoid business disruption. Ensure continuous compliance across the entire Hybrid environment. Authors Joseph Hallman\rJoseph is a Product Marketing Manager at AlgoSec with over 20 years of experience in networking and data center markets. He has worked at both startups and global enterprises, bringing expertise in sales, product management, and marketing strategy.\nAmit Gaur\rAmit is a Cloud Infrastructure Architect at AWS, specializing in network architecture design. He helps customers build highly scalable and resilient environments on AWS.\nSrivalsan Mannoor Sudhagar\rSrivalsan is a Sr. Cloud Infrastructure Architect at Amazon Web Services, Professional Services who brings expertise in Cloud Infrastructure and MLOps platforms.\nSaleem Muhammad\rSaleem is a Senior Manager of Product Management in AWS Network \u0026 Application Protection. He is passionate about building solutions that help customers to secure mission critical workloads.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/3-blogstranslated/",
	"title": "Translated Blogs",
	"tags": [],
	"description": "",
	"content": "Blog 1 - AWS Named as a Leader in 2025 Gartner Magic Quadrant for Strategic Cloud Platform Services for 15 Years in a Row This blog highlights AWS being recognized once again as a Leader in the 2025 Gartner Magic Quadrant for Strategic Cloud Platform Services, marking the 15th consecutive year of leadership. It explains why AWS earned this recognition: strong ability to execute, comprehensive strategic vision, and the broadest cloud services portfolio. The post also emphasizes AWS‚Äôs continued investment in innovation across AI/ML, data and analytics, security, and global infrastructure to empower customers‚Äîfrom startups and enterprises to public sector organizations‚Äîto build, run, and innovate on the cloud.\nBlog 2 - Qwen Models are Now Available in Amazon Bedrock This blog announces that Qwen models, developed by Alibaba Cloud, are now available in Amazon Bedrock, enabling customers to build and scale generative AI applications with advanced NLP, multilingual support, strong reasoning capabilities, and seamless integration with AWS services‚Äîwithout the need to manage infrastructure.\nBlog 3 - Centralized AWS Firewall Policy Management with AlgoSec This blog introduces a solution from AlgoSec (available on AWS Marketplace) that integrates with AWS Firewall Manager to provide unified visibility and management across Hybrid Cloud environments. The solution combines AlgoSec Horizon (for visibility and application mapping) and AlgoSec Cloud Enterprise (ACE) (for security policy management and risk analysis). Key benefits include centralized firewall policy visibility across AWS and on-premise infrastructure, contextual business application mapping, detailed rule analysis for both Stateless and Stateful rule groups, and change simulation capabilities to prevent business disruption‚Äîgiving security teams a \u0026ldquo;single pane of glass\u0026rdquo; for comprehensive firewall governance.\nBlog 4 - Your Essential Guide to Cloud Governance at AWS re:Invent 2025 This blog provides an overview of the Cloud Governance track at AWS re:Invent 2025, highlighting how governance has evolved from a compliance obligation into a strategic driver of business innovation. It introduces the main focus areas, including generative AI and intelligent governance, operational efficiency and cost optimization, secure operations and automation, and multicloud and sovereign cloud requirements. The post also showcases key sessions on policy-as-code, AI-driven compliance automation, and global governance strategies, equipping organizations with the skills to modernize and scale their governance frameworks across complex cloud environments.\nBlog 5 - Solution-Centric Procurement Strategy on AWS Marketplace This blog announces AWS Marketplace\u0026rsquo;s strategic shift to solution-centric procurement, introducing Multi-product solutions that allow Partners to bundle software, services, and data from multiple vendors into a single comprehensive solution package. This transformation helps enterprises purchase complete business outcomes (such as a full Security Operations Center solution) instead of acquiring individual tools separately. Key benefits include a single negotiation point, flexible component customization, centralized governance, and streamlined procurement processes. The feature supports ISVs, Channel Partners, and System Integrators to create bundled offerings, while enhanced Generative AI-powered search helps customers discover solutions based on use cases and industries rather than just product names.\nBlog 6 - Top 10 AWS Cloud Operations Announcements at re:Invent 2025 This blog summarizes the top 10 announcements for AWS Cloud Operations at re:Invent 2025, focusing on applying Generative AI to enhance observability and troubleshooting while simplifying large-scale operational data management. Key highlights include Generative AI observability for AI applications on CloudWatch, automatic service discovery with Application Map, AI-powered root cause analysis using the \u0026ldquo;5 Whys\u0026rdquo; methodology, Model Context Protocol (MCP) server support, GitHub Actions integration for observability, enhanced log analytics on OpenSearch Service, Real User Monitoring (RUM) for mobile platforms (iOS/Android), CloudTrail Event Aggregation to reduce storage costs, and multi-account/multi-region centralization for both logs and database monitoring. These innovations help operators shift from reactive to proactive system control through AI automation and centralized visibility.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.04-configure-stacks/5.4.3-core-stack/",
	"title": "5.4.3 Core Stack",
	"tags": [],
	"description": "",
	"content": " Core Stack - Data Layer Infrastructure Overview The Core Stack is the Phase 2 foundational data layer of the EveryoneCook project. It creates the core infrastructure for data storage, content delivery, and encryption that all other services depend on.\nDeployment Order: This stack MUST be deployed after Certificate Stack and before Auth Stack and Backend Stack.\nKey Responsibilities Create DynamoDB Single Table with 5 GSI indexes for username-based queries Create S3 buckets with Intelligent-Tiering for cost optimization (57% savings) Create CloudFront CDN distribution with compression and caching Create KMS encryption keys for DynamoDB and S3 Configure Origin Access Control (OAC) for S3 security Setup custom domain with SSL certificate for CDN What This Stack Includes Storage:\nDynamoDB Single Table with encryption at rest S3 Content Bucket (avatars, posts, recipes, backgrounds) S3 CDN Logs Bucket for CloudFront access logs CDN \u0026amp; Caching:\nCloudFront Distribution with custom domain Compression enabled (Gzip + Brotli, 70-80% size reduction) Cache policies (24h default, 7 days max) Origin Access Control (OAC) for S3 security Security:\nKMS Customer Managed Keys for encryption Automatic key rotation (yearly) Security headers (HSTS, X-Frame-Options, etc.) Cost Optimization:\nS3 Intelligent-Tiering (57% cost reduction) CloudFront Price Class 200 (45% cost reduction) Pay-per-request billing for dev environment Architecture ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ Core Stack (Phase 2) ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ KMS Encryption Layer ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ DynamoDB Key (automatic rotation) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ S3 Key (automatic rotation) ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚ñº ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ DynamoDB Single Table ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ PK: USER#{username} ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ SK: PROFILE|RECIPE#{id}|POST#{id} ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ 5 GSI indexes for queries ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Billing: PAY_PER_REQUEST (dev) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Encryption: Customer Managed KMS ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Streams: Enabled (NEW_AND_OLD_IMAGES) ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚ñº ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ S3 Content Bucket ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Folders: avatars/, posts/, recipes/, backgrounds/ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Intelligent-Tiering (57% savings) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ Archive: 90 days, Deep Archive: 180 days ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Encryption: S3 Managed Keys ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Versioning: Enabled (prod) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ CORS: Configured for frontend ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ OAC: CloudFront access only ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚ñº ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ CloudFront CDN Distribution ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Custom Domain: cdn.everyonecook.cloud ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Certificate: ACM (us-east-1) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Compression: Gzip + Brotli (70-80% reduction) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Cache TTL: 24h default, 7 days max ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Price Class: 200 (US, EU, Asia - 45% savings) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Security: HTTPS redirect, Security headers ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Protection: Shield Standard (free DDoS) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Logs: S3 CDN Logs Bucket ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚ñº ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ Route 53 DNS Record (from DNS Stack) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ cdn.everyonecook.cloud ‚Üí CloudFront (A + AAAA Alias) ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ\r‚îÇ Exports\r‚ñº\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚ñº ‚ñº\rAuth Stack Backend Stack\r(Cognito) (API Gateway, Lambda) Stack Configuration File Structure infrastructure/lib/stacks/\r‚îî‚îÄ‚îÄ core-stack.ts # Core Stack implementation (1545 lines) Code Implementation Highlights File: infrastructure/lib/stacks/core-stack.ts\n1. KMS Keys Creation /** * Create KMS key for DynamoDB encryption */ private createDynamoDBKey(): cdk.aws_kms.Key { const key = new cdk.aws_kms.Key(this, \u0026#39;DynamoDBKey\u0026#39;, { alias: `everyonecook-dynamodb-${this.config.environment}`, description: `KMS key for DynamoDB encryption in ${this.config.environment} environment`, // Enable automatic key rotation (yearly) enableKeyRotation: true, // Deletion protection for production pendingWindow: this.config.environment === \u0026#39;prod\u0026#39; ? cdk.Duration.days(30) : cdk.Duration.days(7), // Removal policy: RETAIN for prod, DESTROY for dev/staging removalPolicy: this.config.environment === \u0026#39;prod\u0026#39; ? cdk.RemovalPolicy.RETAIN : cdk.RemovalPolicy.DESTROY, }); // Add key policy for DynamoDB service key.addToResourcePolicy( new cdk.aws_iam.PolicyStatement({ sid: \u0026#39;Allow DynamoDB to use the key\u0026#39;, effect: cdk.aws_iam.Effect.ALLOW, principals: [new cdk.aws_iam.ServicePrincipal(\u0026#39;dynamodb.amazonaws.com\u0026#39;)], actions: [\u0026#39;kms:Decrypt\u0026#39;, \u0026#39;kms:DescribeKey\u0026#39;, \u0026#39;kms:CreateGrant\u0026#39;], resources: [\u0026#39;*\u0026#39;], conditions: { StringEquals: { \u0026#39;kms:ViaService\u0026#39;: `dynamodb.${this.region}.amazonaws.com`, }, }, }) ); return key; } 2. DynamoDB Single Table /** * Create DynamoDB Single Table with cost optimization */ private createDynamoDBTable(): cdk.aws_dynamodb.Table { const tableName = `EveryoneCook-${this.config.environment}-v2`; const dbConfig = this.config.dynamodb; const table = new cdk.aws_dynamodb.Table(this, \u0026#39;EveryoneCookTable\u0026#39;, { tableName, partitionKey: { name: \u0026#39;PK\u0026#39;, type: cdk.aws_dynamodb.AttributeType.STRING }, sortKey: { name: \u0026#39;SK\u0026#39;, type: cdk.aws_dynamodb.AttributeType.STRING }, // Billing mode: PROVISIONED for prod/staging, PAY_PER_REQUEST for dev billingMode: dbConfig.billingMode === \u0026#39;PROVISIONED\u0026#39; ? cdk.aws_dynamodb.BillingMode.PROVISIONED : cdk.aws_dynamodb.BillingMode.PAY_PER_REQUEST, // Point-in-time recovery for prod/staging pointInTimeRecoverySpecification: { pointInTimeRecoveryEnabled: dbConfig.pointInTimeRecovery, }, // Deletion protection for production deletionProtection: dbConfig.deletionProtection, // Enable DynamoDB Streams stream: dbConfig.streamEnabled ? cdk.aws_dynamodb.StreamViewType.NEW_AND_OLD_IMAGES : undefined, // TTL attribute for automatic cleanup timeToLiveAttribute: \u0026#39;ttl\u0026#39;, // Encryption with customer managed KMS key encryption: cdk.aws_dynamodb.TableEncryption.CUSTOMER_MANAGED, encryptionKey: this.dynamoDbKey, // Removal policy removalPolicy: this.config.environment === \u0026#39;prod\u0026#39; ? cdk.RemovalPolicy.RETAIN : cdk.RemovalPolicy.DESTROY, }); // Add 5 GSI indexes (code continues...) return table; } 3. S3 Bucket with Intelligent-Tiering /** * Create S3 bucket with Intelligent-Tiering for 57% cost savings */ private createContentBucket(): cdk.aws_s3.Bucket { const bucketName = `everyonecook-content-${this.config.environment}`; const s3Config = this.config.s3; const bucket = new cdk.aws_s3.Bucket(this, \u0026#39;ContentBucket\u0026#39;, { bucketName, // Block ALL public access (private bucket) blockPublicAccess: cdk.aws_s3.BlockPublicAccess.BLOCK_ALL, // Enable versioning for production versioned: s3Config.versioning, // S3-managed encryption encryption: cdk.aws_s3.BucketEncryption.S3_MANAGED, // Intelligent-Tiering configuration intelligentTieringConfigurations: [{ name: \u0026#39;EntireBucket\u0026#39;, archiveAccessTierTime: cdk.Duration.days(90), // Archive tier deepArchiveAccessTierTime: cdk.Duration.days(180), // Deep Archive }], // Lifecycle rules lifecycleRules: [ { id: \u0026#39;DeleteOldVersions\u0026#39;, enabled: s3Config.versioning, noncurrentVersionExpiration: cdk.Duration.days(30), }, { id: \u0026#39;DeleteTempUploads\u0026#39;, enabled: true, prefix: \u0026#39;posts/temp/\u0026#39;, expiration: cdk.Duration.days(1), // Clean up temp files after 24h }, ], // CORS for frontend access cors: [{ allowedOrigins: [ `https://${this.config.domain.frontend}`, ...(this.config.environment === \u0026#39;dev\u0026#39; ? [\u0026#39;http://localhost:3000\u0026#39;] : []), ], allowedMethods: [ cdk.aws_s3.HttpMethods.GET, cdk.aws_s3.HttpMethods.PUT, cdk.aws_s3.HttpMethods.POST, cdk.aws_s3.HttpMethods.DELETE, ], allowedHeaders: [\u0026#39;*\u0026#39;], exposedHeaders: [\u0026#39;ETag\u0026#39;], maxAge: 3000, }], removalPolicy: this.config.environment === \u0026#39;prod\u0026#39; ? cdk.RemovalPolicy.RETAIN : cdk.RemovalPolicy.DESTROY, }); return bucket; } 4. CloudFront Distribution /** * Create CloudFront distribution with compression and caching */ private createCloudFrontDistribution(): cdk.aws_cloudfront.Distribution { // Import Route 53 Hosted Zone const hostedZone = cdk.aws_route53.HostedZone.fromHostedZoneAttributes( this, \u0026#39;HostedZone\u0026#39;, { hostedZoneId: cdk.Fn.importValue(this.exportName(\u0026#39;HostedZoneId\u0026#39;)), zoneName: \u0026#39;everyonecook.cloud\u0026#39;, } ); // Import ACM certificate from Certificate Stack (us-east-1) const certificate = cdk.aws_certificatemanager.Certificate.fromCertificateArn( this, \u0026#39;ImportedCloudFrontCertificate\u0026#39;, \u0026#39;arn:aws:acm:us-east-1:616580903213:certificate/8d53776e-0480-47d2-a6ff-4fe9b2eb6534\u0026#39; ); // Create cache policy with compression const publicCachePolicy = new cdk.aws_cloudfront.CachePolicy( this, \u0026#39;PublicCachePolicy\u0026#39;, { cachePolicyName: `EveryoneCook-Public-${this.config.environment}`, defaultTtl: cdk.Duration.hours(24), // 24h default maxTtl: cdk.Duration.days(7), // 7 days max minTtl: cdk.Duration.seconds(0), // Enable compression (Gzip + Brotli) enableAcceptEncodingGzip: true, enableAcceptEncodingBrotli: true, queryStringBehavior: cdk.aws_cloudfront.CacheQueryStringBehavior.all(), headerBehavior: cdk.aws_cloudfront.CacheHeaderBehavior.allowList( \u0026#39;CloudFront-Viewer-Country\u0026#39; ), cookieBehavior: cdk.aws_cloudfront.CacheCookieBehavior.none(), } ); // Create CloudFront distribution const distribution = new cdk.aws_cloudfront.Distribution( this, \u0026#39;CDNDistribution\u0026#39;, { comment: `Everyone Cook CDN - ${this.config.environment}`, // Default behavior with OAC defaultBehavior: { origin: origins.S3BucketOrigin.withOriginAccessControl(this.contentBucket), viewerProtocolPolicy: cdk.aws_cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS, compress: true, cachePolicy: publicCachePolicy, allowedMethods: cdk.aws_cloudfront.AllowedMethods.ALLOW_GET_HEAD_OPTIONS, }, // Price Class 200 (US, Europe, Asia - 45% cost savings) priceClass: cdk.aws_cloudfront.PriceClass.PRICE_CLASS_200, // Custom domain with SSL domainNames: [this.config.domains.cdn], certificate: certificate, // CloudFront access logs enableLogging: true, logBucket: this.cdnLogsBucket, logFilePrefix: \u0026#39;cdn-access-logs/\u0026#39;, // Enable IPv6 enableIpv6: true, // HTTP/2 + HTTP/3 httpVersion: cdk.aws_cloudfront.HttpVersion.HTTP2_AND_3, // TLS 1.2 minimum minimumProtocolVersion: cdk.aws_cloudfront.SecurityPolicyProtocol.TLS_V1_2_2021, } ); // Create Route 53 A record (Alias to CloudFront) new cdk.aws_route53.ARecord(this, \u0026#39;CloudFrontAliasRecord\u0026#39;, { zone: hostedZone, recordName: this.config.domains.cdn, target: cdk.aws_route53.RecordTarget.fromAlias( new targets.CloudFrontTarget(distribution) ), }); return distribution; } Key Configuration Details 1. DynamoDB Single Table Design Table Structure:\nPK: USER#{username}\rSK: PROFILE | RECIPE#{recipeId} | POST#{postId} | COMMENT#{commentId}\rGSI1: username-recipeDate (user\u0026#39;s recipes by date)\rGSI2: username-postDate (user\u0026#39;s posts by date)\rGSI3: recipeId-index (recipe lookup)\rGSI4: postId-index (post lookup)\rGSI5: email-index (email lookup) Billing Modes:\nDev: PAY_PER_REQUEST (no provisioned capacity, pay per request) Staging: PROVISIONED (5 RCU, 5 WCU with auto-scaling) Prod: PROVISIONED (10 RCU, 10 WCU with auto-scaling) 2. S3 Intelligent-Tiering Cost Savings Cost Comparison (100GB content):\nTier Cost per GB 100GB Cost Timeline Frequent Access $0.023 $2.30/month Default Infrequent Access $0.0125 $1.25/month After 30 days Archive Instant $0.004 $0.40/month After 90 days Archive $0.0036 $0.36/month After 90 days Deep Archive $0.00099 $0.099/month After 180 days Savings: $2.30 ‚Üí $0.099 = 57% cost reduction after 12 months\n3. CloudFront Compression File Size Reduction:\nText files (HTML, CSS, JS, JSON): 70-80% reduction Images (already compressed): No additional compression Videos (already compressed): No additional compression Example:\nOriginal JS bundle: 1MB ‚Üí Compressed: 200KB (80% reduction) 1000 requests/day: 1GB/day ‚Üí 200MB/day (saves 800MB bandwidth) 4. CloudFront Price Class 200 Cost Comparison:\nPrice Class Regions Cost per GB Savings All All regions $0.085 Baseline 200 US, EU, Asia $0.047 45% savings 100 US, EU only $0.025 71% savings (but limited coverage) Decision: Price Class 200 balances cost (45% savings) with global coverage.\nStack Outputs After deployment, the stack exports the following values:\nOutput Name Value Used By DynamoDBTableName EveryoneCook-dev-v2 Auth Stack, Backend Stack DynamoDBTableArn arn:aws:dynamodb:... Lambda IAM policies DynamoDBTableStreamArn arn:aws:dynamodb:... Event-driven processing DynamoDBKeyId KMS Key ID Encryption references DynamoDBKeyArn arn:aws:kms:... Lambda permissions S3KeyId KMS Key ID S3 encryption ContentBucketName everyonecook-content-dev Backend Stack, Lambda ContentBucketArn arn:aws:s3:... IAM policies CloudFrontDistributionId E1234567890ABC Backend Stack (WAF) CloudFrontDomainName d1234567890.cloudfront.net DNS verification Deployment Steps Step 1: Verify Prerequisites Before deploying Core Stack, ensure:\nDNS Stack successfully deployed Certificate Stack successfully deployed (us-east-1) CloudFront certificate status is Issued Route 53 DNS delegation working Step 2: Deploy Core Stack Navigate to infrastructure directory:\ncd D:\\Project_AWS\\everyonecook\\infrastructure Deploy Core Stack to ap-southeast-1:\n# Deploy Core Stack npx cdk deploy EveryoneCook-dev-Core --context environment=dev Expected output:\n‚ú® Synthesis time: 8.45s\rEveryoneCook-dev-Core: deploying...\r[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] (12/12)\rEveryoneCook-dev-Core: creating CloudFormation changeset...\rEveryoneCook-dev-Core\r‚ú® Deployment time: 450.23s\rOutputs:\rEveryoneCook-dev-Core.DynamoDBTableName = EveryoneCook-dev-v2\rEveryoneCook-dev-Core.ContentBucketName = everyonecook-content-dev\rEveryoneCook-dev-Core.CloudFrontDistributionId = E2ABCDEFGHIJKL\rEveryoneCook-dev-Core.CloudFrontDomainName = d1a2b3c4d5e6f7.cloudfront.net\rEveryoneCook-dev-Core.StackInfo = Core Stack for dev environment\rStack ARN:\rarn:aws:cloudformation:ap-southeast-1:616580903213:stack/EveryoneCook-dev-Core/... Step 3: Wait for CloudFront Distribution CloudFront distribution deployment takes 15-20 minutes. You can monitor progress:\n# Check CloudFront distribution status aws cloudfront get-distribution --id E2ABCDEFGHIJKL --query \u0026#39;Distribution.Status\u0026#39; Status progression:\nInProgress (0-15 minutes) Deployed (ready to use) Step 4: Verify in AWS Console Navigate to DynamoDB Open AWS Console ‚Üí ap-southeast-1 region Go to DynamoDB \u0026gt; Tables Find table EveryoneCook-dev-v2 DynamoDB table showing partitionKey (PK), sortKey (SK), 5 GSI indexes, billing mode (PAY_PER_REQUEST), encryption (KMS), and streams enabled\nVerify:\nPartition key: PK (String) Sort key: SK (String) 5 GSI indexes visible Billing mode: PAY_PER_REQUEST (dev) Encryption: Customer managed KMS Streams: Enabled (NEW_AND_OLD_IMAGES) Navigate to S3 Go to S3 \u0026gt; Buckets Find buckets: everyonecook-content-dev everyonecook-cdn-logs-dev S3 content bucket showing folder structure (avatars/, posts/, recipes/, backgrounds/), Intelligent-Tiering configuration, versioning, CORS, and encryption settings\nVerify Content Bucket:\nBlock all public access: On Versioning: Enabled (prod) / Disabled (dev) Intelligent-Tiering: Configured Encryption: S3-managed keys CORS: Configured Lifecycle rules: 2 rules S3 Intelligent-Tiering configuration showing Archive Access Tier (90 days) and Deep Archive Access Tier (180 days)\nNavigate to CloudFront Go to CloudFront \u0026gt; Distributions Find distribution with domain cdn-dev.everyonecook.cloud CloudFront distribution showing custom domain, origin (S3 with OAC), cache behaviors, compression enabled, Price Class 200, SSL certificate, and status (Deployed)\nVerify:\nStatus: Deployed Domain: cdn-dev.everyonecook.cloud Origin: S3 bucket with OAC Compression: Enabled Price Class: 200 SSL Certificate: Valid HTTPS: Redirect CloudFront Origin Access Control (OAC) configuration showing S3 origin with OAC policy automatically created\nNavigate to KMS Go to KMS \u0026gt; Customer managed keys Find keys: everyonecook-dynamodb-dev everyonecook-s3-dev KMS customer managed keys showing key aliases, key rotation enabled (yearly), key policies, and usage by DynamoDB and S3\nVerify:\nKey rotation: Enabled Key state: Enabled Deletion protection: Configured Key policy: DynamoDB/S3 service access Verify Route 53 DNS Record Go to Route 53 \u0026gt; Hosted zones Select everyonecook.cloud Verify A record for cdn-dev.everyonecook.cloud Route 53 A record (Alias) pointing cdn-dev.everyonecook.cloud to CloudFront distribution\nExpected:\ncdn-dev.everyonecook.cloud A Alias d1a2b3c4d5e6f7.cloudfront.net Cost Breakdown Monthly Costs (Dev Environment) Resource Configuration Monthly Cost Notes DynamoDB PAY_PER_REQUEST $1-5 Low traffic S3 Content 10GB, Intelligent-Tiering $0.23 Moves to Deep Archive S3 Logs 5GB $0.12 Access logs CloudFront 100GB transfer, Price Class 200 $4.70 45% savings vs All KMS 2 keys $2.00 $1/key/month Route 53 1 hosted zone, DNS queries $0.50 From DNS Stack Total (Estimated) ~$8-13/month Low traffic scenario Cost Optimization Strategies S3 Intelligent-Tiering: 57% savings on storage CloudFront Price Class 200: 45% savings on bandwidth DynamoDB PAY_PER_REQUEST (dev): Pay only for actual usage CloudFront WAF removed: $9/month savings Compression enabled: 70-80% bandwidth reduction Total Potential Savings: ~$20-30/month compared to non-optimized setup\nCross-Stack Dependencies Imports from Previous Stacks From DNS Stack:\nhostedZoneId: cdk.Fn.importValue(\u0026#39;EveryoneCook-dev-HostedZoneId\u0026#39;) zoneName: \u0026#39;everyonecook.cloud\u0026#39; From Certificate Stack:\ncertificateArn: \u0026#39;arn:aws:acm:us-east-1:616580903213:certificate/8d53776e-...\u0026#39; Exports Used By Other Stacks Auth Stack imports:\nDynamoDB table (for user profiles) DynamoDB key (for Lambda permissions) Backend Stack imports:\nDynamoDB table (for all data operations) S3 content bucket (for file uploads) CloudFront distribution (for WAF association) KMS keys (for encryption) Dependency Flow DNS Stack ‚Üí Hosted Zone ID\r‚îÇ\r‚ñº\rCertificate Stack (us-east-1) ‚Üí Certificate ARN\r‚îÇ\r‚ñº\rCore Stack (ap-southeast-1)\r‚îÇ\r‚îú‚îÄ‚ñ∫ DynamoDB Table ‚Üí Auth Stack, Backend Stack\r‚îú‚îÄ‚ñ∫ S3 Buckets ‚Üí Backend Stack\r‚îú‚îÄ‚ñ∫ CloudFront ‚Üí Backend Stack (WAF)\r‚îî‚îÄ‚ñ∫ KMS Keys ‚Üí Auth Stack, Backend Stack Validation Checklist Before proceeding to Auth Stack deployment:\nCore Stack successfully deployed to ap-southeast-1 DynamoDB table exists with 5 GSI indexes S3 content bucket has Intelligent-Tiering configured S3 CORS configured for frontend domain CloudFront distribution status is Deployed CloudFront custom domain resolves: cdn-dev.everyonecook.cloud CloudFront OAC configured for S3 access KMS keys created with rotation enabled Route 53 A record created for CloudFront All stack outputs exported successfully Testing Test CloudFront Distribution Test custom domain:\ncurl -I https://cdn-dev.everyonecook.cloud Expected response:\nHTTP/2 403\rserver: CloudFront\rx-cache: Error from cloudfront (403 is expected - bucket is empty)\nTest compression:\ncurl -H \u0026#34;Accept-Encoding: gzip, br\u0026#34; -I https://cdn-dev.everyonecook.cloud Test HTTPS redirect:\ncurl -I http://cdn-dev.everyonecook.cloud Expected: Redirect to HTTPS\nTest DynamoDB Table # List tables aws dynamodb list-tables --region ap-southeast-1 # Describe table aws dynamodb describe-table --table-name EveryoneCook-dev-v2 --region ap-southeast-1 Test S3 Bucket Access # Try direct S3 access (should be blocked) curl -I https://everyonecook-content-dev.s3.ap-southeast-1.amazonaws.com # Expected: 403 Forbidden (OAC protection working) Next Steps After successfully deploying the Core Stack:\n‚û°Ô∏è 5.4.4 Auth Stack - Create Cognito User Pool and authentication\nThe Auth Stack will:\nCreate Cognito User Pool with advanced security Configure user attributes and password policy Setup Cognito triggers (Lambda functions) Create SES email identity for verification emails Import DynamoDB table from Core Stack References Source Code: infrastructure/lib/stacks/core-stack.ts Base Stack: infrastructure/lib/base-stack.ts Environment Config: infrastructure/config/environment.ts AWS Documentation: DynamoDB Single Table Design S3 Intelligent-Tiering CloudFront Origin Access Control KMS Key Rotation "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.04-configure-stacks/",
	"title": "Configure Infrastructure Stacks",
	"tags": [],
	"description": "",
	"content": "Configure Infrastructure Stacks EveryoneCook Project Overview Introduction EveryoneCook is a social network platform for sharing cooking recipes, built entirely on AWS Cloud. The project uses a serverless architecture, leveraging AWS managed services to ensure scalability, security, and cost optimization.\nSystem Architecture The project is designed with a 5-Stack Architecture featuring clear layers:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ EveryoneCook Platform ‚îÇ\r‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r‚îÇ Layer 1: DNS \u0026amp; Certificate (Foundation) ‚îÇ\r‚îÇ ‚îú‚îÄ DNS Stack: Route 53 Hosted Zone ‚îÇ\r‚îÇ ‚îî‚îÄ Certificate Stack: ACM Certificates (us-east-1) ‚îÇ\r‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r‚îÇ Layer 2: Data \u0026amp; Storage (Core Infrastructure) ‚îÇ\r‚îÇ ‚îî‚îÄ Core Stack: DynamoDB, S3, CloudFront, KMS ‚îÇ\r‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r‚îÇ Layer 3: Authentication \u0026amp; Security ‚îÇ\r‚îÇ ‚îî‚îÄ Auth Stack: Cognito, Lambda Triggers, SES ‚îÇ\r‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r‚îÇ Layer 4: Application \u0026amp; Business Logic ‚îÇ\r‚îÇ ‚îî‚îÄ Backend Stack: API Gateway, Lambda, SQS, WAF ‚îÇ\r‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r‚îÇ Layer 5: Monitoring \u0026amp; Observability ‚îÇ\r‚îÇ ‚îî‚îÄ Observability Stack: CloudWatch, Alarms, Dashboards ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Technologies Used Infrastructure as Code AWS CDK (TypeScript): Infrastructure management with code CloudFormation: Underlying template engine for CDK Git: Version control for infrastructure code Backend Services API Gateway REST API: RESTful API endpoint with custom domain Lambda Functions: Serverless compute for business logic (6 main functions + 1 worker) Lambda Layers: Shared dependencies layer (reduces deployment size by 90%) DynamoDB: NoSQL database with Single Table Design + 5 GSI indexes S3: Object storage for user content (avatars, posts, recipes, backgrounds) SQS: Message queue for async processing (4 queues + 4 DLQs) Security \u0026amp; Authentication Cognito User Pool: User authentication \u0026amp; management Cognito User Pool Client: Frontend authentication config WAF (Web Application Firewall): API Gateway protection with rate limiting KMS (Key Management Service): 2 customer-managed keys (DynamoDB, S3) IAM Roles \u0026amp; Policies: Fine-grained access control for all services Content Delivery \u0026amp; Networking CloudFront: CDN with Origin Access Control (OAC) + Shield Standard Route 53: DNS management with Hosted Zone ACM (Certificate Manager): SSL/TLS certificates (2 certificates) Monitoring \u0026amp; Operations CloudWatch Logs: Centralized logging for Lambda functions CloudWatch Metrics: Performance metrics tracking CloudWatch Dashboards: 4 dashboards (Core, Auth, Backend, Overview) CloudWatch Alarms: Real-time monitoring (10+ alarms) + Composite Alarm SNS (Simple Notification Service): Email notifications for alarms Project Directory Structure everyonecook/\r‚îú‚îÄ‚îÄ infrastructure/ # AWS CDK Infrastructure\r‚îÇ ‚îú‚îÄ‚îÄ bin/\r‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ app.ts # CDK app entry point - creates all stacks\r‚îÇ ‚îú‚îÄ‚îÄ lib/\r‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ base-stack.ts # Base class for all stacks\r‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ stacks/ # Stack definitions\r‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dns-stack.ts # Route 53 Hosted Zone\r‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ certificate-stack.ts # ACM Certificates\r‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ core-stack.ts # DynamoDB, S3, CloudFront\r‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ auth-stack.ts # Cognito, Lambda triggers\r‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ backend-stack.ts # API Gateway, Lambda, SQS\r‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ observability-stack.ts # CloudWatch, Alarms\r‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ constructs/ # Reusable CDK constructs\r‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ shared-layer.ts # Lambda Layer with dependencies\r‚îÇ ‚îú‚îÄ‚îÄ config/\r‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ environment.ts # Environment configuration (dev/staging/prod)\r‚îÇ ‚îú‚îÄ‚îÄ cdk.json # CDK configuration\r‚îÇ ‚îú‚îÄ‚îÄ package.json # Node.js dependencies\r‚îÇ ‚îî‚îÄ‚îÄ tsconfig.json # TypeScript configuration\r‚îú‚îÄ‚îÄ services/ # Lambda function source code\r‚îÇ ‚îú‚îÄ‚îÄ api-router/ # API request routing\r‚îÇ ‚îú‚îÄ‚îÄ auth-user/ # Authentication endpoints\r‚îÇ ‚îú‚îÄ‚îÄ social/ # Social features (posts, comments)\r‚îÇ ‚îú‚îÄ‚îÄ recipe-ai/ # Recipe \u0026amp; AI endpoints\r‚îÇ ‚îú‚îÄ‚îÄ admin/ # Admin management\r‚îÇ ‚îî‚îÄ‚îÄ upload/ # File upload handler\r‚îú‚îÄ‚îÄ shared/ # Shared code \u0026amp; utilities\r‚îÇ ‚îú‚îÄ‚îÄ utils/ # Common utilities\r‚îÇ ‚îú‚îÄ‚îÄ models/ # Data models\r‚îÇ ‚îî‚îÄ‚îÄ middleware/ # Lambda middleware\r‚îú‚îÄ‚îÄ frontend/ # Next.js frontend (deployed separately)\r‚îÇ ‚îî‚îÄ‚îÄ ...\r‚îî‚îÄ‚îÄ layers/ # Lambda layers\r‚îî‚îÄ‚îÄ shared-dependencies/ # Common npm packages Stack Architecture Overview 1. DNS Stack (Phase 1) Purpose: Create the foundation for DNS management\nMain resources:\nRoute 53 Hosted Zone for domain everyonecook.cloud Export nameservers to configure at the domain registrar Deployment order: This stack must be deployed first\nEstimated cost: ~$0.50/month\nNote: After deploying this stack, update the nameservers at Hostinger to point to Route 53.\n2. Certificate Stack (Phase 1.5) Purpose: Create SSL/TLS certificates for CloudFront and API Gateway\nMain resources:\nACM Certificate for CloudFront: cdn.everyonecook.cloud ACM Wildcard Certificate for API Gateway: *.everyonecook.cloud DNS validation records in Route 53 Special region: MUST deploy to us-east-1 (CloudFront requirement)\nDependencies: DNS Stack (requires Hosted Zone for DNS validation)\nEstimated cost: Free (ACM certificates are free)\nImportant note: CloudFront only accepts certificates from the us-east-1 region.\n3. Core Stack (Phase 2) Purpose: Create the data layer and storage infrastructure\nMain resources:\nDynamoDB Table: Single Table Design with 5 GSI indexes PK: USER#{username}, SK: PROFILE|RECIPE#{id}|POST#{id}|COMMENT#{id} Username-based primary key (immutable) GSI1-GSI5 for different query patterns: GSI1: User recipes by date GSI2: User posts by date GSI3: Post comments GSI4: Recipe search by cuisine/difficulty GSI5: Social interactions (likes, follows) Billing mode: Pay-per-request (on-demand) Encryption: Customer-managed KMS key with auto-rotation S3 Buckets (2 buckets): Content Bucket: User uploads (avatars, posts, recipes, backgrounds) Intelligent-Tiering enabled (automatically optimizes cost) Versioning enabled Lifecycle rules: Delete incomplete multipart uploads after 7 days Encryption: Customer-managed KMS key CDN Logs Bucket: CloudFront access logs Intelligent-Tiering enabled Auto-delete logs after 90 days (cost optimization) CloudFront Distribution: Origin: S3 Content Bucket Origin Access Control (OAC) to secure S3 access (replaces OAI) Custom domain: cdn.everyonecook.cloud SSL Certificate: ACM certificate from Certificate Stack Cache behaviors: Optimized for images \u0026amp; static content Compression: Gzip \u0026amp; Brotli enabled Shield Standard: DDoS protection (free, auto-enabled) NOTE: CloudFront WAF removed to save $9/month KMS Keys (2 customer-managed keys): DynamoDB Encryption Key: Auto-rotation enabled (yearly) Used by: DynamoDB table, CloudWatch Logs S3 Encryption Key: Auto-rotation enabled (yearly) Used by: S3 buckets, CloudFront signed URLs IAM Roles: CloudFront Origin Access Control role Lambda execution roles with DynamoDB \u0026amp; S3 access Dependencies: Certificate Stack (requires certificate for CloudFront)\nEstimated cost: ~$8-15/month\nCost optimization:\nS3 Intelligent-Tiering automatically moves objects to cheaper storage CloudFront WAF removed (Shield Standard provides DDoS protection) CloudWatch Logs auto-delete after retention period 4. Auth Stack (Phase 3) Purpose: Authentication and user management\nMain resources:\nCognito User Pool: Sign-in methods: Username OR Email + Password NO MFA requirement (only email + password) Password policy: Min 12 chars for prod (8 chars for dev) Require uppercase, lowercase, digits, symbols Standard attributes: email, given_name (fullName), birthdate, gender Custom attributes: account_status (for admin ban), country (ISO 3166-1) Device tracking: Enabled (NO challenge required) Email verification: Required before use Account recovery: Email-based NOTE: Advanced Security Mode OFF to save ~$5/month Lambda Triggers (5 functions with CloudWatch Logs): Pre-signup: Validate username uniqueness Check profanity/banned words Runtime: Node.js 20.x Post-confirmation: Create user profile in DynamoDB Initialize user stats Pre-authentication: Check account status (active/banned) Log login attempts Post-authentication: Update last login timestamp Track user activity Custom message: Customize verification emails Branded email templates Cognito User Pool Client: OAuth flows: Authorization code grant Token validity: Access token: 1 hour Refresh token: 30 days Read/Write attributes configured CloudWatch Log Groups: Each Lambda trigger has a dedicated log group Retention: 7 days Encryption: KMS DynamoDB key IAM Roles: Lambda execution roles Permissions: DynamoDB read/write, Cognito admin, Logs write Dependencies: Core Stack (Lambda triggers need access to DynamoDB)\nEstimated cost: ~$0-2/month (Cognito free tier: 50,000 MAU)\nSecurity:\nAdvanced Security Mode not enabled to optimize cost (would cost an extra ~$5/month) Device tracking enabled but NO MFA to improve user experience All Lambda triggers have CloudWatch logging 5. Backend Stack (Phase 4) Purpose: Application layer and business logic\nMain resources:\nAPI Gateway REST API: Custom domain: api.everyonecook.cloud SSL Certificate: Wildcard ACM certificate (*.everyonecook.cloud) Cognito Authorizer: Validate JWT tokens Request validators: Body validator: Validate request body Params validator: Validate query params \u0026amp; path params Full validator: Validate both body \u0026amp; params Deployment stage: dev/staging/prod CloudWatch Logs: Access logs + execution logs WAF Web ACL attached (API protection) Lambda Functions (6 main modules + CloudWatch Logs): API Router: Route requests to appropriate handlers Memory: 256 MB, Timeout: 30s Auth User: Login, register, forgot-password, verify-email Cognito integration Memory: 512 MB, Timeout: 30s Social: Create/edit/delete posts, comments, likes Follow/unfollow users Memory: 512 MB, Timeout: 30s Recipe AI: CRUD operations for recipes AI recipe generation (Bedrock integration) Recipe search \u0026amp; recommendations Memory: 1024 MB, Timeout: 60s Admin: User management, ban/unban Content moderation Analytics dashboard Memory: 512 MB, Timeout: 30s Upload: File upload to S3 Generate pre-signed URLs Image validation Memory: 512 MB, Timeout: 30s Runtime: Node.js 20.x Environment variables: DynamoDB table, S3 bucket, SQS queues Lambda Layer - Shared Dependencies: AWS SDK v3 clients: DynamoDB, S3, SQS, Cognito, Bedrock, Lambda Utilities: uuid, jsonwebtoken, jwks-rsa Benefit: Reduces deployment size from 8MB ‚Üí 200KB per function (90% reduction) Compatible runtimes: Node.js 18.x, 20.x SQS Queues (4 main queues + 4 DLQs): AI Queue: AI recipe generation requests Visibility timeout: 120s (2 minutes) Message retention: 4 days Max receive count: 3 (then move to DLQ) Image Processing Queue: Image optimization, thumbnails Visibility timeout: 60s Message retention: 4 days Analytics Queue: User activity tracking Visibility timeout: 30s Message retention: 4 days Notification Queue: Push notifications, emails Visibility timeout: 30s Message retention: 4 days Encryption: AWS managed KMS keys Worker Lambda (1 active): AI Worker: Process AI Queue messages Call Amazon Bedrock for recipe generation Store results in DynamoDB Memory: 1024 MB, Timeout: 120s Event source: AI Queue (batch size: 10) Note: Other workers not yet implemented WAF Web ACL (API Gateway only): Rate limiting: 2000 requests / 5 minutes per IP AWS Managed Rules: AWSManagedRulesCommonRuleSet (OWASP Top 10) AWSManagedRulesKnownBadInputsRuleSet Custom rules: Block specific patterns NOTE: CloudFront WAF removed to save $9/month Shield Standard: Auto-enabled (DDoS protection - free) CloudWatch Log Groups: API Gateway access logs + execution logs Lambda function logs (per function) Retention: 7 days (cost optimization) Encryption: KMS DynamoDB key IAM Roles \u0026amp; Policies: API Gateway execution role Lambda execution roles (per function) Permissions: DynamoDB, S3, SQS, Cognito, Bedrock, Logs, KMS Shared Lambda Layer:\nAWS SDK v3 clients (DynamoDB, S3, SQS, Cognito, Bedrock) Common utilities (uuid, jsonwebtoken, jwks-rsa) Reduces deployment size: 8MB ‚Üí 200KB per function Dependencies: Auth Stack (requires Cognito User Pool)\nEstimated cost: ~$10-25/month\nCost optimization:\nCloudFront WAF removed (Shield Standard provides DDoS protection) WAF only enabled for API Gateway (main attack surface) Lambda Layer reduces deployment size by 90% CloudWatch Logs auto-delete after 7 days 6. Observability Stack (Phase 7) Purpose: Monitoring, logging, and alerting\nMain resources:\nCloudWatch Dashboards (4 dashboards): Core Dashboard: DynamoDB metrics: Read/write capacity, throttling, latency S3 metrics: Request count, 4xx/5xx errors, bytes downloaded CloudFront metrics: Request count, cache hit rate, error rate KMS metrics: Key usage, encryption/decryption operations Auth Dashboard: Cognito metrics: Sign-ups, sign-ins, failed authentications Lambda trigger metrics: Invocations, errors, duration User pool analytics Backend Dashboard: API Gateway metrics: Request count, 4xx/5xx errors, latency Lambda metrics: Invocations, errors, duration, throttles, concurrent executions SQS metrics: Messages sent, received, deleted, DLQ depth WAF metrics: Blocked requests, allowed requests, rule matches Overview Dashboard: System health summary Cost tracking Composite alarm status Key metrics from all stacks CloudWatch Alarms (15+ alarms): Critical Alarms (notify immediately): API Gateway 5xx errors \u0026gt; 5% (system errors) Lambda error rate \u0026gt; 10% DynamoDB read/write throttling SQS DLQ has messages (failed processing) S3 5xx errors Cost \u0026gt; $50/month (budget exceeded) Warning Alarms (notify but not urgent): API Gateway 4xx errors \u0026gt; 10% (client errors) Lambda duration \u0026gt; 25s (approaching timeout) Lambda throttling (concurrent limit reached) DynamoDB latency high (\u0026gt; 100ms) S3 4xx errors SQS queue age \u0026gt; 15 minutes (processing lag) Cost \u0026gt; $35/month (budget warning) All alarms: Evaluation periods: 1-2 periods Datapoints to alarm: Configurable Treatment of missing data: NOT_BREACHING Composite Alarm: Name: \u0026ldquo;SystemHealth\u0026rdquo; Combines all critical alarms Alarm rule: OR logic (any critical alarm triggers) Actions: Send SNS notification Purpose: Single alarm for overall system health SNS Topic: Topic name: EveryoneCook-{env}-Alarms Email subscription: Admin email from config Delivery status logging enabled Encryption: AWS managed key CloudWatch Logs: Retention: 7 days (cost optimization) Encryption: KMS DynamoDB key Log groups: API Gateway, Lambda functions (all have logs) Cost Tracking: CloudWatch metric: EstimatedCharges Alarms: Warning ($35) + Critical ($50) Daily cost monitoring Dependencies: All other stacks (monitors the entire infrastructure)\nEstimated cost: ~$3-8/month\nBest practice:\nDeploy this stack last for complete visibility Composite alarm helps reduce alarm fatigue 7-day log retention balances debugging needs and cost Cost alarms prevent unexpected bills Stack Dependencies Flow DNS Stack (Route 53)\r‚Üì\rCertificate Stack (ACM in us-east-1)\r‚Üì\rCore Stack (DynamoDB, S3, CloudFront, KMS)\r‚Üì\rAuth Stack (Cognito, Lambda Triggers)\r‚Üì\rBackend Stack (API Gateway, Lambda, SQS, WAF)\r‚Üì\rObservability Stack (CloudWatch, Alarms) Dependency explanation:\nCertificate Stack needs DNS Stack to validate certificates via Route 53 DNS Core Stack needs Certificate Stack to attach certificate to CloudFront Auth Stack needs Core Stack so Lambda triggers can access DynamoDB Backend Stack needs Auth Stack to integrate Cognito Authorizer into API Gateway Observability Stack needs all stacks to monitor all resources Total Estimated Cost Development Environment:\nService Cost/month Notes Route 53 Hosted Zone $0.50 1 hosted zone + DNS queries ACM Certificates $0 Free for public certificates DynamoDB (Pay-per-request) $3-5 Depends on usage, free tier available S3 (Intelligent-Tiering) $1-3 2 buckets, auto-tiering saves cost CloudFront $2-5 CDN distribution + data transfer Lambda $0-3 7 functions + 1 worker, free tier 1M requests Lambda Layer $0 No additional charge API Gateway $0-3 REST API, free tier 1M requests Cognito (Free tier) $0 Up to 50,000 MAU SQS $0-1 4 queues + 4 DLQs, free tier 1M requests WAF (API Gateway only) $5-8 Web ACL + rules + requests processed CloudWatch Logs $1-2 7-day retention, all services CloudWatch Dashboards $0-1 4 dashboards, first 3 free CloudWatch Alarms $0.50-1 15+ alarms, $0.10/alarm SNS $0 Email notifications, low volume KMS $2 2 customer-managed keys @ $1 each IAM $0 Roles \u0026amp; policies are free TOTAL $15-35/month Development with low traffic Note:\nThis is an estimate for the development environment with low traffic Production environment with high traffic will have significantly higher costs Free tier: Cognito (50K MAU), Lambda (1M requests), API Gateway (1M requests), SQS (1M requests) Cost optimizations applied: CloudFront WAF removed (-$9/month) S3 Intelligent-Tiering (auto cost reduction) CloudWatch Logs 7-day retention Lambda Layer reduces deployment costs authStack.addDependency(coreStack); backendStack.addDependency(authStack); observabilityStack.addDependency(backendStack);\nConfiguration Guide Step 1: Prepare Infrastructure Directory 1. Navigate to infrastructure directory\ncd D:\\Project_AWS\\everyonecook\\infrastructure 2. Install dependencies\nnpm install TODO: Take a screenshot of the terminal with the output of npm install\nStep 2: Configure Environment Settings 1. Review environment configuration\nOpen the file config/environment.ts to review the configuration:\ncode config\\environment.ts This file contains configuration for environments (dev, staging, prod):\n// Example Dev environment configuration dev: { environment: \u0026#39;dev\u0026#39;, account: \u0026#39;123456789012\u0026#39;, // Update with your AWS Account ID region: \u0026#39;ap-southeast-1\u0026#39;, // Singapore region domains: { frontend: \u0026#39;dev.everyonecook.cloud\u0026#39;, api: \u0026#39;api-dev.everyonecook.cloud\u0026#39;, cdn: \u0026#39;cdn-dev.everyonecook.cloud\u0026#39;, }, cognito: { passwordPolicy: { minLength: 8, // Dev: 8 chars, Prod: 12 chars } } } 2. Verify AWS Account ID\n# Check current AWS Account ID aws sts get-caller-identity Output will show:\n{ \u0026#34;UserId\u0026#34;: \u0026#34;AIDAXXXXXXXXXXXXXXXXX\u0026#34;, \u0026#34;Account\u0026#34;: \u0026#34;123456789012\u0026#34;, \u0026#34;Arn\u0026#34;: \u0026#34;arn:aws:iam::123456789012:user/your-username\u0026#34; } 3. Update account ID in config (if needed)\nIf the account ID does not match, update it in config/environment.ts:\ndev: { account: \u0026#39;YOUR_ACTUAL_ACCOUNT_ID\u0026#39;, // Update here // ... other configs } Step 3: Review CDK App Structure 1. Review main CDK app file\ncode bin\\app.ts The file bin/app.ts is the entry point of the CDK application. Main content:\n#!/usr/bin/env node import * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import { getConfig } from \u0026#39;../config/environment\u0026#39;; const app = new cdk.App(); // Get environment from context (default: \u0026#39;dev\u0026#39;) const environment = app.node.tryGetContext(\u0026#39;environment\u0026#39;) || \u0026#39;dev\u0026#39;; const config = getConfig(environment); console.log(`üöÄ Deploying Everyone Cook infrastructure for environment: ${environment}`); // Create stacks in dependency order const dnsStack = new DnsStack(app, `EveryoneCook-${environment}-DNS`, {...}); const certificateStack = new CertificateStack(app, `EveryoneCook-${environment}-Certificate`, {...}); const coreStack = new CoreStack(app, `EveryoneCook-${environment}-Core`, {...}); const authStack = new AuthStack(app, `EveryoneCook-${environment}-Auth`, {...}); const backendStack = new BackendStack(app, `EveryoneCook-${environment}-Backend`, {...}); const observabilityStack = new ObservabilityStack(app, `EveryoneCook-${environment}-Observability`, {...}); // Add dependencies certificateStack.addDependency(dnsStack); coreStack.addDependency(certificateStack); authStack.addDependency(coreStack); backendStack.addDependency(authStack); observabilityStack.addDependency(backendStack); // Add tags to all stacks cdk.Tags.of(app).add(\u0026#39;Project\u0026#39;, \u0026#39;EveryoneCook\u0026#39;); cdk.Tags.of(app).add(\u0026#39;Environment\u0026#39;, config.environment); cdk.Tags.of(app).add(\u0026#39;ManagedBy\u0026#39;, \u0026#39;CDK\u0026#39;); 2. Understand stack dependencies\nStacks are created in order and have explicit dependencies:\nCertificate Stack depends on DNS Stack Core Stack depends on Certificate Stack Auth Stack depends on Core Stack Backend Stack depends on Auth Stack Observability Stack depends on all other stacks Step 4: Validate Configuration 1. Compile TypeScript\n# Navigate to infrastructure directory cd D:\\Project_AWS\\everyonecook\\infrastructure # Compile TypeScript npm run build Successful output:\n\u0026gt; everyonecook-infrastructure@1.0.0 build\r\u0026gt; tsc\r# No errors - compilation successful 2. List all CDK stacks\n# List all stacks for dev environment npx cdk list --context environment=dev Output:\nEveryoneCook-dev-DNS\rEveryoneCook-dev-Certificate\rEveryoneCook-dev-Core\rEveryoneCook-dev-Auth\rEveryoneCook-dev-Backend\rEveryoneCook-dev-Observability 3. Synthesize CloudFormation templates\n# Generate CloudFormation templates npx cdk synth --context environment=dev Output:\nSuccessfully synthesized to D:\\Project_AWS\\everyonecook\\infrastructure\\cdk.out\rSupply a stack id (EveryoneCook-dev-DNS, EveryoneCook-dev-Certificate, ...) to display its template. The cdk.out/ folder is created with CloudFormation templates:\ncdk.out/\r‚îú‚îÄ‚îÄ EveryoneCook-dev-DNS.template.json\r‚îú‚îÄ‚îÄ EveryoneCook-dev-Certificate.template.json\r‚îú‚îÄ‚îÄ EveryoneCook-dev-Core.template.json\r‚îú‚îÄ‚îÄ EveryoneCook-dev-Auth.template.json\r‚îú‚îÄ‚îÄ EveryoneCook-dev-Backend.template.json\r‚îî‚îÄ‚îÄ EveryoneCook-dev-Observability.template.json Step 5: Review Stack Resources (Optional) If you want to see details of resources in each stack:\n1. DNS Stack Resources\n# View DNS stack template Get-Content cdk.out\\EveryoneCook-dev-DNS.template.json | ConvertFrom-Json | Select-Object -ExpandProperty Resources Resources:\nHostedZone: Route 53 Hosted Zone Outputs: Nameservers, Hosted Zone ID 2. Certificate Stack Resources\n# View Certificate stack template Get-Content cdk.out\\EveryoneCook-dev-Certificate.template.json | ConvertFrom-Json | Select-Object -ExpandProperty Resources Resources:\nCloudFrontCertificate: ACM Certificate for CloudFront (cdn.everyonecook.cloud) ApiGatewayCertificate: Wildcard ACM Certificate (*.everyonecook.cloud) ValidationRecords: Route 53 DNS validation records 3. Core Stack Resources\nResources (30+ resources):\nDynamoDB Table with 5 GSI indexes S3 Buckets (2 buckets: content, cdn-logs) CloudFront Distribution with OAC KMS Keys (2 keys: DynamoDB, S3) IAM Roles and Policies 4. Auth Stack Resources\nResources (20+ resources):\nCognito User Pool with password policy Cognito User Pool Client Lambda Functions (5 triggers) IAM Roles for Lambda functions 5. Backend Stack Resources\nResources (50+ resources):\nAPI Gateway REST API with custom domain Lambda Functions (6 modules + 1 worker) SQS Queues (4 queues + 4 DLQs) WAF Web ACL for API Gateway Lambda Layer (shared dependencies) IAM Roles and Policies 6. Observability Stack Resources\nResources (15+ resources):\nCloudWatch Dashboards (4 dashboards) CloudWatch Alarms (10+ alarms) Composite Alarm for overall health SNS Topic for notifications Step 6: Detailed Configuration for Each Stack To learn more about the configuration and resources of each stack, see the following sections:\n5.4.1 DNS Stack: Route 53 Hosted Zone configuration 5.4.2 Certificate Stack: ACM Certificates configuration 5.4.3 Core Stack: DynamoDB, S3, CloudFront configuration 5.4.4 Auth Stack: Cognito, Lambda Triggers configuration 5.4.5 Backend Stack: API Gateway, Lambda, SQS configuration 5.4.7 Observability Stack: CloudWatch, Alarms configuration Configuration Checklist Before deploying, check the following items:\nEnvironment Configuration\nAWS Account ID has been verified and updated in config/environment.ts Region is set correctly (ap-southeast-1 for dev) Domain names configured correctly Dependencies\nNode.js and npm have been installed AWS CLI has been configured with credentials AWS CDK CLI has been installed globally npm dependencies have been installed (npm install) Validation\nTypeScript compilation successful (npm run build) CDK list shows all 6 stacks CDK synth generates CloudFormation templates successfully No syntax errors in stack code Preparation for Deployment\nCDK bootstrap has been run (see 5.03 CDK Bootstrap) AWS account has sufficient permissions to create resources Domain has been registered (or ready to register) Next Steps After completing configuration and validation, continue to:\n5.05 Deploy Infrastructure - Deploy all stacks to AWS\nIn the next step, you will:\nDeploy DNS Stack and configure nameservers Deploy Certificate Stack and validate certificates Deploy Core Stack (DynamoDB, S3, CloudFront) Deploy Auth Stack (Cognito, Lambda Triggers) Deploy Backend Stack (API Gateway, Lambda Functions) Deploy Observability Stack (CloudWatch Dashboards) "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/1.4-week4/",
	"title": "Week 4 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 4 Objectives: Deploy a production-grade WordPress architecture ensuring High Availability (HA) and Scalability using Auto Scaling Groups and CloudFront. Master Server Migration workflows by importing/exporting Virtual Machines (VMs) between on-premises environments and AWS. Perform comprehensive Database Migration for heterogeneous sources using AWS Schema Conversion Tool (SCT) and Database Migration Service (DMS). Research advanced cloud migration strategies and tools (DataSync, MGN, Outposts). Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 WordPress on AWS - Part 1 (Deployment) - Prepare Infrastructure: VPC, Subnets, Security Groups for Web \u0026amp; DB - Launch Multi-AZ RDS for high database availability - Deploy EC2 and install WordPress application - Connect WordPress to RDS instance 29/09/2025 29/09/2025 https://000021.awsstudygroup.com/ 3 WordPress on AWS - Part 2 (Scaling \u0026amp; CDN) - Create AMI from the configured WordPress instance - Setup Auto Scaling Group (ASG) with Application Load Balancer - Accelerate content delivery using Amazon CloudFront - Perform Database Backup (Snapshot) \u0026amp; Restore operations - Cleanup resources 30/09/2025 30/09/2025 https://000021.awsstudygroup.com/ 4 Server Migration (VM Import/Export) - Deploy local Application Server (Simulated On-Prem) - Import VM to AWS: Export local VM, upload to S3, and convert to AMI/EC2 - Export VM from AWS: Export EC2 instance back to S3 for on-prem use - Manage S3 ACLs and CLI roles for migration tasks 01/10/2025 01/10/2025 https://000014.awsstudygroup.com/ 5 Database Migration (DMS \u0026amp; SCT) - Set up Migration Environment: Source (Oracle/SQL Server) \u0026amp; Target (Aurora/RDS) - Use Schema Conversion Tool (SCT) to convert database schemas - Configure AWS DMS: + Create Replication Instance \u0026amp; Endpoints + Run Migration Task (Full Load + CDC) - Explore DMS Serverless for auto-scaling replication 02/10/2025 02/10/2025 https://000043.awsstudygroup.com/ 6 Advanced Migration Monitoring \u0026amp; Strategies - Monitoring DMS: Analyze CloudWatch metrics, Table statistics, and Task logs - Troubleshooting: Diagnose memory pressure and table errors during migration - Research: Explore upcoming migration patterns: + AWS Application Migration Service (MGN) + AWS DataSync \u0026amp; Migration Hub + Container Migration to EKS 03/10/2025 03/10/2025 https://000043.awsstudygroup.com/ Self-Study on AWS Migration Hub Week 4 Achievements Scalable Web Architecture Successfully deployed a highly available WordPress site using Multi-AZ RDS and Auto Scaling Groups. Configured Application Load Balancer (ALB) to distribute traffic dynamically across healthy instances. Optimized global content delivery speeds by integrating Amazon CloudFront as a CDN. Implemented disaster recovery procedures using RDS Snapshots and restoration techniques. Server Migration Expertise Gained hands-on experience with VM Import/Export methodologies. Successfully migrated a virtual machine from a simulated on-premises environment (VMware) to AWS EC2. Mastered the reverse process of exporting an active AWS EC2 instance back to a portable VM image stored in S3. Configured necessary IAM roles and S3 permissions to facilitate secure image transfer. Database Migration \u0026amp; Modernization Executed a heterogeneous database migration (e.g., SQL Server/Oracle to Aurora) using AWS DMS. Utilized the AWS Schema Conversion Tool (SCT) to automate schema transformation between different database engines. Configured Continuous Data Replication (CDC) to keep source and target databases in sync with minimal downtime. Experimented with DMS Serverless to handle variable migration workloads automatically. Learned to monitor migration health using CloudWatch and troubleshoot common issues like memory pressure or data type mismatches. "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/3-blogstranslated/3.4-blog4/",
	"title": "Blog 4: Essential Guide to Cloud Governance at AWS re:Invent 2025",
	"tags": [],
	"description": "",
	"content": "Overview: Governance as a Launchpad for Innovation At AWS re:Invent 2025, the theme of Cloud Governance is no longer viewed as a compliance burden but has become a strategic factor to drive innovation. This year\u0026rsquo;s Cloud Governance track focuses on bridging the gap between operational excellence and business innovation.\nThis post summarizes guidance for attending the most important sessions, divided into 4 main themes reflecting today\u0026rsquo;s most pressing challenges.\nKey Themes This year\u0026rsquo;s program is organized around 4 main pillars:\nGenerative AI \u0026amp; Intelligent Governance: Using AI to analyze logs, automate controls, and shift from reactive to proactive governance. Operational Efficiency \u0026amp; Cost Optimization: Balancing strict controls with operational efficiency, optimizing monitoring costs. Secure Operations \u0026amp; Automation: Shifting from \u0026ldquo;checkbox\u0026rdquo; compliance to automated, continuous protection through Policy-as-Code. Multicloud \u0026amp; Sovereign Cloud: Consistent governance across multiple cloud environments and meeting data sovereignty requirements. Featured Sessions Details Below is a list of \u0026ldquo;must-attend\u0026rdquo; sessions categorized by theme to help you easily plan your learning schedule.\n1. Generative AI \u0026amp; Intelligent Governance Revolutionizing governance processes with AI to reduce manual operations.\nCOP350 | Building and validating cloud controls with generative AI: (Breakout) Technical guidance on using GenAI to customize AWS Control Tower, write rules for AWS Config, and analyze CloudTrail logs. COP411 | Intelligent automation for managing cloud governance: (Builders session) Hands-on building intelligent workflows that analyze data from Config and Security Hub to provide context-based insights. 2. Operational Efficiency \u0026amp; Cost Optimization Building a governance framework that helps enterprises stay agile while saving costs.\nCOP355 | A practical guide to implement cost-effective governance controls: (Chalk talk) Strategies to reduce monitoring costs while maintaining security, using Config and CloudTrail. COP351 | Innovation Sandbox on AWS: (Lightning Talk) Automating the creation and destruction of temporary sandbox environments to control costs and security. COP324 | Moving AWS Accounts seamlessly at scale: (Chalk talk) Guidance on safely migrating AWS accounts in merger and acquisition (M\u0026amp;A) scenarios. 3. Secure Operations \u0026amp; Automation Applying Policy-as-Code and continuous compliance checking.\nCOP347 | Actionable controls for improving governance and compliance: (Breakout) Transforming compliance frameworks into practical AWS controls using Control Tower and Audit Manager. COP352 | From Reactive to Proactive: Infrastructure governance by design: (Code talk) Using CloudFormation Guard and Hooks to block non-compliant deployments from the start. COP406 | Build and automate policy as code: (Builders session) Hands-on building Policy-as-Code pipelines with automated security testing steps (shift-left security). 4. Multicloud \u0026amp; Sovereign Cloud Addressing complex requirements for data sovereignty and multi-cloud.\nCOP409 | Building Sovereign Cloud Environments: (Code talk) How Control Tower supports data sovereignty requirements and controls cross-border data movement. COP349 | Balancing agility and compliance feat. The Japan Digital Agency: (Breakout) Case study on Japan\u0026rsquo;s government managing centralized governance for 30 ministries and 5,000 AWS accounts. COP346 | Governance that Enables Innovation at Scale feat. Eli Lilly: (Breakout) Case study on pharmaceutical company Eli Lilly modernizing governance with Control Tower without causing operational disruption (zero downtime). Conclusion This year\u0026rsquo;s sessions emphasize fundamental shifts in cloud operations:\nIntegrating Generative AI into governance processes. Emphasis on Policy-as-Code. Shifting from reactive controls to proactive approaches. Attending these sessions will equip you with knowledge to lead your organization\u0026rsquo;s digital transformation safely and efficiently.\nAuthor David Sokolik\rDavid Sokolik is an Enterprise Support Technical Account Manager at Amazon Web Services based out of Tel Aviv, Israel. With over a decade of IT and cloud experience, David is a dedicated team member and advocate for his customers for building scalable, resilient and cost-effective solutions. David enjoys spending time with his family and friends traveling the world and exploring local cuisines.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/4-eventparticipated/",
	"title": "Events Participated",
	"tags": [],
	"description": "",
	"content": "During my internship, I had the chance to participate in three events, each bringing valuable insights, engaging experiences, and memorable moments. These activities not only enriched my learning journey but also came with thoughtful gifts that made the experience even more meaningful.\nEvent 1 Event Name: The First Cloud Journey (FCJ) Program Kick-off\nTime: 08:30 on September 6, 2025\nLocation: 26th Floor, Bitexco Tower, 02 Hai Trieu Street, Saigon Ward, Ho Chi Minh City\nRole in the Event: Attendee\nEvent 2 Event Name: AWS Cloud Mastery Series #1 ‚Äî AI/ML/GenAI on AWS\nTime: 08:30 on November 15, 2025\nLocation: 26th Floor, Bitexco Tower, 02 Hai Trieu Street, Saigon Ward, Ho Chi Minh City\nRole in the Event: Attendee\nEvent 3 Event Name: AWS Cloud Mastery Series #2: DevOps on AWS\nTime: 08:30 on November 17, 2025\nLocation: 26th Floor, Bitexco Tower, 02 Hai Trieu Street, Saigon Ward, Ho Chi Minh City\nRole in the Event: Attendee\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.04-configure-stacks/5.4.4-auth-stack/",
	"title": "5.4.4 Auth Stack",
	"tags": [],
	"description": "",
	"content": " Auth Stack - Authentication \u0026amp; User Management Overview The Auth Stack is the Phase 3 authentication layer of the EveryoneCook project. It manages user authentication, registration, and account security using AWS Cognito with custom Lambda triggers for enhanced user experience.\nDeployment Order: This stack MUST be deployed after Core Stack and before Backend Stack.\nKey Responsibilities Create Cognito User Pool with production-grade security settings Configure Cognito User Pool Client for web application Setup 5 Lambda triggers for custom authentication workflows Manage user registration, email verification, and login flows Handle user profile creation in DynamoDB (via PostConfirmation trigger) What This Stack Includes Cognito User Pool:\nSign-in: Username or email Password policy: Min 12 chars (8 for dev), uppercase, lowercase, digits, symbols Email verification required MFA: Disabled (email + password only) Device tracking: Enabled (no MFA challenge) Standard attributes: username, email, given_name (fullName) Custom attributes: account_status, country Cognito User Pool Client:\nAuth flows: USER_PASSWORD_AUTH, USER_SRP_AUTH OAuth flows: Authorization code grant (future social login) Token validity: Access/ID (1h), Refresh (30 days) Callback URLs: Environment-specific Lambda Triggers (5 triggers):\nPreSignUp: Cleanup unverified users (24h expiration) CustomMessage: Customize email templates PostConfirmation: Create user profile in DynamoDB PreAuthentication: Check if user is banned/suspended PostAuthentication: Update last login timestamp Architecture ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ Auth Stack (Phase 3) ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ Cognito User Pool ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Sign-in: Username or Email ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Password: Min 12 chars, strong policy ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Email Verification: Required ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ MFA: Disabled (email + password only) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Device Tracking: Enabled (no MFA) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Custom Attributes: account_status, country ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚ñº ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ Lambda Triggers (Custom Workflows) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 1Ô∏è‚É£ PreSignUp ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Check existing username/email ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Delete expired unverified users (\u0026gt;24h) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Allow new registration ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 2Ô∏è‚É£ CustomMessage ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Customize email verification template ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Customize password reset template ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Add styling and branding ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 3Ô∏è‚É£ PostConfirmation ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Create DynamoDB entities: ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ Core Profile (PK=USER#{userId}, SK=PROFILE) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ Privacy Settings (SK=PRIVACY_SETTINGS) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ AI Preferences (SK=AI_PREFERENCES) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Initialize user data ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 4Ô∏è‚É£ PreAuthentication ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Check user account status ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Reject if banned/suspended ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Allow login if active ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 5Ô∏è‚É£ PostAuthentication ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Update lastLoginAt timestamp ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Track user activity ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚ñº ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ Cognito User Pool Client ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Client Type: Web (no secret) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Auth Flows: Password, SRP ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ OAuth: Authorization code grant ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Tokens: 1h access, 1h ID, 30d refresh ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Callback: https://{env}.everyonecook.cloud ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Security: Token revocation, user enum protection ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ\r‚îÇ Exports\r‚ñº\rBackend Stack\r(API Gateway Cognito Authorizer) Stack Configuration File Structure infrastructure/lib/stacks/\r‚îî‚îÄ‚îÄ auth-stack.ts # Auth Stack (865 lines)\rservices/auth-module/triggers/\r‚îú‚îÄ‚îÄ pre-signup.ts # PreSignUp trigger\r‚îú‚îÄ‚îÄ custom-message.ts # CustomMessage trigger\r‚îú‚îÄ‚îÄ post-confirmation.ts # PostConfirmation trigger\r‚îú‚îÄ‚îÄ pre-authentication.ts # PreAuthentication trigger\r‚îî‚îÄ‚îÄ post-authentication.ts # PostAuthentication trigger Code Implementation Highlights File: infrastructure/lib/stacks/auth-stack.ts\n1. Cognito User Pool Creation /** * Create Cognito User Pool with production-grade security */ private createUserPool(): cdk.aws_cognito.UserPool { const cognitoConfig = this.config.cognito; const userPool = new cdk.aws_cognito.UserPool(this, \u0026#39;UserPool\u0026#39;, { userPoolName: `EveryoneCook-${this.config.environment}`, // Sign-in configuration signInAliases: { username: true, email: true, }, // Self sign-up enabled selfSignUpEnabled: true, // Standard attributes standardAttributes: { email: { required: true, mutable: false, // Email cannot be changed }, givenName: { required: true, // fullName stored in given_name mutable: true, }, birthdate: { required: false, mutable: true }, gender: { required: false, mutable: true }, }, // Custom attributes customAttributes: { account_status: new cdk.aws_cognito.StringAttribute({ mutable: true, minLen: 1, maxLen: 20, }), country: new cdk.aws_cognito.StringAttribute({ mutable: true, minLen: 2, maxLen: 2, // ISO 3166-1 alpha-2 }), }, // Password policy passwordPolicy: { minLength: 12, // 8 for dev requireLowercase: true, requireUppercase: true, requireDigits: true, requireSymbols: true, tempPasswordValidity: cdk.Duration.days(7), }, // Account recovery accountRecovery: cdk.aws_cognito.AccountRecovery.EMAIL_ONLY, // Email configuration (Cognito default) email: cdk.aws_cognito.UserPoolEmail.withCognito(), // Auto-verify email autoVerify: { email: true }, // MFA: Disabled mfa: cdk.aws_cognito.Mfa.OFF, // Device tracking (no MFA challenge) deviceTracking: { challengeRequiredOnNewDevice: false, deviceOnlyRememberedOnUserPrompt: true, }, // Email templates userVerification: { emailSubject: \u0026#39;üç≥ Verify your Everyone Cook account\u0026#39;, emailBody: \u0026#39;Hello {username}, your verification code is: {####}\u0026#39;, emailStyle: cdk.aws_cognito.VerificationEmailStyle.CODE, }, // Deletion protection for production deletionProtection: this.config.environment === \u0026#39;prod\u0026#39;, }); return userPool; } 2. Lambda Triggers /** * Create PostConfirmation Lambda Trigger * * Creates 3 DynamoDB entities after email verification: * 1. Core Profile (PK=USER#{userId}, SK=PROFILE) * 2. Privacy Settings (SK=PRIVACY_SETTINGS) * 3. AI Preferences (SK=AI_PREFERENCES) */ private createPostConfirmationTrigger( dynamoTable: cdk.aws_dynamodb.ITable ): cdk.aws_lambda.Function { const trigger = new cdk.aws_lambda.Function(this, \u0026#39;PostConfirmationTrigger\u0026#39;, { functionName: `EveryoneCook-${this.config.environment}-PostConfirmation`, runtime: cdk.aws_lambda.Runtime.NODEJS_20_X, handler: \u0026#39;post-confirmation.handler\u0026#39;, code: cdk.aws_lambda.Code.fromAsset( path.join(__dirname, \u0026#39;../../../services/auth-module/triggers/dist\u0026#39;) ), memorySize: 512, timeout: cdk.Duration.seconds(30), environment: { DYNAMODB_TABLE_NAME: dynamoTable.tableName, ENVIRONMENT: this.config.environment, }, }); // Grant DynamoDB write permissions dynamoTable.grantReadWriteData(trigger); return trigger; } /** * Create PreSignUp Lambda Trigger * * Handles cleanup of unverified users: * - If user exists and UNCONFIRMED \u0026gt;24h ‚Üí delete and allow new signup * - If user exists and UNCONFIRMED \u0026lt;24h ‚Üí reject with \u0026#34;wait 24h\u0026#34; message * - If user doesn\u0026#39;t exist ‚Üí allow signup */ private createPreSignUpTrigger(): cdk.aws_lambda.Function { const trigger = new cdk.aws_lambda.Function(this, \u0026#39;PreSignUpTrigger\u0026#39;, { functionName: `EveryoneCook-${this.config.environment}-PreSignUp`, runtime: cdk.aws_lambda.Runtime.NODEJS_20_X, handler: \u0026#39;pre-signup.handler\u0026#39;, code: cdk.aws_lambda.Code.fromAsset( path.join(__dirname, \u0026#39;../../../services/auth-module/triggers/dist\u0026#39;) ), memorySize: 256, timeout: cdk.Duration.seconds(10), }); // Grant Cognito permissions trigger.addToRolePolicy( new cdk.aws_iam.PolicyStatement({ effect: cdk.aws_iam.Effect.ALLOW, actions: [\u0026#39;cognito-idp:ListUsers\u0026#39;, \u0026#39;cognito-idp:AdminDeleteUser\u0026#39;], resources: [`arn:aws:cognito-idp:${this.region}:${this.account}:userpool/*`], }) ); return trigger; } 3. User Pool Client /** * Create Cognito User Pool Client for web application */ private createUserPoolClient(): cdk.aws_cognito.UserPoolClient { const callbackUrls = this.getCallbackUrls(); const logoutUrls = this.getLogoutUrls(); const userPoolClient = new cdk.aws_cognito.UserPoolClient( this, \u0026#39;UserPoolClient\u0026#39;, { userPoolClientName: `EveryoneCook-Web-Client-${this.config.environment}`, userPool: this.userPool, // Auth flows authFlows: { userPassword: true, // USER_PASSWORD_AUTH userSrp: true, // USER_SRP_AUTH (Secure Remote Password) custom: false, adminUserPassword: false, }, // OAuth configuration (future social login) oAuth: { flows: { authorizationCodeGrant: true, implicitCodeGrant: false, clientCredentials: false, }, scopes: [ cdk.aws_cognito.OAuthScope.EMAIL, cdk.aws_cognito.OAuthScope.OPENID, cdk.aws_cognito.OAuthScope.PROFILE, ], callbackUrls: callbackUrls, logoutUrls: logoutUrls, }, // Token validity accessTokenValidity: cdk.Duration.hours(1), idTokenValidity: cdk.Duration.hours(1), refreshTokenValidity: cdk.Duration.days(30), // Read attributes readAttributes: new cdk.aws_cognito.ClientAttributes() .withStandardAttributes({ email: true, emailVerified: true, givenName: true, }) .withCustomAttributes(\u0026#39;account_status\u0026#39;, \u0026#39;country\u0026#39;), // Security settings preventUserExistenceErrors: true, // Prevent enumeration attacks enableTokenRevocation: true, // Allow token revocation generateSecret: false, // No secret for web apps } ); return userPoolClient; } Key Configuration Details 1. User Registration Flow Registration Process:\n1. User signs up ‚Üí PreSignUp trigger\r‚îú‚îÄ Check if username/email exists\r‚îú‚îÄ If UNCONFIRMED \u0026gt;24h: Delete old user\r‚îú‚îÄ If UNCONFIRMED \u0026lt;24h: Reject with \u0026#34;wait 24h\u0026#34;\r‚îî‚îÄ Allow registration\r2. User receives verification email ‚Üí CustomMessage trigger\r‚îú‚îÄ Customize email template\r‚îî‚îÄ Send verification code\r3. User verifies email ‚Üí PostConfirmation trigger\r‚îú‚îÄ Create DynamoDB entities:\r‚îÇ ‚îú‚îÄ Core Profile (username, email, fullName, etc.)\r‚îÇ ‚îú‚îÄ Privacy Settings (default: private)\r‚îÇ ‚îî‚îÄ AI Preferences (default settings)\r‚îî‚îÄ User account ready\r4. User logs in ‚Üí PreAuthentication trigger\r‚îú‚îÄ Check account_status\r‚îú‚îÄ If banned/suspended: Reject login\r‚îî‚îÄ Allow login\r5. Login successful ‚Üí PostAuthentication trigger\r‚îî‚îÄ Update lastLoginAt timestamp 2. Password Policy Environments:\nEnvironment Min Length Requirements Dev 8 chars Uppercase, lowercase, digits, symbols Staging 12 chars Uppercase, lowercase, digits, symbols Prod 12 chars Uppercase, lowercase, digits, symbols Example Valid Passwords:\nMyP@ssw0rd123 (12 chars) Str0ng!Pass (11 chars, invalid for prod/staging) 3. Token Validity Token Type Validity Purpose Access Token 1 hour API authorization ID Token 1 hour User identity claims Refresh Token 30 days Renew access/ID tokens Token Refresh Flow:\nAccess token expires (1h) ‚Üí Use refresh token ‚Üí Get new access/ID tokens\rRefresh token expires (30d) ‚Üí User must login again 4. Lambda Trigger Details PreSignUp Trigger Purpose: Prevent \u0026ldquo;username already taken\u0026rdquo; errors for unverified users\nLogic:\nif (userExists \u0026amp;\u0026amp; userStatus === \u0026#39;UNCONFIRMED\u0026#39;) { const hoursSinceCreation = (now - userCreationDate) / (1000 * 60 * 60); if (hoursSinceCreation \u0026gt; 24) { // Delete expired unverified user await deleteUser(username); return allowSignUp(); } else { // User still has time to verify return rejectSignUp(`Please wait ${24 - hoursSinceCreation}h to register again`); } } else { return allowSignUp(); } PostConfirmation Trigger DynamoDB Entities Created:\n// 1. Core Profile { PK: \u0026#34;USER#{userId}\u0026#34;, SK: \u0026#34;PROFILE\u0026#34;, username: \u0026#34;john_doe\u0026#34;, email: \u0026#34;john@example.com\u0026#34;, fullName: \u0026#34;John Doe\u0026#34;, account_status: \u0026#34;active\u0026#34;, createdAt: \u0026#34;2025-01-01T00:00:00Z\u0026#34;, // ... other fields } // 2. Privacy Settings { PK: \u0026#34;USER#{userId}\u0026#34;, SK: \u0026#34;PRIVACY_SETTINGS\u0026#34;, profileVisibility: \u0026#34;private\u0026#34;, showEmail: false, allowMessages: \u0026#34;friends\u0026#34;, // ... other settings } // 3. AI Preferences { PK: \u0026#34;USER#{userId}\u0026#34;, SK: \u0026#34;AI_PREFERENCES\u0026#34;, aiEnabled: true, preferredLanguage: \u0026#34;en\u0026#34;, dietaryRestrictions: [], // ... other preferences } Stack Outputs After deployment, the stack exports the following values:\nOutput Name Value Used By UserPoolId ap-southeast-1_XXXXXXXXX Backend Stack (Authorizer) UserPoolArn arn:aws:cognito-idp:... Lambda IAM policies UserPoolClientId 1234567890abcdef Frontend (Amplify config) CustomMessageFunctionArn arn:aws:lambda:... Monitoring PostConfirmationFunctionArn arn:aws:lambda:... Monitoring PreAuthenticationFunctionArn arn:aws:lambda:... Monitoring PostAuthenticationFunctionArn arn:aws:lambda:... Monitoring Deployment Steps Step 1: Build Lambda Triggers Before deploying, compile Lambda triggers to JavaScript:\ncd D:\\Project_AWS\\everyonecook\\services\\auth-module\\triggers # Install dependencies npm install # Build TypeScript to JavaScript npm run build Expected output:\n\u0026gt; auth-module-triggers@1.0.0 build\r\u0026gt; tsc\rCompiled successfully to dist/ Step 2: Verify Prerequisites Core Stack successfully deployed DynamoDB table exists Lambda triggers built to dist/ folder Step 3: Deploy Auth Stack Navigate to infrastructure directory:\ncd D:\\Project_AWS\\everyonecook\\infrastructure Deploy Auth Stack to ap-southeast-1:\n# Deploy Auth Stack npx cdk deploy EveryoneCook-dev-Auth --context environment=dev Expected output:\n‚ú® Synthesis time: 7.23s\rEveryoneCook-dev-Auth: deploying...\r[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] (9/9)\rEveryoneCook-dev-Auth: creating CloudFormation changeset...\rEveryoneCook-dev-Auth\r‚ú® Deployment time: 180.45s\rOutputs:\rEveryoneCook-dev-Auth.UserPoolId = ap-southeast-1_a1B2c3D4e\rEveryoneCook-dev-Auth.UserPoolClientId = 1a2b3c4d5e6f7g8h9i0j\rEveryoneCook-dev-Auth.UserPoolArn = arn:aws:cognito-idp:ap-southeast-1:616580903213:userpool/...\rEveryoneCook-dev-Auth.PostConfirmationFunctionArn = arn:aws:lambda:ap-southeast-1:...\rEveryoneCook-dev-Auth.PreAuthenticationFunctionArn = arn:aws:lambda:ap-southeast-1:...\rStack ARN:\rarn:aws:cloudformation:ap-southeast-1:616580903213:stack/EveryoneCook-dev-Auth/... Step 4: Verify in AWS Console Navigate to Cognito User Pool Open AWS Console ‚Üí ap-southeast-1 region Go to Amazon Cognito \u0026gt; User pools Find EveryoneCook-dev Cognito User Pool showing sign-in options (username/email), MFA disabled, password policy, and deletion protection\nVerify:\nSign-in: Username or Email MFA: Disabled Password policy: Configured Email verification: Required Verify User Pool Configuration Click on the User Pool to view details:\nUser Pool configuration showing authentication settings, attributes, password policy, and security features\nCheck:\nSign-in experience: Username and Email enabled User attributes: email, given_name (required), birthdate, gender (optional) Custom attributes: account_status, country Password policy: Min 12 chars, requires uppercase, lowercase, digits, symbols MFA: Off Device tracking: Enabled Verify Lambda Triggers Go to User pool properties \u0026gt; Lambda triggers:\nLambda triggers configured for Pre sign-up, Custom message, Post confirmation, Pre authentication, and Post authentication\nVerify 5 triggers:\nPre sign-up: EveryoneCook-dev-PreSignUp Custom message: EveryoneCook-dev-CustomMessage Post confirmation: EveryoneCook-dev-PostConfirmation Pre authentication: EveryoneCook-dev-PreAuthentication Post authentication: EveryoneCook-dev-PostAuthentication Verify User Pool Client Go to App integration \u0026gt; App clients:\nUser Pool Client showing auth flows, OAuth settings, token validity, callback URLs, and security settings\nVerify:\nClient type: Public (no secret) Auth flows: USER_PASSWORD_AUTH, USER_SRP_AUTH OAuth flows: Authorization code grant Callback URLs: Environment-specific Token validity: 1h access, 1h ID, 30d refresh Navigate to Lambda Functions Go to Lambda \u0026gt; Functions, find Auth triggers:\nLambda functions showing all 5 Cognito triggers with runtime Node.js 20.x, memory 256-512 MB, and timeout 10-30s\nVerify:\nAll 5 Lambda functions created Runtime: Node.js 20.x Environment variables configured CloudWatch log groups created Check Lambda Permissions Click on a Lambda function ‚Üí Configuration \u0026gt; Permissions:\nLambda execution role showing permissions for DynamoDB (PostConfirmation), Cognito (PreSignUp), and CloudWatch Logs\nExpected permissions:\nPostConfirmation: DynamoDB read/write PreAuthentication: DynamoDB read PostAuthentication: DynamoDB read/write PreSignUp: Cognito ListUsers, AdminDeleteUser All triggers: CloudWatch Logs write Cost Breakdown Monthly Costs (Dev Environment) Resource Configuration Monthly Cost Notes Cognito User Pool \u0026lt;50 MAU $0 First 50K MAU free Lambda Triggers 5 functions, low invocations $0-1 Free tier covers most CloudWatch Logs 7-day retention, 5 log groups $0.50 ~1GB logs Total (Estimated) ~$0.50-1.50/month Very low for dev Cost Notes Cognito: First 50,000 MAU free, then $0.0055/MAU Lambda: 1M requests/month free, then $0.20 per 1M CloudWatch Logs: $0.50/GB ingested, $0.03/GB stored No MFA charges: MFA disabled saves $0.05/MAU Production Estimate (1000 MAU):\nCognito: 1000 MAU √ó $0.0055 = $5.50/month Lambda triggers: ~5000 invocations/month = $0 (free tier) CloudWatch Logs: $1-2/month Total: ~$7-8/month Cross-Stack Dependencies Imports from Previous Stacks From Core Stack:\ndynamoTable: cdk.Fn.importValue(\u0026#39;EveryoneCook-dev-DynamoDBTableName\u0026#39;) Exports Used By Other Stacks Backend Stack imports:\nUser Pool ID (for Cognito Authorizer) User Pool ARN (for API Gateway) User Pool Client ID (for frontend config) Dependency Flow Core Stack ‚Üí DynamoDB Table\r‚îÇ\r‚ñº\rAuth Stack (creates Cognito + Lambda triggers)\r‚îÇ\r‚îú‚îÄ‚ñ∫ User Pool ID ‚Üí Backend Stack (API Gateway Authorizer)\r‚îú‚îÄ‚ñ∫ User Pool Client ID ‚Üí Frontend (Amplify config)\r‚îî‚îÄ‚ñ∫ Lambda triggers ‚Üí User management workflows Validation Checklist Before proceeding to Backend Stack deployment:\nAuth Stack successfully deployed to ap-southeast-1 Cognito User Pool exists with correct settings 5 Lambda triggers configured and attached User Pool Client created with OAuth settings Lambda functions have correct IAM permissions CloudWatch log groups created (7-day retention) Stack outputs exported successfully Lambda trigger code built to dist/ folder Testing Test User Registration Flow Test sign-up with Cognito console:\nGo to Cognito \u0026gt; User pools \u0026gt; EveryoneCook-dev \u0026gt; Users \u0026gt; Create user\nCreate a test user:\nUsername: testuser01\rEmail: your-email@example.com\rFull Name: Test User\rTemporary Password: TempP@ss123 Verify email sent:\nCheck your email for verification code.\nCheck Lambda logs:\n# View PostConfirmation logs aws logs tail /aws/lambda/EveryoneCook-dev-PostConfirmation --follow --region ap-southeast-1 Verify DynamoDB entries:\n# Query user profile aws dynamodb query \\ --table-name EveryoneCook-dev-v2 \\ --key-condition-expression \u0026#34;PK = :pk\u0026#34; \\ --expression-attribute-values \u0026#39;{\u0026#34;:pk\u0026#34;:{\u0026#34;S\u0026#34;:\u0026#34;USER#testuser01\u0026#34;}}\u0026#39; \\ --region ap-southeast-1 Expected: 3 items (PROFILE, PRIVACY_SETTINGS, AI_PREFERENCES)\nTest Authentication Flow Login with test user:\nUse AWS CLI to authenticate:\naws cognito-idp initiate-auth \\ --auth-flow USER_PASSWORD_AUTH \\ --client-id \u0026lt;USER_POOL_CLIENT_ID\u0026gt; \\ --auth-parameters USERNAME=testuser01,PASSWORD=\u0026lt;password\u0026gt; \\ --region ap-southeast-1 Check PreAuthentication logs:\naws logs tail /aws/lambda/EveryoneCook-dev-PreAuthentication --follow --region ap-southeast-1 Check PostAuthentication logs:\naws logs tail /aws/lambda/EveryoneCook-dev-PostAuthentication --follow --region ap-southeast-1 Test PreSignUp Cleanup Create unverified user:\nSign up a user but don\u0026rsquo;t verify email.\nWait 24 hours (or modify trigger code to 1 minute for testing)\nTry to sign up again with same username:\nPreSignUp trigger should delete old user and allow new signup.\nNext Steps After successfully deploying the Auth Stack:\n‚û°Ô∏è 5.4.5 Backend Stack - Create API Gateway, Lambda functions, and SQS queues\nThe Backend Stack will:\nCreate API Gateway REST API with Cognito Authorizer Create 5 Lambda functions (auth, social, recipe, AI, admin) Create 6 SQS queues for async processing Create 6 worker Lambda functions Import User Pool ID from Auth Stack Configure API Gateway custom domain References Source Code: infrastructure/lib/stacks/auth-stack.ts Lambda Triggers: services/auth-module/triggers/ Base Stack: infrastructure/lib/base-stack.ts Environment Config: infrastructure/config/environment.ts AWS Documentation: Cognito User Pools Cognito Lambda Triggers Cognito User Pool Client Password Policies "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.05-deploy-infrastructure/",
	"title": "Deploy Infrastructure",
	"tags": [],
	"description": "",
	"content": "T·ªïng quan Trong b∆∞·ªõc n√†y, b·∫°n s·∫Ω deploy t·∫•t c·∫£ infrastructure stacks l√™n AWS theo ƒë√∫ng th·ª© t·ª± dependencies. D·ª± √°n EveryoneCook s·ª≠ d·ª•ng 5-Stack Architecture v·ªõi AWS CDK.\n5-Stack Architecture Phase 1: DNS Stack ‚Üí Route 53 Hosted Zone\rPhase 1.5: Certificate Stack ‚Üí ACM Certificates (us-east-1)\rPhase 2: Core Stack ‚Üí DynamoDB, S3, CloudFront, KMS\rPhase 3: Auth Stack ‚Üí Cognito, SES, Lambda Triggers\rPhase 4: Backend Stack ‚Üí API Gateway, Lambda, SQS, WAF\rPhase 5: Observability Stack ‚Üí CloudWatch Dashboards \u0026amp; Alarms Stack Dependencies DNS Stack (no dependencies)\r‚Üì\rCertificate Stack (depends on DNS)\r‚Üì\rCore Stack (depends on Certificate)\r‚Üì\rAuth Stack (depends on Core)\r‚Üì\rBackend Stack (depends on Auth, Core)\r‚Üì\rObservability Stack (depends on Backend) Deployment Timeline Stack Time Critical Resources DNS Stack 2-3 ph√∫t Route 53 Hosted Zone Certificate Stack 5-10 ph√∫t ACM Certificate (DNS validation) Core Stack 10-15 ph√∫t CloudFront Distribution, DynamoDB Auth Stack 5-7 ph√∫t Cognito User Pool, SES Backend Stack 8-12 ph√∫t API Gateway, 7 Lambda Functions Observability Stack 3-5 ph√∫t CloudWatch Dashboards Total deployment time: 35-50 ph√∫t\nPrerequisites 1. Verify AWS Credentials # Check AWS credentials aws sts get-caller-identity # Expected output: # { # \u0026#34;UserId\u0026#34;: \u0026#34;...\u0026#34;, # \u0026#34;Account\u0026#34;: \u0026#34;616580903213\u0026#34;, # \u0026#34;Arn\u0026#34;: \u0026#34;arn:aws:iam::616580903213:user/your-username\u0026#34; # } 2. Verify Node.js \u0026amp; CDK # Check Node.js version (must be 20.x+) node -v # v20.11.0 or higher # Check CDK version cdk --version # 2.114.0 or higher 3. Navigate to Infrastructure # Navigate to infrastructure directory cd D:\\Project_AWS\\everyonecook\\infrastructure # Verify cdk.json exists Get-Item cdk.json Phase 1: Deploy DNS Stack (Route 53) DNS Stack t·∫°o Route 53 Hosted Zone cho domain everyonecook.cloud. ƒê√¢y l√† stack ƒë·∫ßu ti√™n v√† quan tr·ªçng nh·∫•t.\nB∆∞·ªõc 1.1: Deploy DNS Stack # Deploy DNS Stack npx cdk deploy EveryoneCook-dev-DNS --context environment=dev # Review changes # Type \u0026#39;y\u0026#39; to confirm Expected output:\n‚úÖ EveryoneCook-dev-DNS\rOutputs:\rEveryoneCook-dev-DNS.HostedZoneId = Z018823421GWCSYG5UMHV\rEveryoneCook-dev-DNS.HostedZoneName = everyonecook.cloud\rEveryoneCook-dev-DNS.NameServers = ns-1164.awsdns-17.org, ns-825.awsdns-39.net, ns-1889.awsdns-44.co.uk, ns-453.awsdns-56.com\rStack ARN:\rarn:aws:cloudformation:ap-southeast-1:616580903213:stack/EveryoneCook-dev-DNS/... B∆∞·ªõc 1.2: L∆∞u Nameservers L∆ØU √ù QUAN TR·ªåNG: L∆∞u l·∫°i 4 nameservers t·ª´ output!\n# Get nameservers $nameservers = aws cloudformation describe-stacks ` --stack-name EveryoneCook-dev-DNS ` --query \u0026#39;Stacks[0].Outputs[?OutputKey==`NameServers`].OutputValue\u0026#39; ` --output text Write-Host \u0026#34;Nameservers: $nameservers\u0026#34; # ns-1164.awsdns-17.org, ns-825.awsdns-39.net, ns-1889.awsdns-44.co.uk, ns-453.awsdns-56.com B∆∞·ªõc 1.3: Update Domain Registrar C·∫≠p nh·∫≠t nameservers t·∫°i domain registrar (Hostinger, GoDaddy, Namecheap, etc.):\nLogin v√†o domain registrar T√¨m domain everyonecook.cloud Ch·ªçn \u0026ldquo;Custom Nameservers\u0026rdquo; ho·∫∑c \u0026ldquo;DNS Settings\u0026rdquo; X√≥a nameservers c≈© Nh·∫≠p 4 nameservers t·ª´ AWS: ns-1164.awsdns-17.org\rns-825.awsdns-39.net\rns-1889.awsdns-44.co.uk\rns-453.awsdns-56.com Save changes B∆∞·ªõc 1.4: Verify DNS Propagation # Check DNS propagation (c√≥ th·ªÉ m·∫•t 5-30 ph√∫t) nslookup -type=NS everyonecook.cloud # Ho·∫∑c d√πng dig (n·∫øu c√≥ WSL/Git Bash) dig NS everyonecook.cloud # Expected: Th·∫•y 4 nameservers t·ª´ AWS Online tools ƒë·ªÉ check:\nhttps://www.whatsmydns.net/ https://dnschecker.org/ ‚è≥ ƒê·ª£i DNS propagate tr∆∞·ªõc khi ti·∫øp t·ª•c (th∆∞·ªùng 5-15 ph√∫t)\nPhase 1.5: Deploy Certificate Stack (ACM) QUAN TR·ªåNG: Stack n√†y ph·∫£i deploy ·ªü us-east-1 region v√¨ CloudFront requirement.\nB∆∞·ªõc 1.5.1: Deploy Certificate Stack # Deploy Certificate Stack (us-east-1) npx cdk deploy EveryoneCook-dev-Certificate --context environment=dev # Type \u0026#39;y\u0026#39; to confirm Stack t·∫°o 2 certificates:\nCloudFront Certificate (us-east-1): cdn-dev.everyonecook.cloud API Gateway Certificate (us-east-1): *.everyonecook.cloud (wildcard) B∆∞·ªõc 1.5.2: Wait for DNS Validation ACM s·∫Ω t·ª± ƒë·ªông:\nT·∫°o CNAME records trong Route 53 ƒë·ªÉ validate domain Validate ownership Issue certificates Qu√° tr√¨nh n√†y m·∫•t 5-10 ph√∫t.\n# Check certificate status aws acm list-certificates --region us-east-1 # Get certificate ARN $certArn = aws acm list-certificates --region us-east-1 ` --query \u0026#39;CertificateSummaryList[?DomainName==`cdn-dev.everyonecook.cloud`].CertificateArn\u0026#39; ` --output text # Check validation status aws acm describe-certificate --certificate-arn $certArn --region us-east-1 ` --query \u0026#39;Certificate.{Status:Status,ValidationMethod:DomainValidationOptions[0].ValidationMethod}\u0026#39; Expected output:\n{ \u0026#34;Status\u0026#34;: \u0026#34;ISSUED\u0026#34;, \u0026#34;ValidationMethod\u0026#34;: \u0026#34;DNS\u0026#34; } B∆∞·ªõc 1.5.3: Verify Certificates # List all certificates aws cloudformation describe-stacks ` --stack-name EveryoneCook-dev-Certificate ` --region us-east-1 ` --query \u0026#39;Stacks[0].Outputs\u0026#39; # Expected: # CloudFrontCertificateArn = arn:aws:acm:us-east-1:...:certificate/... # ApiGatewayCertificateArn = arn:aws:acm:us-east-1:...:certificate/... ‚úÖ Ch·ªù ƒë·∫øn khi c·∫£ 2 certificates c√≥ Status = ISSUED\nPhase 2: Deploy Core Stack (Foundation) Core Stack t·∫°o foundation resources: DynamoDB, S3, CloudFront, KMS.\nB∆∞·ªõc 2.1: Deploy Core Stack # Deploy Core Stack (takes 10-15 minutes) npx cdk deploy EveryoneCook-dev-Core --context environment=dev # Type \u0026#39;y\u0026#39; to confirm Stack t·∫°o:\nDynamoDB:\nTable: EveryoneCook-dev Billing: Pay-per-request 5 GSI indexes (GSI1-GSI5) Stream enabled (for DynamoDB Streams) KMS encryption S3 Buckets (4 buckets):\neveryonecook-content-dev - User uploads (avatars, images) everyonecook-logs-dev - S3 access logs everyonecook-cdn-logs-dev - CloudFront logs everyonecook-incoming-emails-dev - SES email receiving CloudFront Distribution:\nCustom domain: cdn-dev.everyonecook.cloud Origin: S3 content bucket HTTPS only (certificate t·ª´ Certificate Stack) Compression enabled Price Class 200 (US, Europe, Asia) KMS Keys (2 keys):\nDynamoDB encryption key S3 encryption key B∆∞·ªõc 2.2: Monitor Deployment Deployment n√†y m·∫•t l√¢u nh·∫•t (10-15 ph√∫t) do CloudFront Distribution.\n# In another terminal, monitor CloudFormation events aws cloudformation describe-stack-events ` --stack-name EveryoneCook-dev-Core ` --max-items 10 ` --query \u0026#39;StackEvents[*].{Time:Timestamp,Status:ResourceStatus,Type:ResourceType,Resource:LogicalResourceId}\u0026#39; ` --output table B∆∞·ªõc 2.3: Verify Core Resources # Check DynamoDB table aws dynamodb describe-table --table-name EveryoneCook-dev ` --query \u0026#39;Table.{Name:TableName,Status:TableStatus,Billing:BillingModeSummary.BillingMode,Stream:StreamSpecification.StreamEnabled}\u0026#39; # Expected: # { # \u0026#34;Name\u0026#34;: \u0026#34;EveryoneCook-dev\u0026#34;, # \u0026#34;Status\u0026#34;: \u0026#34;ACTIVE\u0026#34;, # \u0026#34;Billing\u0026#34;: \u0026#34;PAY_PER_REQUEST\u0026#34;, # \u0026#34;Stream\u0026#34;: true # } # Check S3 buckets aws s3 ls | Select-String \u0026#34;everyonecook\u0026#34; # Expected: # everyonecook-cdn-logs-dev # everyonecook-content-dev # everyonecook-incoming-emails-dev # everyonecook-logs-dev # Check CloudFront distribution aws cloudfront list-distributions ` --query \u0026#39;DistributionList.Items[?Comment==`EveryoneCook CDN (dev)`].{Id:Id,Domain:DomainName,Status:Status}\u0026#39; # Expected: # { # \u0026#34;Id\u0026#34;: \u0026#34;E2INNJ4XX421Q3\u0026#34;, # \u0026#34;Domain\u0026#34;: \u0026#34;d2shrpzup69rju.cloudfront.net\u0026#34;, # \u0026#34;Status\u0026#34;: \u0026#34;Deployed\u0026#34; # } B∆∞·ªõc 2.4: Get Stack Outputs # Get all Core Stack outputs aws cloudformation describe-stacks ` --stack-name EveryoneCook-dev-Core ` --query \u0026#39;Stacks[0].Outputs[*].{Key:OutputKey,Value:OutputValue}\u0026#39; ` --output table Key outputs:\nDynamoDBTableName: EveryoneCook-dev ContentBucketName: everyonecook-content-dev CloudFrontDistributionId: E2INNJ4XX421Q3 CloudFrontDomainName: d2shrpzup69rju.cloudfront.net Phase 3: Deploy Auth Stack (Cognito \u0026amp; SES) Auth Stack t·∫°o authentication infrastructure v·ªõi Cognito v√† SES.\nB∆∞·ªõc 3.1: Deploy Auth Stack # Deploy Auth Stack npx cdk deploy EveryoneCook-dev-Auth --context environment=dev # Type \u0026#39;y\u0026#39; to confirm Stack t·∫°o:\nCognito User Pool:\nUser Pool: EveryoneCook-UserPool-dev Password policy: 12 chars min, requires symbols MFA: Optional Email verification 5 Lambda Triggers:\nPre-Signup - Validate username/email Post-Confirmation - T·∫°o user profile trong DynamoDB Post-Authentication - Update lastLoginAt Pre-Authentication - Check ban status Custom Message - Custom email templates SES Email Identity:\nDomain: everyonecook.cloud DKIM authentication Mail FROM domain: mail.everyonecook.cloud Production mode (can send to any email) IAM Roles:\nLambda execution roles Cognito SMS role (for MFA) B∆∞·ªõc 3.2: Verify Cognito User Pool # Get User Pool ID $userPoolId = aws cloudformation describe-stacks ` --stack-name EveryoneCook-dev-Auth ` --query \u0026#39;Stacks[0].Outputs[?OutputKey==`UserPoolId`].OutputValue\u0026#39; ` --output text Write-Host \u0026#34;User Pool ID: $userPoolId\u0026#34; # ap-southeast-1_PKoL34PF0 # Describe User Pool aws cognito-idp describe-user-pool --user-pool-id $userPoolId ` --query \u0026#39;UserPool.{Name:Name,Status:Status,MFA:MfaConfiguration}\u0026#39; B∆∞·ªõc 3.3: Verify Lambda Triggers # Check Lambda triggers attached to User Pool aws cognito-idp describe-user-pool --user-pool-id $userPoolId ` --query \u0026#39;UserPool.LambdaConfig\u0026#39; # Expected: 5 triggers configured # { # \u0026#34;PreSignUp\u0026#34;: \u0026#34;arn:aws:lambda:...:function:EveryoneCook-dev-PreSignup\u0026#34;, # \u0026#34;PostConfirmation\u0026#34;: \u0026#34;arn:aws:lambda:...:function:EveryoneCook-dev-PostConfirmation\u0026#34;, # \u0026#34;PostAuthentication\u0026#34;: \u0026#34;arn:aws:lambda:...:function:EveryoneCook-dev-PostAuthentication\u0026#34;, # \u0026#34;PreAuthentication\u0026#34;: \u0026#34;arn:aws:lambda:...:function:EveryoneCook-dev-PreAuthentication\u0026#34;, # \u0026#34;CustomMessage\u0026#34;: \u0026#34;arn:aws:lambda:...:function:EveryoneCook-dev-CustomMessage\u0026#34; # } B∆∞·ªõc 3.4: Verify SES Email Identity # Check SES identity status aws sesv2 get-email-identity --email-identity everyonecook.cloud ` --query \u0026#39;{Status:VerifiedForSendingStatus,DKIM:DkimAttributes.Status}\u0026#39; # Expected: # { # \u0026#34;Status\u0026#34;: true, # \u0026#34;DKIM\u0026#34;: \u0026#34;SUCCESS\u0026#34; # } # Check DKIM records in Route 53 aws route53 list-resource-record-sets ` --hosted-zone-id Z018823421GWCSYG5UMHV ` --query \u0026#39;ResourceRecordSets[?Type==`CNAME` \u0026amp;\u0026amp; contains(Name, `_domainkey`)]\u0026#39; ‚úÖ SES ph·∫£i ·ªü Production mode ƒë·ªÉ send email ƒë·∫øn b·∫•t k·ª≥ ƒë·ªãa ch·ªâ n√†o\nPhase 4: Deploy Backend Stack (API \u0026amp; Lambda) Backend Stack t·∫°o API Gateway v√† Lambda functions. Tr∆∞·ªõc khi deploy, c·∫ßn build Lambda code.\nB∆∞·ªõc 4.1: Build Lambda Code # Navigate to project root cd D:\\Project_AWS\\everyonecook # Run deployment script to build all Lambda code .\\deploy\\deploy-backend.ps1 -Environment dev -SkipBuild:$false # Or manual build: # Build all modules cd services/api-router; npm run build; cd ../.. cd services/auth-module; npm run build; cd ../.. cd services/social-module; npm run build; cd ../.. cd services/ai-module; npm run build; cd ../.. cd services/admin-module; npm run build; cd ../.. cd services/upload-module; npm run build; cd ../.. ‚ö†Ô∏è QUAN TR·ªåNG: Lambda code ph·∫£i ƒë∆∞·ª£c build TR∆Ø·ªöC khi deploy Backend Stack!\nB∆∞·ªõc 4.2: Deploy Backend Stack # Navigate back to infrastructure cd D:\\Project_AWS\\everyonecook\\infrastructure # Deploy Backend Stack npx cdk deploy EveryoneCook-dev-Backend --context environment=dev # Type \u0026#39;y\u0026#39; to confirm Stack t·∫°o:\nAPI Gateway:\nREST API: EveryoneCook-API-dev Custom domain: api-dev.everyonecook.cloud Cognito Authorizer WAF Web ACL protection 7 Lambda Functions:\neveryonecook-dev-api-router - API routing (512 MB, 30s)\neveryonecook-dev-auth-user - Auth \u0026amp; User Management (512 MB, 30s)\neveryonecook-dev-social - Social features (512 MB, 30s)\neveryonecook-dev-recipe-ai - Recipes \u0026amp; AI (1024 MB, 60s)\neveryonecook-dev-ai-worker - AI processing worker (1024 MB, 300s)\neveryonecook-dev-admin - Admin dashboard (512 MB, 30s)\neveryonecook-dev-upload - File upload (256 MB, 15s)\nLambda Layer:\neveryonecook-shared-deps-dev - Shared dependencies (~15-20 MB) SQS Queues (4 queues + 4 DLQs):\nAI Queue + DLQ Image Processing Queue + DLQ Analytics Queue + DLQ Notification Queue + DLQ WAF Web ACL:\nAPI Gateway protection Rate limiting (2000 req/5min per IP) Geo blocking support B∆∞·ªõc 4.3: Verify API Gateway # Get API endpoint $apiUrl = aws cloudformation describe-stacks ` --stack-name EveryoneCook-dev-Backend ` --query \u0026#39;Stacks[0].Outputs[?OutputKey==`ApiCustomDomain`].OutputValue\u0026#39; ` --output text Write-Host \u0026#34;API Endpoint: $apiUrl\u0026#34; # https://api-dev.everyonecook.cloud # Test health endpoint $response = Invoke-RestMethod -Uri \u0026#34;$apiUrl/health\u0026#34; -Method Get $response | ConvertTo-Json # Expected: # { # \u0026#34;status\u0026#34;: \u0026#34;healthy\u0026#34;, # \u0026#34;timestamp\u0026#34;: \u0026#34;2025-12-09T...\u0026#34;, # \u0026#34;service\u0026#34;: \u0026#34;EveryoneCook API\u0026#34;, # \u0026#34;environment\u0026#34;: \u0026#34;dev\u0026#34; # } B∆∞·ªõc 4.4: Verify Lambda Functions # List all Lambda functions aws lambda list-functions ` --query \u0026#39;Functions[?contains(FunctionName, `everyonecook-dev`)].{Name:FunctionName,Runtime:Runtime,Memory:MemorySize,Timeout:Timeout}\u0026#39; ` --output table # Expected: 7 functions + 5 Cognito triggers = 12 Lambda functions total B∆∞·ªõc 4.5: Verify SQS Queues # List SQS queues aws sqs list-queues --queue-name-prefix everyonecook-dev # Expected: 8 queues (4 main + 4 DLQ) # - everyonecook-dev-ai-queue # - everyonecook-dev-ai-queue-dlq # - everyonecook-dev-image-queue # - everyonecook-dev-image-queue-dlq # - everyonecook-dev-analytics-queue # - everyonecook-dev-analytics-queue-dlq # - everyonecook-dev-notification-queue # - everyonecook-dev-notification-queue-dlq Phase 5: Deploy Observability Stack (CloudWatch) Observability Stack t·∫°o monitoring dashboards v√† alarms.\nB∆∞·ªõc 5.1: Deploy Observability Stack # Deploy Observability Stack npx cdk deploy EveryoneCook-dev-Observability --context environment=dev # Type \u0026#39;y\u0026#39; to confirm Stack t·∫°o:\n4 CloudWatch Dashboards:\nCore Dashboard - DynamoDB, S3, CloudFront metrics Auth Dashboard - Cognito, SES metrics Backend Dashboard - API Gateway, Lambda metrics Overview Dashboard - High-level system health CloudWatch Alarms:\nDynamoDB throttling Lambda errors API Gateway 5xx errors CloudFront 5xx errors SNS Topic:\nAlarm notifications Email subscription support Composite Alarm:\nCritical system health alarm Aggregates multiple alarms B∆∞·ªõc 5.2: Subscribe to SNS Topic # Get SNS topic ARN $topicArn = aws cloudformation describe-stacks ` --stack-name EveryoneCook-dev-Observability ` --query \u0026#39;Stacks[0].Outputs[?OutputKey==`AlarmTopicArn`].OutputValue\u0026#39; ` --output text # Subscribe your email aws sns subscribe ` --topic-arn $topicArn ` --protocol email ` --notification-endpoint \u0026#34;your-email@example.com\u0026#34; Write-Host \u0026#34;Check your email and confirm subscription!\u0026#34; B∆∞·ªõc 5.3: Verify Dashboards # List CloudWatch dashboards aws cloudwatch list-dashboards ` --query \u0026#39;DashboardEntries[?contains(DashboardName, `EveryoneCook-dev`)].DashboardName\u0026#39; # Expected: # - EveryoneCook-dev-CoreDashboard # - EveryoneCook-dev-AuthDashboard # - EveryoneCook-dev-BackendDashboard # - EveryoneCook-dev-OverviewDashboard # Get dashboard URL $region = \u0026#34;ap-southeast-1\u0026#34; $dashboardName = \u0026#34;EveryoneCook-dev-OverviewDashboard\u0026#34; Write-Host \u0026#34;Dashboard URL: https://console.aws.amazon.com/cloudwatch/home?region=$region#dashboards:name=$dashboardName\u0026#34; Verify Complete Deployment B∆∞·ªõc 6.1: List All Stacks # List all deployed stacks aws cloudformation list-stacks ` --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE ` --query \u0026#39;StackSummaries[?contains(StackName, `EveryoneCook-dev`)].{Name:StackName,Status:StackStatus,Created:CreationTime}\u0026#39; ` --output table Expected stacks:\n------------------------------------------------------------\r| ListStacks |\r+--------------------------------------------------+--------+\r| Name | Status | Created|\r+--------------------------------------------------+--------+\r| EveryoneCook-dev-DNS | CREATE_COMPLETE |\r| EveryoneCook-dev-Certificate | CREATE_COMPLETE |\r| EveryoneCook-dev-Core | CREATE_COMPLETE |\r| EveryoneCook-dev-Auth | CREATE_COMPLETE |\r| EveryoneCook-dev-Backend | CREATE_COMPLETE |\r| EveryoneCook-dev-Observability | CREATE_COMPLETE |\r+--------------------------------------------------+--------+ B∆∞·ªõc 6.2: Get All Stack Outputs # Create comprehensive outputs report $stacks = @(\u0026#34;DNS\u0026#34;, \u0026#34;Certificate\u0026#34;, \u0026#34;Core\u0026#34;, \u0026#34;Auth\u0026#34;, \u0026#34;Backend\u0026#34;, \u0026#34;Observability\u0026#34;) foreach ($stack in $stacks) { Write-Host \u0026#34;`n========================================\u0026#34; -ForegroundColor Cyan Write-Host \u0026#34;EveryoneCook-dev-$stack Outputs\u0026#34; -ForegroundColor Cyan Write-Host \u0026#34;========================================\u0026#34; -ForegroundColor Cyan aws cloudformation describe-stacks ` --stack-name \u0026#34;EveryoneCook-dev-$stack\u0026#34; ` --query \u0026#39;Stacks[0].Outputs[*].{Key:OutputKey,Value:OutputValue}\u0026#39; ` --output table } B∆∞·ªõc 6.3: Save Outputs to File # Save outputs to infrastructure/outputs.json cd D:\\Project_AWS\\everyonecook\\infrastructure # Get outputs in JSON format $outputs = @{} foreach ($stack in $stacks) { $stackOutputs = aws cloudformation describe-stacks ` --stack-name \u0026#34;EveryoneCook-dev-$stack\u0026#34; ` --query \u0026#39;Stacks[0].Outputs\u0026#39; | ConvertFrom-Json $stackData = @{} foreach ($output in $stackOutputs) { $stackData[$output.OutputKey] = $output.OutputValue } $outputs[\u0026#34;EveryoneCook-dev-$stack\u0026#34;] = $stackData } # Save to file $outputs | ConvertTo-Json -Depth 5 | Out-File -FilePath \u0026#34;outputs.json\u0026#34; -Encoding utf8 Write-Host \u0026#34;Outputs saved to outputs.json\u0026#34; -ForegroundColor Green B∆∞·ªõc 6.4: Verify Key Resources # Comprehensive resource verification Write-Host \u0026#34;`n===== RESOURCE VERIFICATION =====\u0026#34; -ForegroundColor Yellow # DynamoDB Write-Host \u0026#34;`nDynamoDB Table:\u0026#34; -ForegroundColor Cyan aws dynamodb describe-table --table-name EveryoneCook-dev ` --query \u0026#39;Table.{Name:TableName,Status:TableStatus,ItemCount:ItemCount,Size:TableSizeBytes}\u0026#39; ` --output table # S3 Buckets Write-Host \u0026#34;`nS3 Buckets:\u0026#34; -ForegroundColor Cyan aws s3 ls | Select-String \u0026#34;everyonecook\u0026#34; # CloudFront Write-Host \u0026#34;`nCloudFront Distribution:\u0026#34; -ForegroundColor Cyan aws cloudfront list-distributions ` --query \u0026#39;DistributionList.Items[?Comment==`EveryoneCook CDN (dev)`].{Id:Id,Status:Status,Domain:DomainName}\u0026#39; ` --output table # Lambda Functions Write-Host \u0026#34;`nLambda Functions:\u0026#34; -ForegroundColor Cyan aws lambda list-functions ` --query \u0026#39;Functions[?contains(FunctionName, `everyonecook-dev`)].FunctionName\u0026#39; ` --output table # Cognito User Pool Write-Host \u0026#34;`nCognito User Pool:\u0026#34; -ForegroundColor Cyan aws cognito-idp list-user-pools --max-results 10 ` --query \u0026#39;UserPools[?Name==`EveryoneCook-UserPool-dev`].{Name:Name,Id:Id,Status:Status}\u0026#39; ` --output table # API Gateway Write-Host \u0026#34;`nAPI Gateway:\u0026#34; -ForegroundColor Cyan aws apigateway get-rest-apis ` --query \u0026#39;items[?name==`EveryoneCook-API-dev`].{Name:name,Id:id}\u0026#39; ` --output table # SQS Queues Write-Host \u0026#34;`nSQS Queues:\u0026#34; -ForegroundColor Cyan aws sqs list-queues --queue-name-prefix everyonecook-dev ` --query \u0026#39;QueueUrls\u0026#39; --output table Write-Host \u0026#34;`n===== VERIFICATION COMPLETE =====\u0026#34; -ForegroundColor Green Deployment Summary Deployed Resources Count Category Count Resources Networking 5 Route 53 Hosted Zone, 2 ACM Certificates, CloudFront Distribution, WAF Web ACL Storage 6 DynamoDB Table (5 GSI), 4 S3 Buckets, 2 KMS Keys Compute 12 7 Lambda Functions, 5 Cognito Triggers Integration 8 API Gateway, 4 SQS Queues, 4 DLQ Security 8 Cognito User Pool, SES Identity, IAM Roles (6) Monitoring 15 4 Dashboards, 10+ Alarms, SNS Topic Total Resources: ~100+ AWS resources\nStack-by-Stack Breakdown DNS Stack:\n‚úÖ Route 53 Hosted Zone Certificate Stack:\n‚úÖ 2 ACM Certificates (us-east-1) Core Stack:\n‚úÖ DynamoDB Table + 5 GSIs + Stream ‚úÖ 4 S3 Buckets ‚úÖ CloudFront Distribution ‚úÖ 2 KMS Keys Auth Stack:\n‚úÖ Cognito User Pool + Client ‚úÖ 5 Lambda Triggers ‚úÖ SES Email Identity ‚úÖ IAM Roles Backend Stack:\n‚úÖ API Gateway REST API ‚úÖ 7 Lambda Functions ‚úÖ Lambda Layer ‚úÖ 4 SQS Queues + 4 DLQs ‚úÖ WAF Web ACL Observability Stack:\n‚úÖ 4 CloudWatch Dashboards ‚úÖ 10+ CloudWatch Alarms ‚úÖ SNS Topic ‚úÖ Composite Alarm Troubleshooting Issue 1: Stack Deployment Failed # Check CloudFormation events for errors aws cloudformation describe-stack-events ` --stack-name EveryoneCook-dev-STACKNAME ` --max-items 20 ` --query \u0026#39;StackEvents[?ResourceStatus==`CREATE_FAILED` || ResourceStatus==`ROLLBACK_IN_PROGRESS`].{Time:Timestamp,Status:ResourceStatus,Reason:ResourceStatusReason,Resource:LogicalResourceId}\u0026#39; ` --output table # Common causes: # - Missing dependencies (check dependency order) # - Insufficient permissions # - Resource limits exceeded # - Naming conflicts Issue 2: Certificate Validation Stuck # Check certificate status $certArn = \u0026#34;arn:aws:acm:us-east-1:...:certificate/...\u0026#34; aws acm describe-certificate --certificate-arn $certArn --region us-east-1 ` --query \u0026#39;Certificate.DomainValidationOptions[0].{Domain:DomainName,Status:ValidationStatus,Method:ValidationMethod}\u0026#39; # Check DNS records aws route53 list-resource-record-sets ` --hosted-zone-id Z018823421GWCSYG5UMHV ` --query \u0026#39;ResourceRecordSets[?Type==`CNAME`]\u0026#39; # Solutions: # - Verify nameservers updated at registrar # - Wait for DNS propagation (up to 48h, usually 15min) # - Check validation CNAME records exist in Route 53 Issue 3: Lambda Deployment Failed # Check if dist folder exists Get-ChildItem D:\\Project_AWS\\everyonecook\\services\\*\\dist # If missing, rebuild cd D:\\Project_AWS\\everyonecook .\\deploy\\deploy-backend.ps1 -Environment dev # Check Lambda package size Get-ChildItem D:\\Project_AWS\\everyonecook\\services\\*\\lambda.zip | Select-Object Name, @{Name=\u0026#34;Size(MB)\u0026#34;;Expression={[math]::Round($_.Length/1MB,2)}} # Lambda limits: # - Deployment package: 50 MB (zipped) # - Unzipped: 250 MB Issue 4: CloudFront Distribution Failed # Check certificate region (must be us-east-1) aws acm list-certificates --region us-east-1 ` --query \u0026#39;CertificateSummaryList[?DomainName==`cdn-dev.everyonecook.cloud`]\u0026#39; # Check S3 bucket exists aws s3 ls everyonecook-content-dev # Solutions: # - Ensure Certificate Stack deployed first # - Certificate must be in us-east-1 # - S3 bucket must exist before CloudFront Issue 5: Insufficient IAM Permissions # Check current user/role aws sts get-caller-identity # Required permissions: # - cloudformation:* (all CloudFormation operations) # - iam:* (create roles, policies) # - lambda:* (create functions) # - apigateway:* (create API) # - cognito-idp:* (create user pools) # - s3:* (create buckets) # - dynamodb:* (create tables) # - route53:* (create hosted zones) # - acm:* (create certificates) # - cloudfront:* (create distributions) # - wafv2:* (create web ACLs) # - logs:* (create log groups) # - sns:* (create topics) # - sqs:* (create queues) # Recommended: AdministratorAccess policy (for first deployment) Issue 6: Stack Rollback # If stack rolls back, check reason aws cloudformation describe-stack-events ` --stack-name EveryoneCook-dev-STACKNAME ` --query \u0026#39;StackEvents[?ResourceStatus==`CREATE_FAILED`].[Timestamp,ResourceStatusReason]\u0026#39; ` --output table # Delete failed stack before retry aws cloudformation delete-stack --stack-name EveryoneCook-dev-STACKNAME # Wait for deletion aws cloudformation wait stack-delete-complete --stack-name EveryoneCook-dev-STACKNAME # Redeploy npx cdk deploy EveryoneCook-dev-STACKNAME --context environment=dev Cost Estimation Monthly Cost Breakdown (Dev Environment) Service Usage Cost DynamoDB Pay-per-request, low usage $2-5 S3 10 GB storage + requests $1-2 CloudFront 10 GB transfer $1-2 Lambda 1M requests, 512 MB $3-5 API Gateway 100K requests $0.35 Cognito 100 MAU $0-5 SES 100 emails $0.01 CloudWatch Logs + metrics $2-3 WAF Basic rules $5 Route 53 1 hosted zone $0.50 SQS 100K requests $0.04 KMS 2 keys $2 Total Estimated Monthly Cost: $20-35 (without OpenSearch)\nWith OpenSearch (if enabled): $70-135/month\nCost Tracking # Check current month costs $startDate = (Get-Date -Day 1).ToString(\u0026#34;yyyy-MM-dd\u0026#34;) $endDate = (Get-Date).AddDays(1).ToString(\u0026#34;yyyy-MM-dd\u0026#34;) aws ce get-cost-and-usage ` --time-period Start=$startDate,End=$endDate ` --granularity DAILY ` --metrics BlendedCost ` --group-by Type=SERVICE ` --output table Next Steps Infrastructure deployment ho√†n th√†nh! Ti·∫øp theo:\n‚úÖ Verify All Stacks: All 6 stacks deployed successfully üîß Configure API: Setup API routes v√† Lambda integration ‚Üí 5.06 - Configure API \u0026amp; Lambda üöÄ Deploy Backend Code: Build v√† deploy Lambda code ‚Üí 5.07 - Deploy Backend ‚úÖ Test Endpoints: Verify API functionality ‚Üí 5.08 - Test Endpoints Current Status:\nInfrastructure: ‚úÖ Complete Lambda Code: ‚è≥ Need to deploy Testing: ‚è≥ Pending Proceed to: 5.06 - Configure API \u0026amp; Lambda\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/",
	"title": "Workshop",
	"tags": [],
	"description": "",
	"content": "Building EveryoneCook: A Full-Stack AWS Infrastructure Workshop Overview In this comprehensive workshop, you will learn how to build a production-ready, full-stack social cooking application infrastructure on AWS using Infrastructure as Code (IaC) with AWS CDK. The EveryoneCook platform demonstrates modern cloud architecture patterns, including serverless computing, content delivery, AI-powered features, advanced search with OpenSearch, and comprehensive observability.\nYou will deploy seven interconnected CDK stacks that work together to create a scalable, secure, and cost-optimized application:\nDNS Stack - Route 53 hosted zone for domain management Certificate Stack - ACM certificates for CloudFront and API Gateway (us-east-1) CoreStack - DynamoDB Single Table, S3 buckets, CloudFront CDN, KMS encryption, and OpenSearch AuthStack - Cognito User Pool with Lambda triggers and SES email integration BackendStack - API Gateway, Lambda functions (6 modules), SQS queues, and WAF protection FrontendStack - AWS Amplify hosting for Next.js 15 application (optional) ObservabilityStack - CloudWatch dashboards, alarms, and X-Ray distributed tracing Content Workshop Overview Setup Environment CDK Bootstrap Configure Infrastructure Stacks Deploy Infrastructure Configure API \u0026amp; Lambda Deploy Backend Services Test Endpoints End-to-End Push to GitLab Deploy to Amplify Clean up "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/1.5-week5/",
	"title": "Week 5 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 5 Objectives: Operational Excellence: Automate operational tasks (server start/stop) using AWS Lambda and integrate with communication tools (Slack). Monitoring \u0026amp; Observability: Build advanced dashboards using Grafana integrated with Amazon CloudWatch for deep system insights. Governance \u0026amp; Tagging: Implement resource organization strategies using Tags, Resource Groups, and enforce Attribute-Based Access Control (ABAC) via IAM. Systems Management (SSM): Explore server management without SSH using Session Manager and understand automated patching workflows (Patch Manager). Infrastructure as Code (IaC): Begin automating infrastructure deployment using AWS CloudFormation. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 Cost Optimization \u0026amp; Automation - Create Lambda functions (Python boto3) to automatically Start/Stop EC2 instances based on schedules. - Integrate Lambda with Slack Webhooks for operational notifications. - Configure EventBridge (CloudWatch Events) triggers. 06/10/2025 06/10/2025 https://000022.awsstudygroup.com/ 3 Advanced Monitoring (Grafana) - Launch EC2 to host Grafana (Open Source). - Connect Grafana to Amazon CloudWatch data source. - Create custom dashboards visualizing CPU, Network, and Disk metrics from EC2. 07/10/2025 07/10/2025 https://000029.awsstudygroup.com/ 4 Governance \u0026amp; Security (Tags \u0026amp; IAM) - Tagging Strategy: Apply consistent tags to resources (Env, Owner, CostCenter). - Create Resource Groups to manage resources by tags. - ABAC Implementation: Configure IAM Policies to control EC2 access based on matching tags between User and Resource. 08/10/2025 08/10/2025 https://000027.awsstudygroup.com/ https://000028.awsstudygroup.com/ 5 Systems Management (SSM) - Session Manager: Connect to private/public instances without opening SSH ports (Port Forwarding, Audit Logs to S3). - Run Command: Execute remote commands across multiple instances. - Theory/Review: Patch Manager workflows (scanning \u0026amp; compliance) due to potential Free Tier/Lab permission limits. 09/10/2025 09/10/2025 https://000058.awsstudygroup.com/ https://000031.awsstudygroup.com/ 6 Infrastructure as Code (CloudFormation) - Write basic CloudFormation templates (YAML/JSON) to deploy VPC and EC2. - Understand Stacks, Parameters, Mappings, and Outputs. - Explore Drift Detection to identify manual changes to infrastructure. 10/10/2025 10/10/2025 https://000037.awsstudygroup.com/ Week 5 Achievements Automation \u0026amp; Cost Management Successfully implemented automated cost-saving mechanisms by scheduling non-production EC2 instances to stop during off-hours using AWS Lambda. Deployed a notification system where operational events trigger messages to a Slack channel, improving team visibility. Reduced manual intervention by leveraging EventBridge Rules to trigger automation workflows. Monitoring Visualization Deployed a self-hosted Grafana instance on EC2. successfully integrated Amazon CloudWatch as a data source for Grafana, enabling the visualization of AWS metrics in a unified, customizable interface. Created specific dashboards to monitor EC2 health, overcoming the limitations of default CloudWatch views. Resource Governance \u0026amp; Security Mastered Tagging strategies to organize resources by environment (Dev/Prod) and project. Implemented Resource Groups to bulk-manage resources sharing common tags. Enhanced security using Attribute-Based Access Control (ABAC): Configured IAM policies that strictly allow users to manage only the EC2 instances that match their specific department tags, effectively isolating environments. Systems Operations (SysOps) Eliminated the need for Bastion Hosts/SSH keys by using AWS Systems Manager Session Manager for secure instance access. Configured Session Logging to S3 for auditing and compliance purposes. Studied and simulated the Patch Manager process for automating OS updates and maintaining compliance across fleets of instances. Utilized Run Command to execute administrative scripts across multiple servers simultaneously without logging into each one. Infrastructure as Code (IaC) Transitioned from manual console clicks to defining infrastructure in code using AWS CloudFormation. Created and deployed Stacks to provision VPCs and EC2 instances, ensuring consistent and repeatable deployments. Learned to detect \u0026ldquo;Configuration Drift\u0026rdquo; to identify where actual infrastructure state deviates from the defined CloudFormation templates. "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/3-blogstranslated/3.5-blog5/",
	"title": "Blog 5: Solution-Centric Procurement Strategy on AWS Marketplace",
	"tags": [],
	"description": "",
	"content": "Overview: From Individual Products to Comprehensive Solutions At this re:Invent, AWS Marketplace announced a strategic shift in software purchasing: moving from buying discrete tools to \u0026ldquo;Solution-centric procurement\u0026rdquo;.\nToday\u0026rsquo;s enterprise customer needs go beyond searching for a specific piece of software. They seek complete business outcomes for example, a comprehensive security solution for healthcare data, or an intelligent manufacturing data analytics system. To meet this demand, AWS Marketplace introduces support for Multi-product solutions, allowing Partners to bundle software, services, and data into a single order.\n1. Introducing Multi-product Solutions This is the latest core feature. Multi-product solutions allow AWS Partners (ISVs, Channel Partners, System Integrators) to combine multiple products and services from different vendors into a single solution package.\nInstead of customers having to search, evaluate, and purchase each component separately (for example: buying SIEM software from vendor A, purchasing deployment consulting services from vendor B, and buying datasets from vendor C), they can now purchase a complete \u0026ldquo;Security Operations Center (SOC) Solution\u0026rdquo; that includes all these components.\n[Figure 1] Accenture solution interface, including both software and services.\nCustomers can scroll down the details page to view each component in this solution package:\n[Figure 2] Details of each component (Software, Services) in a multi-product solution package.\n2. Streamlined Procurement One of the biggest barriers when implementing complex solutions is the administrative process. The new feature significantly simplifies this:\nSingle negotiation point: Customers negotiate pricing and terms for the entire solution package with a single partner. Flexible components: Despite purchasing as a package, customers can still customize terms and renewals for individual components within the package independently if needed. Centralized governance: All spending, invoices, and licenses are centrally managed on AWS, making it easy to track budgets and ensure compliance. [Figure 3] Procurement page displaying detailed information about the solution package.\nCustomers can manage contracts for individual components separately while still benefiting from a single approval process:\n[Figure 4] Detailed pricing table for each component in the solution package.\n3. Benefits for the Partner Ecosystem This change opens up significant opportunities for AWS partners:\nISV (Independent Software Vendors): Can combine their software with professional deployment services in a single listing (Example: Okta combining software and deployment services). Channel Partners: Can combine their own services with ISV products they are authorized to resell (Example: SCC combining services with CrowdStrike products). System Integrators (SI): Can combine software and services from multiple partners to create complete solutions (Example: Accenture combining their services with Elastic). 4. Discovery Experience To support the \u0026ldquo;buy solutions\u0026rdquo; mindset, AWS Marketplace has also improved search capabilities with Generative AI. Customers can search based on Use Case or Industry instead of just product names, making it faster to find suitable solutions.\nConclusion The shift to Solution-centric procurement is AWS\u0026rsquo;s strategic move to reduce IT purchasing complexity. It helps enterprises move faster from \u0026ldquo;having a problem\u0026rdquo; to \u0026ldquo;having a solution,\u0026rdquo; eliminating the burden of having to assemble disparate technology pieces themselves.\nAuthors Tuan Vo\rTuan Vo is a Marketplace Specialist Solutions Architect who focuses on supporting sellers to list their products on AWS Marketplace. He supports large enterprises and public sector customers. Outside of work, Tuan enjoys traveling, trying out new food, and going on walks.\nAlex Hodges\rAlex Hodges is a Seattle-based product marketer for AWS Marketplace. Alex is passionate about launching new products and enjoys developing crisp messaging that customers can easily understand. In his free time, he enjoys backpacking, cycling, watching documentaries, and spending time with friends and family.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.04-configure-stacks/5.4.5-backend-stack/",
	"title": "5.4.5 Backend Stack",
	"tags": [],
	"description": "",
	"content": " Backend Stack - Application Layer Overview The Backend Stack is the Phase 4 application layer of the EveryoneCook infrastructure. It consolidates the API Gateway, Lambda functions, SQS queues, and WAF security into a unified backend architecture.\nDeployment Order: This stack MUST be deployed after Core Stack and Auth Stack.\n‚ö†Ô∏è Environment Note: This guide focuses on Development (dev) environment deployment. For staging/production deployments, see Environment Differences section.\nKey Responsibilities Create API Gateway REST API with custom domain Deploy 6 Lambda functions (API Router + 5 business modules) Configure 2 active SQS queues for async processing (AI, Image queues with DLQs) Deploy 2 worker Lambda functions for event processing (AI Worker, Image Worker) Setup WAF Web ACL for API Gateway protection Configure CloudWatch monitoring and alarms What\u0026rsquo;s Actually Running:\n8 Lambda Functions (6 business + 2 workers) 4 SQS Queues deployed (AI + Image queues with their DLQs) 1 WAF Web ACL with 5 security rules CloudWatch Logs and Alarms What This Stack Includes API Gateway (Dev Environment):\nCustom domain: api-dev.everyonecook.cloud ACM certificate for HTTPS (Regional - ap-southeast-1) Cognito authorizer for JWT validation Caching: Disabled (enabled only in production) Compression: Enabled (gzip/deflate for responses \u0026gt;1KB) Rate limiting: 10K req/sec, burst 5K Request validation: Body, parameters, headers Data trace logging: Enabled (disabled in production) Lambda Functions (6 functions - Dev Environment):\nAPI Router (everyonecook-dev-api-router): Routes requests to target Lambda functions Auth \u0026amp; User (everyonecook-dev-auth-user): Authentication, user profiles, privacy settings Social (everyonecook-dev-social): Posts, comments, reactions, friends, notifications Recipe \u0026amp; AI (everyonecook-dev-recipe-ai): Recipe CRUD, AI generation, search, trending Admin (everyonecook-dev-admin): Content moderation, user management, appeals Upload (everyonecook-dev-upload): S3 presigned URLs, file uploads Source Code: All functions located in services/ directory\nSQS Queues (2 active queues + 2 DLQs):\nAI Queue (everyonecook-dev-ai-queue): Bedrock AI recipe generation (2-minute timeout) ‚Üí AI Worker Image Queue (everyonecook-dev-image-queue): S3 image optimization (60-second timeout) ‚Üí Image Worker Note: Analytics and Notification queues are defined in code but NOT deployed. Notifications are handled directly in Social Module.\nWorker Lambda Functions (2 workers actively deployed):\nAI Worker (ai-module/workers/): Processes AI generation jobs from AI Queue using Bedrock Claude 3 Haiku Image Worker (image-worker/): Processes image optimization from Image Queue (resize, compress, watermark) WAF Web ACL:\nRate limiting: 2000 req/5min per IP SQL injection protection (AWS Managed) XSS protection (AWS Managed) Known bad inputs (AWS Managed) Request size limit: 10MB max Architecture ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ Backend Stack (Phase 4 - Dev Environment) ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ WAF Web ACL (REGIONAL) - API Gateway Protection ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Rate Limiting: 2000 req/5min per IP ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ SQL Injection Protection (AWS Managed) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ XSS Protection (AWS Managed) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Known Bad Inputs (AWS Managed) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Request Size Limit: 10MB max ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚ñº ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ API Gateway REST API ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Custom Domain: api.everyonecook.cloud ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ ACM Certificate (Regional - ap-southeast-1) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Cognito Authorizer (JWT validation) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Caching: 0.5GB, 5-min TTL (prod only) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Compression: gzip/deflate (\u0026gt;1KB) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Rate Limiting: 10K req/sec, burst 5K ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Request Validation: Body, params, headers ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚ñº ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ Lambda Function: API Router (512MB, 30s timeout) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ JWT Validation \u0026amp; User Context Extraction ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Request Routing to Target Lambda Functions ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Error Handling \u0026amp; Response Formatting ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚ñº ‚ñº ‚ñº ‚ñº ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ Auth \u0026amp; ‚îÇ ‚îÇ Social ‚îÇ ‚îÇ Recipe ‚îÇ ‚îÇ Admin ‚îÇ ‚îÇ\r‚îÇ ‚îÇ User ‚îÇ ‚îÇ Module ‚îÇ ‚îÇ \u0026amp; AI ‚îÇ ‚îÇ Module ‚îÇ ‚îÇ\r‚îÇ ‚îÇ Lambda ‚îÇ ‚îÇ Lambda ‚îÇ ‚îÇ Lambda ‚îÇ ‚îÇ Lambda ‚îÇ ‚îÇ\r‚îÇ ‚îÇ (512MB) ‚îÇ ‚îÇ (512MB) ‚îÇ ‚îÇ (512MB) ‚îÇ ‚îÇ (512MB) ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚ñº ‚ñº ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ SQS Queues + Worker Lambdas ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 1Ô∏è‚É£ AI Queue ‚Üí AI Worker (1024MB, 60s) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Bedrock Claude 3 Haiku (us-east-1) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Recipe generation from ingredients ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Visibility timeout: 2 minutes ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 2Ô∏è‚É£ Image Queue ‚Üí Image Worker (512MB, 60s) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ S3 image optimization ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Resize, compress, watermark ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Visibility timeout: 60 seconds ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ üìå Only 2 queues actively used (AI \u0026amp; Image) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ üìå Analytics \u0026amp; Notification queues exist but no workers ‚îÇ ‚îÇ\r‚îÇ ‚îÇ üìå All queues have DLQ (14-day retention) ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ Dependencies from Other Stacks: ‚îÇ\r‚îÇ ‚îú‚îÄ DynamoDB Table (Core Stack) ‚îÇ\r‚îÇ ‚îú‚îÄ S3 Content Bucket (Core Stack) ‚îÇ\r‚îÇ ‚îú‚îÄ CloudFront Distribution (Core Stack) ‚îÇ\r‚îÇ ‚îú‚îÄ Cognito User Pool (Auth Stack) ‚îÇ\r‚îÇ ‚îî‚îÄ Cognito User Pool Client (Auth Stack) ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Stack Configuration File Structure infrastructure/lib/stacks/\r‚îî‚îÄ‚îÄ backend-stack.ts # Backend Stack implementation (2965 lines)\r‚îú‚îÄ API Gateway configuration\r‚îú‚îÄ Lambda function definitions (6 functions)\r‚îú‚îÄ SQS queue configuration (4 queues + 4 DLQs)\r‚îú‚îÄ Worker Lambda definitions (2 active workers)\r‚îî‚îÄ WAF Web ACL configuration\rservices/ # Lambda function source code\r‚îú‚îÄ‚îÄ api-router/ # API Router Lambda\r‚îú‚îÄ‚îÄ auth-module/ # Auth \u0026amp; User Lambda\r‚îú‚îÄ‚îÄ social-module/ # Social Lambda\r‚îú‚îÄ‚îÄ recipe-module/ # Recipe \u0026amp; AI Lambda\r‚îú‚îÄ‚îÄ admin-module/ # Admin Lambda\r‚îú‚îÄ‚îÄ upload-module/ # Upload Lambda\r‚îú‚îÄ‚îÄ ai-module/ # AI Worker Lambda\r‚îÇ ‚îî‚îÄ‚îÄ workers/\r‚îú‚îÄ‚îÄ image-worker/ # Image Worker Lambda\r‚îú‚îÄ‚îÄ websocket-module/ # WebSocket (separate stack, not in Backend)\r‚îî‚îÄ‚îÄ shared/ # Shared utilities Code Implementation File: infrastructure/lib/stacks/backend-stack.ts\n1. Stack Interface \u0026amp; Constructor export interface BackendStackProps extends BaseStackProps { dynamoTable: cdk.aws_dynamodb.ITable; contentBucket: cdk.aws_s3.IBucket; distribution: cdk.aws_cloudfront.IDistribution; userPool: cdk.aws_cognito.IUserPool; userPoolClient: cdk.aws_cognito.IUserPoolClient; } export class BackendStack extends BaseStack { // Lambda Layer public readonly sharedLayer: SharedDependenciesLayer; // API Gateway public readonly api: cdk.aws_apigateway.RestApi; public readonly cognitoAuthorizer: cdk.aws_apigateway.CognitoUserPoolsAuthorizer; public readonly apiDomainName: cdk.aws_apigateway.DomainName; // Request Validators public readonly bodyValidator: cdk.aws_apigateway.RequestValidator; public readonly paramsValidator: cdk.aws_apigateway.RequestValidator; public readonly fullValidator: cdk.aws_apigateway.RequestValidator; // Lambda Functions (6 business functions) public readonly apiRouterFunction: cdk.aws_lambda.Function; // services/api-router public readonly authUserFunction: cdk.aws_lambda.Function; // services/auth-module public readonly socialFunction: cdk.aws_lambda.Function; // services/social-module public readonly recipeAIFunction: cdk.aws_lambda.Function; // services/recipe-module public readonly adminFunction: cdk.aws_lambda.Function; // services/admin-module public readonly uploadFunction: cdk.aws_lambda.Function; // services/upload-module // SQS Queues (4 queues + 4 DLQs) public readonly aiQueue: cdk.aws_sqs.Queue; public readonly imageProcessingQueue: cdk.aws_sqs.Queue; public readonly analyticsQueue: cdk.aws_sqs.Queue; public readonly notificationQueue: cdk.aws_sqs.Queue; // Worker Lambdas (2 active workers) public readonly aiWorker: cdk.aws_lambda.Function; // services/ai-module/workers public readonly imageWorker?: cdk.aws_lambda.Function; // services/image-worker // Note: analyticsWorker \u0026amp; notificationWorker exist in code but NOT deployed // public readonly analyticsWorker?: cdk.aws_lambda.Function; // Commented out // public readonly notificationWorker?: cdk.aws_lambda.Function; // Not created // WAF WebACL public readonly apiGatewayWebAcl?: cdk.aws_wafv2.CfnWebACL; constructor(scope: Construct, id: string, props: BackendStackProps) { super(scope, id, props); // Add stack-specific tags cdk.Tags.of(this).add(\u0026#39;StackType\u0026#39;, \u0026#39;Backend\u0026#39;); cdk.Tags.of(this).add(\u0026#39;Layer\u0026#39;, \u0026#39;Application\u0026#39;); cdk.Tags.of(this).add(\u0026#39;CostCenter\u0026#39;, `Backend-${this.config.environment}`); // Create resources (see implementation below) // 1. Shared Dependencies Layer // 2. SQS Queues and DLQs // 3. API Gateway // 4. Lambda Functions // 5. Worker Lambdas // 6. WAF Web ACL // 7. Export outputs } } 2. API Gateway Configuration private createAPIGateway(): cdk.aws_apigateway.RestApi { const cachingEnabled = this.config.apiGateway.caching.enabled; const compressionEnabled = this.config.apiGateway.compression; const api = new cdk.aws_apigateway.RestApi(this, \u0026#39;EveryoneCookAPI\u0026#39;, { restApiName: `EveryoneCook-API-${this.config.environment}`, description: `Everyone Cook REST API - ${this.config.environment}`, // Compression for responses \u0026gt;1KB minCompressionSize: compressionEnabled ? cdk.Size.kibibytes(1) : undefined, deployOptions: { stageName: \u0026#39;api\u0026#39;, // Caching configuration (production only) cachingEnabled: cachingEnabled, cacheClusterEnabled: cachingEnabled, cacheClusterSize: cachingEnabled ? this.config.apiGateway.caching.cacheSize : undefined, cacheTtl: cachingEnabled ? cdk.Duration.seconds(this.config.apiGateway.caching.ttl) : undefined, cacheDataEncrypted: cachingEnabled, // Throttling settings throttlingRateLimit: this.config.apiGateway.throttling.rateLimit, throttlingBurstLimit: this.config.apiGateway.throttling.burstLimit, // X-Ray Tracing - Disabled (CloudWatch Logs sufficient) tracingEnabled: false, // Logging configuration loggingLevel: cdk.aws_apigateway.MethodLoggingLevel.INFO, dataTraceEnabled: this.config.environment !== \u0026#39;prod\u0026#39;, metricsEnabled: true, // Access logging accessLogDestination: new cdk.aws_apigateway.LogGroupLogDestination( new cdk.aws_logs.LogGroup(this, \u0026#39;APIGatewayAccessLogs\u0026#39;, { logGroupName: `/aws/apigateway/everyonecook-${this.config.environment}`, retention: this.config.cloudwatch.logRetentionDays, }) ), }, // CORS configuration defaultCorsPreflightOptions: { allowOrigins: [ `https://${this.config.domains.frontend}`, `https://www.${this.config.domains.frontend}`, ...(this.config.environment !== \u0026#39;prod\u0026#39; ? [\u0026#39;http://localhost:3000\u0026#39;] : []), ], allowMethods: [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;, \u0026#39;PUT\u0026#39;, \u0026#39;DELETE\u0026#39;, \u0026#39;PATCH\u0026#39;, \u0026#39;OPTIONS\u0026#39;], allowHeaders: [ \u0026#39;Content-Type\u0026#39;, \u0026#39;Authorization\u0026#39;, \u0026#39;X-Amz-Date\u0026#39;, \u0026#39;X-Api-Key\u0026#39;, \u0026#39;X-Amz-Security-Token\u0026#39;, \u0026#39;X-Correlation-Id\u0026#39;, \u0026#39;Cache-Control\u0026#39;, \u0026#39;Accept-Encoding\u0026#39;, ], allowCredentials: false, maxAge: cdk.Duration.hours(1), }, // Endpoint configuration endpointConfiguration: { types: [cdk.aws_apigateway.EndpointType.REGIONAL], }, // Binary media types binaryMediaTypes: [\u0026#39;image/*\u0026#39;, \u0026#39;application/octet-stream\u0026#39;], }); // Add Gateway Responses with CORS headers const corsHeaders = { \u0026#39;gatewayresponse.header.Access-Control-Allow-Origin\u0026#39;: \u0026#34;\u0026#39;*\u0026#39;\u0026#34;, \u0026#39;gatewayresponse.header.Access-Control-Allow-Headers\u0026#39;: \u0026#34;\u0026#39;Content-Type,Authorization,...\u0026#39;\u0026#34;, \u0026#39;gatewayresponse.header.Access-Control-Allow-Methods\u0026#39;: \u0026#34;\u0026#39;GET,POST,PUT,DELETE,PATCH,OPTIONS\u0026#39;\u0026#34;, }; api.addGatewayResponse(\u0026#39;Unauthorized\u0026#39;, { type: cdk.aws_apigateway.ResponseType.UNAUTHORIZED, statusCode: \u0026#39;401\u0026#39;, responseHeaders: corsHeaders, }); return api; } 3. SQS Queue Configuration private createAIQueue(): cdk.aws_sqs.Queue { const queue = new cdk.aws_sqs.Queue(this, \u0026#39;AIQueue\u0026#39;, { queueName: `everyonecook-${this.config.environment}-ai-queue`, visibilityTimeout: cdk.Duration.seconds(120), // 2 minutes for AI processing retentionPeriod: cdk.Duration.days(4), deadLetterQueue: { queue: this.aiDLQ, maxReceiveCount: 3, }, encryption: cdk.aws_sqs.QueueEncryption.KMS_MANAGED, }); // CloudWatch alarm for queue depth if (this.config.cloudwatch.alarms.enabled) { new cdk.aws_cloudwatch.Alarm(this, \u0026#39;AIQueueDepthAlarm\u0026#39;, { alarmName: `EveryoneCook-${this.config.environment}-AI-Queue-Depth`, metric: queue.metricApproximateNumberOfMessagesVisible(), threshold: 100, evaluationPeriods: 2, }); } return queue; } 4. Lambda Function Configuration private createAuthUserLambda(props: BackendStackProps): cdk.aws_lambda.Function { const logGroup = new cdk.aws_logs.LogGroup(this, \u0026#39;AuthUserLogGroup\u0026#39;, { logGroupName: `/aws/lambda/everyonecook-${this.config.environment}-auth-user`, retention: this.config.cloudwatch.logRetentionDays, }); const authUserFunction = new cdk.aws_lambda.Function(this, \u0026#39;AuthUserFunction\u0026#39;, { functionName: `everyonecook-${this.config.environment}-auth-user`, runtime: cdk.aws_lambda.Runtime.NODEJS_20_X, handler: \u0026#39;services/auth-module/index.handler\u0026#39;, code: this.createLambdaCode(\u0026#39;services/auth-module/deployment\u0026#39;), layers: [this.sharedLayer.layer], memorySize: 512, timeout: cdk.Duration.seconds(30), tracing: cdk.aws_lambda.Tracing.DISABLED, environment: { DYNAMODB_TABLE: props.dynamoTable.tableName, USER_POOL_ID: props.userPool.userPoolId, USER_POOL_CLIENT_ID: props.userPoolClient.userPoolClientId, CONTENT_BUCKET: props.contentBucket.bucketName, LOG_LEVEL: this.config.environment === \u0026#39;prod\u0026#39; ? \u0026#39;INFO\u0026#39; : \u0026#39;DEBUG\u0026#39;, }, logGroup: logGroup, }); // Grant permissions props.dynamoTable.grantReadWriteData(authUserFunction); props.contentBucket.grantReadWrite(authUserFunction); props.userPool.grant(authUserFunction, \u0026#39;cognito-idp:AdminGetUser\u0026#39;, \u0026#39;cognito-idp:ListUsers\u0026#39;); return authUserFunction; } 5. WAF Web ACL Configuration private createApiGatewayWebAcl(): cdk.aws_wafv2.CfnWebACL { const webAcl = new cdk.aws_wafv2.CfnWebACL(this, \u0026#39;ApiGatewayWebACL\u0026#39;, { name: `EveryoneCook-API-WAF-${this.config.environment}`, scope: \u0026#39;REGIONAL\u0026#39;, defaultAction: { allow: {} }, visibilityConfig: { sampledRequestsEnabled: true, cloudWatchMetricsEnabled: true, metricName: `EveryoneCook-API-WAF-${this.config.environment}`, }, rules: [ // Rule 1: Rate Limiting { name: \u0026#39;RateLimitRule\u0026#39;, priority: 0, statement: { rateBasedStatement: { limit: 2000, // 2000 requests per 5 minutes aggregateKeyType: \u0026#39;IP\u0026#39;, }, }, action: { block: {} }, visibilityConfig: { sampledRequestsEnabled: true, cloudWatchMetricsEnabled: true, metricName: \u0026#39;RateLimitRule\u0026#39;, }, }, // Rule 2-5: AWS Managed Rules (SQL injection, XSS, etc.) // ... see full implementation ], }); return webAcl; } Key Configuration Details 1. Shared Dependencies Layer The Backend Stack uses a Lambda Layer to share common dependencies across all Lambda functions:\n// Create Shared Dependencies Layer this.sharedLayer = new SharedDependenciesLayer(this, \u0026#39;SharedDependenciesLayer\u0026#39;); // Benefits: // - 90% reduction in deployment size (8MB ‚Üí 200KB per Lambda) // - Faster deployments // - Consistent dependency versions // - Lower storage costs // Dependencies included: // - AWS SDK v3 clients (DynamoDB, Lambda, Cognito, S3, SQS, Bedrock) // - uuid, jsonwebtoken, jwks-rsa 2. API Gateway Custom Domain The stack creates a custom domain for API Gateway with ACM certificate:\n// Custom domain configuration const domainName = this.config.domains.api; // api.everyonecook.cloud // Create ACM certificate in ap-southeast-1 (Regional endpoint) const certificate = new acm.Certificate(this, \u0026#39;ApiGatewayCertificate\u0026#39;, { domainName: \u0026#39;*.everyonecook.cloud\u0026#39;, validation: acm.CertificateValidation.fromDns(hostedZone), }); // Create API Gateway DomainName const apiDomainName = new cdk.aws_apigateway.DomainName(this, \u0026#39;ApiDomain\u0026#39;, { domainName: this.config.domains.api, certificate: certificate, endpointType: cdk.aws_apigateway.EndpointType.REGIONAL, securityPolicy: cdk.aws_apigateway.SecurityPolicy.TLS_1_2, }); // Create Route 53 A record (Alias) new cdk.aws_route53.ARecord(this, \u0026#39;ApiAliasRecord\u0026#39;, { zone: hostedZone, recordName: this.config.domains.api, target: cdk.aws_route53.RecordTarget.fromAlias( new cdk.aws_route53_targets.ApiGatewayDomain(apiDomainName) ), }); Environments:\nDev: api-dev.everyonecook.cloud Staging: api-staging.everyonecook.cloud Prod: api.everyonecook.cloud 3. Request Validation The stack implements three levels of request validation:\n// 1. Body Validator - Validate request body only this.bodyValidator = new cdk.aws_apigateway.RequestValidator(this, \u0026#39;BodyValidator\u0026#39;, { restApi: api, validateRequestBody: true, validateRequestParameters: false, }); // 2. Params Validator - Validate query strings and headers only this.paramsValidator = new cdk.aws_apigateway.RequestValidator(this, \u0026#39;ParamsValidator\u0026#39;, { restApi: api, validateRequestBody: false, validateRequestParameters: true, }); // 3. Full Validator - Validate both body and parameters this.fullValidator = new cdk.aws_apigateway.RequestValidator(this, \u0026#39;FullValidator\u0026#39;, { restApi: api, validateRequestBody: true, validateRequestParameters: true, }); // Benefits: // - Early rejection of invalid requests (before Lambda invocation) // - Cost optimization: No Lambda charges for invalid requests // - Security: Prevents malformed requests // - Performance: Faster error responses 4. Resource Naming Convention All resources follow a consistent naming pattern:\n// Lambda function format: everyonecook-{env}-{function} functionName: `everyonecook-${this.config.environment}-auth-user` // SQS queue format: everyonecook-{env}-{queue} queueName: `everyonecook-${this.config.environment}-ai-queue` // API Gateway format: EveryoneCook-API-{env} restApiName: `EveryoneCook-API-${this.config.environment}` // WAF format: EveryoneCook-API-WAF-{env} name: `EveryoneCook-API-WAF-${this.config.environment}` Example:\nStack name: EveryoneCook-dev-Backend API: EveryoneCook-API-dev Lambda: everyonecook-dev-auth-user Queue: everyonecook-dev-ai-queue 5. Resource Tags Every resource is tagged for cost tracking and management:\n{ Stack: \u0026#39;EveryoneCook-dev-Backend\u0026#39;, Environment: \u0026#39;dev\u0026#39;, StackType: \u0026#39;Backend\u0026#39;, Layer: \u0026#39;Application\u0026#39;, CostCenter: \u0026#39;Backend-dev\u0026#39;, Component: \u0026#39;API\u0026#39; | \u0026#39;EventProcessing\u0026#39; | \u0026#39;Security\u0026#39;, Module: \u0026#39;AuthUser\u0026#39; | \u0026#39;Social\u0026#39; | \u0026#39;RecipeAI\u0026#39; | \u0026#39;Admin\u0026#39; | \u0026#39;Upload\u0026#39;, Purpose: \u0026#39;REST-API\u0026#39; | \u0026#39;RequestRouting\u0026#39; | \u0026#39;AI-Processing\u0026#39;, Project: \u0026#39;EveryoneCook\u0026#39; } Stack Outputs After deployment, the stack exports the following values:\nOutput Name Value Usage ApiUrl https://api.everyonecook.cloud Frontend API endpoint ApiId abc123xyz API Gateway REST API ID ApiStage api API Gateway stage name ApiDomainName api.everyonecook.cloud Custom domain name AIQueueUrl https://sqs.ap-southeast-1... AI Queue URL for sending messages ImageQueueUrl https://sqs.ap-southeast-1... Image Queue URL WafWebAclArn arn:aws:wafv2:... WAF Web ACL ARN Deployment Steps Step 1: Review Configuration Navigate to the infrastructure directory:\ncd D:\\Project_AWS\\everyonecook\\infrastructure Verify the Development environment configuration in config/environment.ts:\ndev: { environment: \u0026#39;dev\u0026#39;, account: \u0026#39;YOUR_AWS_ACCOUNT_ID\u0026#39;, region: \u0026#39;ap-southeast-1\u0026#39;, domains: { frontend: \u0026#39;dev.everyonecook.cloud\u0026#39;, api: \u0026#39;api-dev.everyonecook.cloud\u0026#39;, cdn: \u0026#39;cdn-dev.everyonecook.cloud\u0026#39;, }, apiGateway: { caching: { enabled: false, // Disabled in dev (enabled in prod) cacheSize: \u0026#39;0.5\u0026#39;, // 0.5GB cache (prod only) ttl: 300, // 5 minutes (prod only) }, compression: true, // Enabled in all environments throttling: { rateLimit: 10000, burstLimit: 5000, }, }, cloudwatch: { logRetentionDays: 7, // Dev: 7 days, Staging: 30 days, Prod: 90 days alarms: { enabled: true, }, }, // ... other configs } For Staging/Production: Update the --context environment= parameter in deployment commands.\nStep 2: Prepare Lambda Deployment Packages Before deploying, prepare the Lambda deployment packages for 8 Lambda functions + 1 Layer:\n# 1. Prepare Shared Layer FIRST (required by all Lambdas) cd D:\\Project_AWS\\everyonecook\\layers\\shared-dependencies .\\prepare-layer.ps1 # 2. Prepare Business Lambda Functions (6 functions) cd D:\\Project_AWS\\everyonecook\\services\\api-router .\\prepare-deployment-layer.ps1 # or prepare-deployment.ps1 cd D:\\Project_AWS\\everyonecook\\services\\auth-module .\\prepare-deployment-layer.ps1 cd D:\\Project_AWS\\everyonecook\\services\\social-module .\\prepare-deployment-layer.ps1 cd D:\\Project_AWS\\everyonecook\\services\\recipe-module .\\prepare-deployment-layer.ps1 cd D:\\Project_AWS\\everyonecook\\services\\admin-module .\\prepare-deployment-layer.ps1 cd D:\\Project_AWS\\everyonecook\\services\\upload-module .\\prepare-deployment-layer.ps1 # 3. Prepare Worker Lambda Functions (2 workers) cd D:\\Project_AWS\\everyonecook\\services\\ai-module .\\prepare-deployment.ps1 # AI Worker uses prepare-deployment.ps1 cd D:\\Project_AWS\\everyonecook\\services\\image-worker .\\prepare-deployment-layer.ps1 Important Notes:\nEach service must have a deployment/ folder after running prepare script Shared Layer must be built FIRST as all Lambdas depend on it Check for prepare-deployment.ps1 or prepare-deployment-layer.ps1 in each service folder Total deployment size: ~8MB ‚Üí ~200KB per Lambda (thanks to Shared Layer) Step 3: Synthesize CloudFormation Template Generate the CloudFormation template to review changes:\n# Return to infrastructure directory cd D:\\Project_AWS\\everyonecook\\infrastructure # Synthesize template npx cdk synth EveryoneCook-dev-Backend --context environment=dev Expected output shows the CloudFormation template with all resources.\nStep 4: Deploy Backend Stack Deploy the Backend stack to AWS:\n# Deploy Backend Stack only npx cdk deploy EveryoneCook-dev-Backend --context environment=dev # Or deploy with approval npx cdk deploy EveryoneCook-dev-Backend --context environment=dev --require-approval never Expected output:\n‚ú® Synthesis time: 5.23s\rEveryoneCook-dev-Backend: deploying...\r[0%] start: Publishing abc123:current_account-current_region\r[33%] success: Published abc123:current_account-current_region\r[33%] start: Publishing def456:current_account-current_region\r[66%] success: Published def456:current_account-current_region\r[66%] start: Publishing EveryoneCook-dev-Backend\r[100%] success: Published EveryoneCook-dev-Backend\rEveryoneCook-dev-Backend: creating CloudFormation changeset...\rEveryoneCook-dev-Backend\r‚ú® Deployment time: 420.15s\rOutputs:\rEveryoneCook-dev-Backend.ApiUrl = https://api-dev.everyonecook.cloud\rEveryoneCook-dev-Backend.ApiId = abc123xyz\rEveryoneCook-dev-Backend.ApiStage = api\rEveryoneCook-dev-Backend.ApiDomainName = api-dev.everyonecook.cloud\rEveryoneCook-dev-Backend.AIQueueUrl = https://sqs.ap-southeast-1.amazonaws.com/123456789/everyonecook-dev-ai-queue\rEveryoneCook-dev-Backend.ImageQueueUrl = https://sqs.ap-southeast-1.amazonaws.com/123456789/everyonecook-dev-image-queue\rEveryoneCook-dev-Backend.WafWebAclArn = arn:aws:wafv2:ap-southeast-1:123456789:regional/webacl/EveryoneCook-API-WAF-dev/...\rStack ARN:\rarn:aws:cloudformation:ap-southeast-1:123456789:stack/EveryoneCook-dev-Backend/...\r‚ú® Total time: 425.38s Deployment time: ~7 minutes (includes certificate validation)\nStep 5: Verify Deployment on AWS Console 5.1: Verify API Gateway Navigate to API Gateway Console Select region: ap-southeast-1 Click on EveryoneCook-API-dev API Gateway dashboard showing API name, stage, custom domain, caching status and throttling settings\nClick on Stages ‚Üí api Verify stage settings: Cache Settings: Enabled (prod) / Disabled (dev) Cache capacity: 0.5 GB (prod only) Default TTL: 300 seconds (prod only) Throttling: 10000 requests/sec Burst: 5000 requests/sec Stage settings showing caching and throttling configuration\nClick on Custom domain names Verify custom domain: Domain name: api-dev.everyonecook.cloud Certificate: ACM certificate (Regional) Base path mapping: / ‚Üí api stage Custom domain configuration with ACM certificate\n5.2: Verify Lambda Functions Navigate to Lambda Console Select region: ap-southeast-1 Verify all 8 Lambda functions exist: Function Name Runtime Memory Timeout Layer Source Code everyonecook-dev-api-router Node 20.x 512MB 30s SharedDependenciesLayer services/api-router everyonecook-dev-auth-user Node 20.x 512MB 30s SharedDependenciesLayer services/auth-module everyonecook-dev-social Node 20.x 512MB 30s SharedDependenciesLayer services/social-module everyonecook-dev-recipe-ai Node 20.x 512MB 30s SharedDependenciesLayer services/recipe-module everyonecook-dev-admin Node 20.x 512MB 30s SharedDependenciesLayer services/admin-module everyonecook-dev-upload Node 20.x 512MB 30s SharedDependenciesLayer services/upload-module everyonecook-dev-ai-worker Node 20.x 1024MB 60s SharedDependenciesLayer services/ai-module/workers everyonecook-dev-image-worker Node 20.x 512MB 60s SharedDependenciesLayer services/image-worker Lambda functions list showing all 8 functions with runtime and configuration\nClick on everyonecook-dev-api-router Verify configuration: Environment variables: DYNAMODB_TABLE, USER_POOL_ID, etc. Layers: SharedDependenciesLayer Triggers: API Gateway (Proxy integration) API Router function showing environment variables, layers, and API Gateway trigger\nClick on Monitoring tab Verify CloudWatch Logs integration: Log group: /aws/lambda/everyonecook-dev-api-router Retention: Based on environment config Lambda monitoring dashboard showing CloudWatch Logs and metrics\n5.3: Verify SQS Queues Navigate to SQS Console Select region: ap-southeast-1 Verify 4 active queues exist (2 main + 2 DLQs): Note: Only AI and Image queues are actively used. Analytics and Notification queues exist in code but are not deployed.\nQueue Name Type Visibility Timeout Retention DLQ Worker Status everyonecook-dev-ai-queue Main 2 minutes 4 days everyonecook-dev-ai-dlq Active everyonecook-dev-ai-dlq DLQ 5 minutes 14 days - - everyonecook-dev-image-queue Main 60 seconds 4 days everyonecook-dev-image-dlq Active everyonecook-dev-image-dlq DLQ 5 minutes 14 days - - SQS queues list showing 4 active queues: ai-queue, ai-dlq, image-queue, image-dlq\nClick on everyonecook-dev-ai-queue Verify queue configuration: Visibility timeout: 2 minutes Message retention: 4 days Dead-letter queue: everyonecook-dev-ai-dlq Maximum receives: 3 Encryption: KMS managed AI Queue configuration showing visibility timeout, retention, DLQ, and encryption settings\nClick on Lambda triggers tab Verify Lambda trigger: Function: everyonecook-dev-ai-worker Batch size: 1 Batch window: 0 seconds AI Queue Lambda trigger showing ai-worker function with batch configuration\n5.4: Verify WAF Web ACL Navigate to WAF \u0026amp; Shield Console Select region: ap-southeast-1 (Regional) Click on Web ACLs Click on EveryoneCook-API-WAF-dev WAF Web ACL dashboard for EveryoneCook API protection\nClick on Rules tab Verify all 5 rules exist: Priority Rule Name Type Action Status 0 RateLimitRule Rate-based Block Enabled 1 AWSManagedRulesSQLi Managed Block Enabled 2 AWSManagedRulesKnownBadInputs Managed Block Enabled 3 AWSManagedRulesCoreRuleSet Managed Block Enabled 4 RequestSizeLimit Size constraint Block Enabled 5.5: Verify CloudWatch Alarms Navigate to CloudWatch Console Select region: ap-southeast-1 Filter by: EveryoneCook-dev-Backend CloudWatch alarms for Backend Stack: Queue depth, Lambda errors/duration, WAF blocks\n5.6: Verify Route 53 DNS Record Navigate to Route 53 Console Click on Hosted zones Click on everyonecook.cloud Verify A record exists: Name: api-dev.everyonecook.cloud Type: A (Alias) Target: API Gateway domain name Routing policy: Simple Route 53 A record (Alias) pointing to API Gateway custom domain\nStep 6: Test API Endpoint Test the custom domain endpoint:\n# Test API Gateway health endpoint (if exists) curl https://api-dev.everyonecook.cloud/health # Or test with browser start https://api-dev.everyonecook.cloud Expected response (if health endpoint exists):\n{ \u0026#34;status\u0026#34;: \u0026#34;healthy\u0026#34;, \u0026#34;environment\u0026#34;: \u0026#34;dev\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-01-15T10:30:00Z\u0026#34; } Environment Differences This guide uses Development (dev) environment as the example. Here are the key differences across environments:\nDomain Names Environment API Domain Frontend Domain Dev api-dev.everyonecook.cloud dev.everyonecook.cloud Staging api-staging.everyonecook.cloud staging.everyonecook.cloud Prod api.everyonecook.cloud everyonecook.cloud Resource Naming Resource Type Dev Staging Prod Stack Name EveryoneCook-dev-Backend EveryoneCook-staging-Backend EveryoneCook-prod-Backend API Gateway EveryoneCook-API-dev EveryoneCook-API-staging EveryoneCook-API-prod Lambda everyonecook-dev-auth-user everyonecook-staging-auth-user everyonecook-prod-auth-user SQS Queue everyonecook-dev-ai-queue everyonecook-staging-ai-queue everyonecook-prod-ai-queue WAF EveryoneCook-API-WAF-dev EveryoneCook-API-WAF-staging EveryoneCook-API-WAF-prod Configuration Differences Setting Dev Staging Production API Caching Disabled Disabled Enabled (0.5GB) Data Trace Logging Enabled Enabled Disabled Log Retention 7 days 30 days 90 days CloudWatch Removal DESTROY DESTROY RETAIN WAF Rate Limit 2000 req/5min 2000 req/5min 5000 req/5min Lambda Log Level DEBUG INFO INFO CORS Localhost Allowed Not allowed Not allowed Deployment Commands # Development npx cdk deploy EveryoneCook-dev-Backend --context environment=dev # Staging npx cdk deploy EveryoneCook-staging-Backend --context environment=staging # Production (requires approval) npx cdk deploy EveryoneCook-prod-Backend --context environment=prod --require-approval broadening Environment-Specific Considerations Development CORS allows http://localhost:3000 for local frontend testing Data trace logging enabled for debugging Lower log retention (7 days) to reduce costs Resources deleted on stack removal (RemovalPolicy.DESTROY) Staging Production-like configuration for pre-release testing Separate domain to avoid production interference Same security rules as production Resources deleted on stack removal Production API Gateway caching enabled (0.5GB, 5-min TTL) Data trace logging disabled (cost optimization) 90-day log retention for compliance Resources retained on stack removal (RemovalPolicy.RETAIN) Stricter WAF rate limits No localhost CORS Cost Analysis Monthly Cost Breakdown (Dev Environment) Service Configuration Monthly Cost API Gateway 1M requests, caching disabled ~$3.50 Lambda (6 functions) 512MB, 1M invocations, 200ms avg ~$8.40 Lambda (2 workers) 512-1024MB, 10K invocations ~$0.42 SQS (2 queues) 10K messages/month ~$0.03 WAF Web ACL 1 ACL + 5 rules + 1M requests ~$10.60 CloudWatch Logs 5GB ingestion, 30-day retention ~$2.50 CloudWatch Alarms 10 alarms ~$1.00 Total Backend Stack ~$26.45/month Production Cost Estimate Service Configuration Monthly Cost API Gateway 10M requests, caching enabled (0.5GB) ~$50.00 Lambda (6 functions) 512MB, 10M invocations, 200ms avg ~$84.00 Lambda (2 workers) 512-1024MB, 100K invocations ~$4.20 SQS (2 queues) 100K messages/month ~$0.25 WAF Web ACL 1 ACL + 5 rules + 10M requests ~$16.00 CloudWatch Logs 20GB ingestion, 90-day retention ~$10.00 CloudWatch Alarms 15 alarms ~$1.50 Total Backend Stack ~$165.95/month Next Steps After deploying the Backend Stack:\nDeploy Frontend Stack (Phase 5) - Next.js application on CloudFront Deploy Observability Stack (Phase 6) - CloudWatch dashboards and alarms Test API Integration - Verify all endpoints work correctly Load Testing - Test performance and scaling Security Audit - Review WAF rules and access controls References Infrastructure Code Backend Stack: infrastructure/lib/stacks/backend-stack.ts (2965 lines) Shared Layer Construct: infrastructure/lib/constructs/shared-layer.ts Lambda Function Source Code (6 Business Functions) API Router: services/api-router/ - Request routing \u0026amp; JWT validation Auth User Module: services/auth-module/ - Authentication \u0026amp; user profiles Social Module: services/social-module/ - Posts, comments, friends, notifications Recipe AI Module: services/recipe-module/ - Recipe CRUD, AI generation, search Admin Module: services/admin-module/ - Content moderation, user management Upload Module: services/upload-module/ - S3 presigned URLs, file uploads Worker Lambda Source Code (2 Active Workers) AI Worker: services/ai-module/workers/ - Bedrock Claude 3 Haiku integration Image Worker: services/image-worker/ - Image optimization (resize, compress) Shared Dependencies Shared Layer: layers/shared-dependencies/ - AWS SDK v3, uuid, jsonwebtoken, jwks-rsa Other Services (Not in Backend Stack) WebSocket Module: services/websocket-module/ - Real-time communication (separate stack) Shared Utilities: services/shared/ - Common utilities across services Summary The Backend Stack is the largest and most complex stack in the EveryoneCook infrastructure. It consolidates:\nAPI Gateway with custom domain (caching in prod only) 6 Lambda functions for business logic 2 active SQS queues for async processing (4 total with DLQs) 2 worker Lambda functions (AI Worker, Image Worker) WAF Web ACL for security (5 protection rules) CloudWatch monitoring and alarms Actually Deployed: 8 Lambda functions, 4 SQS queues (2 active with workers), 1 WAF Web ACL, CloudWatch alarms\nDevelopment Environment Checklist Prepare all Lambda deployment packages (8 functions + 1 layer) Review dev environment configuration Verify caching is disabled (prod only) Test each Lambda function independently Monitor CloudWatch alarms Verify WAF rules don\u0026rsquo;t block legitimate traffic Test localhost CORS (dev only) For Staging/Production Deployment Review Environment Differences Enable API Gateway caching (prod only) Disable data trace logging (prod only) Set appropriate log retention (90 days for prod) Update WAF rate limits (higher for prod) Remove localhost from CORS Use --require-approval broadening for production Deployment Order: DNS ‚Üí Certificate ‚Üí Core ‚Üí Auth ‚Üí Backend ‚Üí Frontend ‚Üí Observability\nEnvironments: This guide demonstrates dev deployment. Repeat for staging and prod with appropriate configurations.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.06-configure-api-lambda/",
	"title": "Configure API &amp; Lambda",
	"tags": [],
	"description": "",
	"content": "Overview Sau khi deploy infrastructure, b·∫°n c·∫ßn c·∫•u h√¨nh API Gateway routes v√† Lambda functions ƒë·ªÉ x·ª≠ l√Ω business logic.\nAPI Architecture API Gateway (api.everyonecook.cloud)\r‚Üì\rAPI Router Lambda (entry point)\r‚Üì\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ Auth ‚îÇ Social ‚îÇ Recipe ‚îÇ Admin ‚îÇ Upload ‚îÇ\r‚îÇ Module ‚îÇ Module ‚îÇ AI ‚îÇ Module ‚îÇ Module ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚Üì ‚Üì ‚Üì ‚Üì ‚Üì\rDynamoDB DynamoDB Bedrock DynamoDB S3 Step 1: Review API Routes API Router Structure:\n// services/api-router/routes/index.ts export const routes = { // Auth routes \u0026#39;POST /auth/register\u0026#39;: \u0026#39;auth-module\u0026#39;, \u0026#39;POST /auth/login\u0026#39;: \u0026#39;auth-module\u0026#39;, \u0026#39;GET /auth/profile\u0026#39;: \u0026#39;auth-module\u0026#39;, \u0026#39;PUT /auth/profile\u0026#39;: \u0026#39;auth-module\u0026#39;, // Social routes \u0026#39;GET /social/posts\u0026#39;: \u0026#39;social-module\u0026#39;, \u0026#39;POST /social/posts\u0026#39;: \u0026#39;social-module\u0026#39;, \u0026#39;GET /social/posts/:id\u0026#39;: \u0026#39;social-module\u0026#39;, \u0026#39;POST /social/posts/:id/like\u0026#39;: \u0026#39;social-module\u0026#39;, // Recipe routes \u0026#39;GET /recipes\u0026#39;: \u0026#39;recipe-module\u0026#39;, \u0026#39;POST /recipes\u0026#39;: \u0026#39;recipe-module\u0026#39;, \u0026#39;POST /ai/generate-recipe\u0026#39;: \u0026#39;recipe-module\u0026#39;, \u0026#39;POST /ai/search\u0026#39;: \u0026#39;recipe-module\u0026#39;, // Admin routes \u0026#39;GET /admin/users\u0026#39;: \u0026#39;admin-module\u0026#39;, \u0026#39;POST /admin/users/:id/ban\u0026#39;: \u0026#39;admin-module\u0026#39;, // Upload routes \u0026#39;POST /upload/presigned-url\u0026#39;: \u0026#39;upload-module\u0026#39;, \u0026#39;POST /upload/complete\u0026#39;: \u0026#39;upload-module\u0026#39; }; Step 2: Configure Lambda Modules 1. Auth Module\ncd services/auth-module # Review configuration cat package.json cat tsconfig.json # Check environment variables needed cat index.ts | grep process.env Environment Variables:\nTABLE_NAME: DynamoDB table name USER_POOL_ID: Cognito User Pool ID REGION: AWS region 2. Social Module\ncd services/social-module # Review handlers ls handlers/ # - posts.handler.ts # - comments.handler.ts # - reactions.handler.ts # - friends.handler.ts 3. Recipe/AI Module\ncd services/recipe-module # Check AI configuration cat services/ai.service.ts Environment Variables:\nBEDROCK_MODEL_ID: Claude 3.5 Sonnet v2 BEDROCK_REGION: us-east-1 OPENSEARCH_ENDPOINT: OpenSearch domain (if enabled) 4. Admin Module\ncd services/admin-module # Review admin operations ls handlers/ 5. Upload Module\ncd services/upload-module # Check S3 configuration cat services/s3.service.ts Environment Variables:\nCONTENT_BUCKET: S3 content bucket name CLOUDFRONT_DOMAIN: CloudFront domain CLOUDFRONT_KEY_PAIR_ID: For signed URLs Step 3: Configure Lambda Layers Shared Dependencies:\ncd services/shared # Review shared code ls -la # - repositories/ # - business-logic/ # - utils/ # - types/ Lambda Layer Structure:\nshared/\r‚îú‚îÄ‚îÄ repositories/\r‚îÇ ‚îú‚îÄ‚îÄ user.repository.ts\r‚îÇ ‚îú‚îÄ‚îÄ post.repository.ts\r‚îÇ ‚îî‚îÄ‚îÄ recipe.repository.ts\r‚îú‚îÄ‚îÄ business-logic/\r‚îÇ ‚îú‚îÄ‚îÄ auth.logic.ts\r‚îÇ ‚îî‚îÄ‚îÄ validation.logic.ts\r‚îî‚îÄ‚îÄ utils/\r‚îú‚îÄ‚îÄ dynamodb.utils.ts\r‚îî‚îÄ‚îÄ response.utils.ts Step 4: Set Lambda Environment Variables 1. Get Stack Outputs\n# Get DynamoDB table name TABLE_NAME=$(aws cloudformation describe-stacks \\ --stack-name EveryoneCook-dev-Core \\ --query \u0026#39;Stacks[0].Outputs[?OutputKey==`DynamoDBTableName`].OutputValue\u0026#39; \\ --output text) # Get User Pool ID USER_POOL_ID=$(aws cloudformation describe-stacks \\ --stack-name EveryoneCook-dev-Auth \\ --query \u0026#39;Stacks[0].Outputs[?OutputKey==`UserPoolId`].OutputValue\u0026#39; \\ --output text) # Get Content Bucket CONTENT_BUCKET=$(aws cloudformation describe-stacks \\ --stack-name EveryoneCook-dev-Core \\ --query \u0026#39;Stacks[0].Outputs[?OutputKey==`ContentBucketName`].OutputValue\u0026#39; \\ --output text) echo \u0026#34;TABLE_NAME=$TABLE_NAME\u0026#34; echo \u0026#34;USER_POOL_ID=$USER_POOL_ID\u0026#34; echo \u0026#34;CONTENT_BUCKET=$CONTENT_BUCKET\u0026#34; 2. Update Lambda Environment Variables\nLambda environment variables ƒë∆∞·ª£c set t·ª± ƒë·ªông b·ªüi CDK stack, nh∆∞ng b·∫°n c√≥ th·ªÉ verify:\n# Check Auth Module environment variables aws lambda get-function-configuration \\ --function-name EveryoneCook-dev-AuthModule \\ --query \u0026#39;Environment.Variables\u0026#39; # Should show: # { # \u0026#34;TABLE_NAME\u0026#34;: \u0026#34;EveryoneCook-dev\u0026#34;, # \u0026#34;USER_POOL_ID\u0026#34;: \u0026#34;us-east-1_ABC123\u0026#34;, # \u0026#34;REGION\u0026#34;: \u0026#34;us-east-1\u0026#34; # } Step 5: Configure API Gateway 1. Review API Gateway Configuration\n# Get API Gateway ID API_ID=$(aws cloudformation describe-stacks \\ --stack-name EveryoneCook-dev-Backend \\ --query \u0026#39;Stacks[0].Outputs[?OutputKey==`ApiId`].OutputValue\u0026#39; \\ --output text) # Get API details aws apigateway get-rest-api --rest-api-id $API_ID 2. Check Cognito Authorizer\n# List authorizers aws apigateway get-authorizers --rest-api-id $API_ID # Should show Cognito User Pool authorizer 3. Verify Custom Domain\n# Check custom domain mapping aws apigateway get-domain-name --domain-name api.everyonecook.cloud # Should show: # - Domain name: api.everyonecook.cloud # - Certificate ARN # - Regional domain name Step 6: Configure SQS Queues 1. List All Queues\n# List SQS queues aws sqs list-queues | grep EveryoneCook-dev # Should show 12 queues (6 main + 6 DLQ) 2. Configure Queue Permissions\nPermissions ƒë∆∞·ª£c set t·ª± ƒë·ªông b·ªüi CDK, verify:\n# Get AI Queue URL AI_QUEUE_URL=$(aws sqs list-queues \\ --queue-name-prefix EveryoneCook-dev-AIQueue \\ | jq -r \u0026#39;.QueueUrls[0]\u0026#39;) # Check queue attributes aws sqs get-queue-attributes \\ --queue-url $AI_QUEUE_URL \\ --attribute-names All Step 7: Configure Lambda Triggers Cognito Lambda Triggers:\n# Check User Pool triggers aws cognito-idp describe-user-pool \\ --user-pool-id $USER_POOL_ID \\ --query \u0026#39;UserPool.LambdaConfig\u0026#39; # Should show 5 triggers: # - PreSignUp # - PostConfirmation # - PreAuthentication # - PostAuthentication # - CustomMessage Step 8: Test Lambda Functions Locally 1. Test Auth Module\ncd services/auth-module # Run tests npm test # Test specific handler npm run test:unit -- handlers/profile.test.ts 2. Test API Router\ncd services/api-router # Test routing logic npm test # Test with sample event node -e \u0026#34; const handler = require(\u0026#39;./dist/index\u0026#39;).handler; const event = { httpMethod: \u0026#39;GET\u0026#39;, path: \u0026#39;/health\u0026#39;, headers: {} }; handler(event).then(console.log); \u0026#34; Step 9: Verify IAM Permissions 1. Check Lambda Execution Roles\n# List Lambda functions aws lambda list-functions \\ --query \u0026#39;Functions[?contains(FunctionName, `EveryoneCook-dev`)].FunctionName\u0026#39; # Check role for Auth Module aws lambda get-function \\ --function-name EveryoneCook-dev-AuthModule \\ --query \u0026#39;Configuration.Role\u0026#39; 2. Verify DynamoDB Permissions\n# Get role name ROLE_NAME=$(aws lambda get-function \\ --function-name EveryoneCook-dev-AuthModule \\ --query \u0026#39;Configuration.Role\u0026#39; \\ --output text | cut -d\u0026#39;/\u0026#39; -f2) # List attached policies aws iam list-attached-role-policies --role-name $ROLE_NAME # Should include DynamoDB access policy Configuration Checklist API routes reviewed and understood Lambda modules structure reviewed Environment variables verified Lambda layers configured API Gateway custom domain working Cognito authorizer configured SQS queues created and accessible Lambda triggers attached to Cognito IAM permissions verified Local tests passing Next Steps Once configuration is complete, proceed to Deploy Backend Services to deploy your Lambda code.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/1.6-week6/",
	"title": "Week 6 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 6 Objectives: Identity \u0026amp; Access Management (IAM): Implement robust identity controls using IAM Identity Center (SSO), restrict privileges with Permission Boundaries, and secure role assumptions with conditional policies. Security Compliance \u0026amp; Defense: Automate security checks with AWS Security Hub and protect web applications using AWS WAF. Data Protection: Master data encryption using AWS KMS (Key Management Service) and establish comprehensive backup strategies with AWS Backup. Advanced Networking: Implement scalable network architectures using VPC Peering for direct connections and Transit Gateway for hub-and-spoke models. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 Advanced Identity Management - Setup IAM Identity Center (SSO) for centralized access across accounts. - Create Permission Boundaries to limit maximum permissions for IAM users/roles. - Configure IAM Role Conditions to prevent role transfer abuse. 13/10/2025 13/10/2025 https://000012.awsstudygroup.com/ https://000030.awsstudygroup.com/ https://000044.awsstudygroup.com/ 3 Security Posture \u0026amp; Application Defense - Enable AWS Security Hub to check compliance (CIS Standards). - Deploy AWS WAF (Web Application Firewall): + Create Web ACLs with Managed Rules. + Block SQL Injection/XSS attacks on ALBs. 14/10/2025 14/10/2025 https://000018.awsstudygroup.com/ https://000026.awsstudygroup.com/ 4 Data Protection (Encryption \u0026amp; Backup) - Create Customer Managed Keys (CMK) in AWS KMS. - Encrypt S3 buckets and audit usage via CloudTrail \u0026amp; Athena. - Configure AWS Backup: + Create Backup Vault and Backup Plan. + Perform on-demand backup and restore of resources. 15/10/2025 15/10/2025 https://000033.awsstudygroup.com/ https://000013.awsstudygroup.com/ 5 Network Reliability (Peering \u0026amp; Transit) - VPC Peering: Connect two isolated VPCs and configure Route Tables/DNS. - Transit Gateway (TGW): Build a central hub to connect multiple VPCs. - Configure TGW Route Tables for traffic isolation. 16/10/2025 16/10/2025 https://000019.awsstudygroup.com/ https://000020.awsstudygroup.com/ 6 Review \u0026amp; Cleanup - Review all security configurations. - Important: Delete Transit Gateway, NAT Gateways, and disable Security Hub/Config to avoid high costs. - Verify deletion of KMS keys (schedule deletion). 17/10/2025 17/10/2025 All Cleanup Sections Week 6 Achievements Identity \u0026amp; Access Management (IAM) Successfully deployed IAM Identity Center to centralize user management and simplify login access across the organization. Implemented Permission Boundaries to prevent privilege escalation, ensuring users cannot grant themselves more permissions than authorized. Enhanced security by adding Conditions to IAM Roles, restricting how and where roles can be assumed or passed (e.g., limiting role passing to specific services). Security Compliance \u0026amp; Application Defense Activated AWS Security Hub to gain a comprehensive view of the security state and automatically check against CIS AWS Foundations Benchmark. Protected web applications by deploying AWS WAF, successfully creating rules to block common threats like SQL Injection and malicious IP addresses before they reach the application load balancer. Data Encryption \u0026amp; Backup Strategy Managed data security using AWS KMS, creating Customer Managed Keys to encrypt sensitive data in S3. Audited key usage and data access patterns by integrating KMS logs with CloudTrail and querying them via Amazon Athena. Established a robust Disaster Recovery plan using AWS Backup, automating the backup schedules for EBS volumes and testing the successful restoration of data from a recovery point. Advanced Networking \u0026amp; Connectivity Connected isolated network environments using VPC Peering, enabling private communication between VPCs without traversing the public internet. Solved the complexity of mesh networking by implementing AWS Transit Gateway, creating a scalable hub-and-spoke network architecture to interconnect multiple VPCs efficiently. Configured complex Route Tables for both Peering and Transit Gateway to ensure correct traffic flow and network isolation. "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/3-blogstranslated/3.6-blog6/",
	"title": "Blog 6: Top 10 AWS Cloud Operations Announcements at re:Invent 2025",
	"tags": [],
	"description": "",
	"content": "Overview: Reshaping Cloud Operations with AI At re:Invent 2025, AWS announced a series of significant improvements for Cloud Operations. This year\u0026rsquo;s focus revolves around applying Generative AI for observability and troubleshooting, while simplifying the management of large-scale operational data through centralization features.\nBelow are detailed notes on the top 10 announcements that help optimize operational processes on AWS.\n1. Generative AI Observability on CloudWatch and AgentCore AWS launched comprehensive observability capabilities for Generative AI applications. This feature provides detailed insights into latency, token usage, and errors occurring in the AI stack. Notably, it integrates seamlessly with Amazon Bedrock AgentCore and open-source frameworks like LangChain or CrewAI without requiring manual instrumentation code.\n[Figure 1] Amazon CloudWatch Generative AI dashboard\nThe Agent Management View also helps track the agent\u0026rsquo;s workflow from end-to-end:\n[Figure 2] Agent Management View\n2. CloudWatch Application Map with Automatic Service Discovery Previously, creating an Application Map often required complex instrumentation setup. Now, CloudWatch Application Signals can automatically detect and visualize application topology, displaying service dependencies instantly. This feature helps operations teams gain a system overview more quickly.\n[Figure 3] CloudWatch Application Map\n3. Root Cause Analysis (5 \u0026ldquo;Whys\u0026rdquo;) and Incident Report Generation This is a major advancement in AIOps. CloudWatch Investigations leverages Generative AI to automate the root cause analysis process. Instead of manually aggregating data, the system generates an interactive incident report.\n[Figure 4] Amazon CloudWatch Investigations Incident Report\nMost notably, the \u0026ldquo;5 Whys\u0026rdquo; analysis process is built-in, simulating Amazon\u0026rsquo;s internal Correction of Errors (COE) methodology, helping to systematically identify the underlying causes of issues.\n[Figure 5] 5 Whys Analysis in the CloudWatch investigations Incident Report\n4. Model Context Protocol (MCP) Servers Support CloudWatch and Application Signals now support Model Context Protocol (MCP) servers. This acts as a bridge, allowing AI assistants to naturally interact with observability data (metrics, logs, traces). This enables us to build autonomous operational workflows and integrate CloudWatch data into AI-powered development tools.\n5. GitHub Action Integration and MCP Improvements for Application Signals To better support developers, CloudWatch Application Signals has been integrated directly into GitHub Actions. This feature provides observability insights right within Pull Requests and CI/CD pipelines.\nIt helps identify performance issues or system errors without leaving the GitHub development environment:\n[Figure 6] Automated Root Cause Analysis in the GitHub issues\nThe system can even suggest automated bug fixes through Pull Requests:\n[Figure 7] Automated GitHub Pull Request to Fix the Issue\n6. Enhanced Log Analytics Experience on OpenSearch Service Amazon OpenSearch Service introduces significant improvements for Piped Processing Language (PPL). Log analysis becomes faster and more intuitive. Enhanced query capabilities help process complex analytical queries efficiently, while seamlessly integrating with CloudWatch Logs for unified log analysis.\n7. Real User Monitoring (RUM) Support for Mobile (iOS/Android) Amazon CloudWatch RUM extends real user experience monitoring to mobile platforms. We can now track performance, user journeys, and client-side errors on iOS and Android applications, ensuring consistent experiences across all devices and geographic locations.\n8. CloudTrail: Data Event Aggregation To address the massive volume of logs from API activity, AWS CloudTrail adds the Event Aggregation feature. Instead of logging each individual entry, the system summarizes high-frequency activities into aggregated reports every 5 minutes.\nThis helps:\nReduce log storage costs. Easily detect anomalous patterns (such as unusual S3 access or DynamoDB throttling) without manually analyzing too much raw data. 9. Multi-Account \u0026amp; Multi-Region Log Centralization This is a highly anticipated feature for large organizations. CloudWatch Logs Centralization allows collecting logs from multiple Accounts and Regions into a single destination account.\nIntegrates with AWS Organizations. Automatically adds @aws.account and @aws.region context to logs for easy source tracking. Cost savings (no ingestion fees for the first copy). 10. Multi-Account \u0026amp; Multi-Region Centralized Database Monitoring Similar to logs, CloudWatch Database Insights also supports centralized monitoring. We can track the performance of Amazon RDS, Amazon Aurora, and Amazon DynamoDB across the entire AWS organization from a single monitoring account. This makes it easier to correlate database performance with application health.\nConclusion The 2025 announcements show that AWS is focused on solving the \u0026ldquo;operational data overload\u0026rdquo; problem by using AI to filter noise and automate analysis. From monitoring GenAI, to using GenAI to fix errors, and centralization capabilities, these tools help operators shift from a reactive state to proactively controlling systems.\nAuthors Nereida Woo\rNereida is a WW Specialist Solutions Architect in Cloud Operations focusing on Centralized Operations Management and Application operations on AWS. When she isn't working, she enjoys traveling to attend music concerts.\nCalvin Weng\rCalvin Weng is a Product Marketing Manager for AWS Cloud Operations, focusing on observability and monitoring services. Outside of work, Calvin travels, practices pottery, plays ping pong competitively, and explores the Pacific Northwest with his dog Kai.\nRaviteja Sunkavalli\rRaviteja Sunkavalli is a Senior Worldwide Specialist Solutions Architect at Amazon Web Services, specializing in AIOps and GenAI observability. He helps global customers implement observability and incident management solutions across complex and distributed cloud environments. Outside of work, he enjoys playing cricket and exploring new cooking recipes.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/6-self-evaluation/",
	"title": "Self-Assessment",
	"tags": [],
	"description": "",
	"content": "During my internship at Amazon Web Services Vietnam Co., Ltd. from September 8, 2025 to December 9, 2025, I embraced the opportunity to work in a highly professional, disciplined, and growth-oriented environment. This experience not only sharpened my understanding of workplace standards but also helped me develop a stronger professional mindset and a more structured approach to fulfilling assigned responsibilities.\nThroughout the program, I contributed to the Everyonecook project, where I engaged with tasks that aligned with the team‚Äôs development and operational activities. This involvement allowed me to gain practical experience with collaborative workflows and cloud-based development practices within a real project setting.\nDuring the internship, I consistently demonstrated a responsible attitude, adhered closely to organizational processes, and coordinated effectively with colleagues to support shared objectives. I focused on delivering high-quality outcomes while ensuring timely completion of assigned work.\nBelow is my self-evaluation based on key performance criteria:\nNo. Criteria Description Good Fair Average 1 Professional knowledge \u0026amp; skills Ability to apply technical knowledge, use tools effectively, and deliver quality results ‚òê ‚úÖ ‚òê 2 Ability to learn Speed of absorbing new concepts, adaptability to new tasks ‚òê ‚úÖ ‚òê 3 Proactiveness Taking initiative and actively contributing to workflows ‚òê ‚úÖ ‚òê 4 Responsibility Completing tasks with expected quality and within deadlines ‚òê ‚úÖ ‚òê 5 Discipline Following work procedures, schedules, and company policies ‚òê ‚úÖ ‚òê 6 Continuous improvement Willingness to accept feedback and continuously improve ‚òê ‚úÖ ‚òê 7 Communication Ability to convey ideas clearly in meetings and written reports ‚òê ‚úÖ ‚òê 8 Teamwork Collaborating effectively and supporting teammates ‚òê ‚úÖ ‚òê 9 Professional conduct Maintaining respectful and appropriate behavior in the workplace ‚òê ‚úÖ ‚òê 10 Problem-solving skills Identifying issues and proposing practical solutions ‚òê ‚úÖ ‚òê 11 Contribution to project/team Efficiency, effort, and impact on assigned project tasks ‚òê ‚úÖ ‚òê 12 Overall Overall assessment of performance throughout the internship ‚òê ‚úÖ ‚òê Areas for Improvement Strengthen consistency and discipline in daily work routines Improve logical reasoning and structured problem-solving approaches Enhance communication skills, especially in expressing ideas and handling professional situations "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.04-configure-stacks/5.4.6-frontend-stack/",
	"title": "5.4.6 Frontend Stack",
	"tags": [],
	"description": "",
	"content": " Frontend Stack - AWS Amplify Hosting Overview The Frontend Stack handles Next.js 15 application deployment using AWS Amplify. Unlike other stacks managed by CDK, the Frontend is deployed through Amplify Console with GitLab integration for automatic deployment.\nDeployment Method: AWS Amplify Console (not a CDK stack)\n‚ö†Ô∏è Important Note: Frontend deployment is performed separately through Amplify Console. See details at 5.10 Deploy to Amplify.\nKey Responsibilities Host Next.js 15 SSR application Automatic deployment from GitLab repository Custom domain configuration with Route 53 Automatic SSL certificate via ACM Global CDN distribution Environment variables management What This Stack Includes Next.js Application:\nFramework: Next.js 15 with React 18 Rendering: Standalone output mode (SSR) Styling: Tailwind CSS + Flowbite components State Management: React Context API Authentication: AWS Amplify Auth (Cognito integration) AWS Amplify Features:\nAutomatic build and deploy from Git Server-side rendering (SSR) support Custom domain with HTTPS CDN caching and compression Environment variables injection GitLab CI/CD integration Architecture ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ GitLab Repository ‚îÇ\r‚îÇ (everyonecook/frontend) ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ Push to main/dev branch ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ Webhook Trigger\r‚ñº\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ AWS Amplify (Hosting + CI/CD) ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ Build Pipeline (Auto-triggered) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 1. Clone repository from GitLab ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 2. npm install (with legacy peer deps) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 3. Inject environment variables ‚Üí .env.production ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 4. npm run build (Next.js standalone build) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 5. Deploy to Amplify CDN ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ Hosting Configuration ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚Ä¢ CDN Distribution (CloudFront) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚Ä¢ SSR Lambda@Edge functions ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚Ä¢ Custom domain: dev.everyonecook.cloud ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚Ä¢ SSL Certificate (ACM - auto-provisioned) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚Ä¢ Custom headers (security) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚Ä¢ Custom rewrites (Next.js routing) ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ\r‚ñº\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ Route 53 (DNS) ‚îÇ\r‚îÇ dev.everyonecook.cloud ‚Üí A Record ‚Üí Amplify CDN ‚îÇ\r‚îÇ www.dev.everyonecook.cloud ‚Üí CNAME ‚Üí Amplify CDN ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ\r‚ñº\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ End Users (Global) ‚îÇ\r‚îÇ Access via: https://dev.everyonecook.cloud ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Frontend Configuration File Structure frontend/\r‚îú‚îÄ‚îÄ amplify.yml # Amplify build configuration\r‚îú‚îÄ‚îÄ next.config.js # Next.js configuration\r‚îú‚îÄ‚îÄ package.json # Dependencies \u0026amp; scripts\r‚îú‚îÄ‚îÄ .env.example # Environment variables template\r‚îú‚îÄ‚îÄ app/ # Next.js App Router\r‚îÇ ‚îú‚îÄ‚îÄ layout.tsx # Root layout\r‚îÇ ‚îú‚îÄ‚îÄ page.tsx # Home page\r‚îÇ ‚îú‚îÄ‚îÄ auth/ # Authentication pages\r‚îÇ ‚îú‚îÄ‚îÄ profile/ # User profile\r‚îÇ ‚îú‚îÄ‚îÄ recipes/ # Recipe pages\r‚îÇ ‚îî‚îÄ‚îÄ ...\r‚îú‚îÄ‚îÄ components/ # Reusable React components\r‚îú‚îÄ‚îÄ contexts/ # React Context providers\r‚îú‚îÄ‚îÄ hooks/ # Custom React hooks\r‚îú‚îÄ‚îÄ lib/ # Utility functions\r‚îú‚îÄ‚îÄ services/ # API service layer\r‚îî‚îÄ‚îÄ types/ # TypeScript definitions 1. Amplify Build Configuration File: amplify.yml (root directory)\n‚ö†Ô∏è Important: Amplify uses the amplify.yml file at the repository root, not in the frontend/ folder.\nversion: 1 applications: - frontend: phases: preBuild: commands: - export HUSKY=0 - npm install --legacy-peer-deps --ignore-scripts build: commands: - echo \u0026#34;=== Creating .env.production from Amplify env vars ===\u0026#34; - rm -f .env.production - env | grep -e NEXT_PUBLIC_ \u0026gt; .env.production || true - echo \u0026#34;=== .env.production content ===\u0026#34; - cat .env.production - echo \u0026#34;=== Building frontend ===\u0026#34; - npm run build artifacts: baseDirectory: .next files: - \u0026#39;**/*\u0026#39; cache: paths: - node_modules/**/* - .next/cache/**/* appRoot: frontend Additional Configuration in frontend/amplify.yml:\nThe frontend/amplify.yml file contains additional security headers and custom rewrites (can be merged into root amplify.yml if needed):\ncustomHeaders: - pattern: \u0026#39;**/*\u0026#39; headers: - key: \u0026#39;Strict-Transport-Security\u0026#39; value: \u0026#39;max-age=31536000; includeSubDomains\u0026#39; - key: \u0026#39;X-Content-Type-Options\u0026#39; value: \u0026#39;nosniff\u0026#39; - key: \u0026#39;X-Frame-Options\u0026#39; value: \u0026#39;DENY\u0026#39; - key: \u0026#39;X-XSS-Protection\u0026#39; value: \u0026#39;1; mode=block\u0026#39; customRules: # Handle dynamic routes [id] - rewrite non-file requests to Next.js - source: \u0026#39;\u0026lt;/^[^.]+$|\\.(?!(css|gif|ico|jpg|jpeg|js|json|png|txt|svg|woff|woff2|ttf|map|webp|avif)$)([^.]+$)/\u0026gt;\u0026#39; target: /index.html status: \u0026#39;200\u0026#39; # Preserve static assets - source: \u0026#39;/_next/\u0026lt;*\u0026gt;\u0026#39; target: \u0026#39;/_next/\u0026lt;*\u0026gt;\u0026#39; status: \u0026#39;200\u0026#39; - source: \u0026#39;/api/\u0026lt;*\u0026gt;\u0026#39; target: \u0026#39;/api/\u0026lt;*\u0026gt;\u0026#39; status: \u0026#39;200\u0026#39; Key Points:\nappRoot: frontend: Source code in the frontend/ directory Build artifacts: .next directory (Next.js standalone build) Root amplify.yml: Build configuration only Frontend amplify.yml: Includes security headers + custom rewrites Recommendation: Merge customHeaders and customRules into root amplify.yml for centralized configuration 2. Next.js Configuration File: frontend/next.config.js\n/** @type {import(\u0026#39;next\u0026#39;).NextConfig} */ const nextConfig = { reactStrictMode: true, // Output mode for Amplify SSR deployment output: \u0026#39;standalone\u0026#39;, // Performance optimizations poweredByHeader: false, compress: true, trailingSlash: false, // Image optimization images: { remotePatterns: [ { protocol: \u0026#39;https\u0026#39;, hostname: \u0026#39;cdn-dev.everyonecook.cloud\u0026#39;, pathname: \u0026#39;/**\u0026#39;, }, ], formats: [\u0026#39;image/avif\u0026#39;, \u0026#39;image/webp\u0026#39;], deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840], }, // Optimize bundle experimental: { optimizePackageImports: [\u0026#39;react-icons\u0026#39;, \u0026#39;flowbite-react\u0026#39;, \u0026#39;aws-amplify\u0026#39;], optimizeCss: true, }, // Environment variables (fallback values) env: { NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL || \u0026#39;https://api-dev.everyonecook.cloud\u0026#39;, NEXT_PUBLIC_CDN_URL: process.env.NEXT_PUBLIC_CDN_URL || \u0026#39;https://cdn-dev.everyonecook.cloud\u0026#39;, NEXT_PUBLIC_COGNITO_USER_POOL_ID: process.env.NEXT_PUBLIC_COGNITO_USER_POOL_ID, NEXT_PUBLIC_COGNITO_CLIENT_ID: process.env.NEXT_PUBLIC_COGNITO_CLIENT_ID, NEXT_PUBLIC_COGNITO_REGION: process.env.NEXT_PUBLIC_COGNITO_REGION || \u0026#39;ap-southeast-1\u0026#39;, }, }; module.exports = nextConfig; Key Points:\noutput: 'standalone': Optimized build for Amplify Image optimization: Support for AVIF, WebP formats CDN integration: Load images from CloudFront CDN Environment variables: Injected from Amplify Console 3. Dependencies File: frontend/package.json\n{ \u0026#34;name\u0026#34;: \u0026#34;everyonecook-frontend\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;next dev --turbo\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;next build\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;next start\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;next\u0026#34;: \u0026#34;^15.0.0\u0026#34;, \u0026#34;react\u0026#34;: \u0026#34;^18.3.0\u0026#34;, \u0026#34;react-dom\u0026#34;: \u0026#34;^18.3.0\u0026#34;, \u0026#34;aws-amplify\u0026#34;: \u0026#34;^6.15.8\u0026#34;, \u0026#34;@aws-amplify/auth\u0026#34;: \u0026#34;^6.17.0\u0026#34;, \u0026#34;axios\u0026#34;: \u0026#34;^1.13.2\u0026#34;, \u0026#34;flowbite-react\u0026#34;: \u0026#34;^0.7.0\u0026#34;, \u0026#34;react-icons\u0026#34;: \u0026#34;^5.0.1\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;typescript\u0026#34;: \u0026#34;^5.3.0\u0026#34;, \u0026#34;tailwindcss\u0026#34;: \u0026#34;^3.4.18\u0026#34;, \u0026#34;autoprefixer\u0026#34;: \u0026#34;^10.4.22\u0026#34; } } Key Dependencies:\nNext.js 15: Latest SSR framework AWS Amplify: Authentication \u0026amp; API integration Flowbite React: UI component library Tailwind CSS: Utility-first CSS framework 4. Environment Variables File: frontend/.env.example\n# API Configuration NEXT_PUBLIC_API_URL=https://api-dev.everyonecook.cloud # CDN Configuration NEXT_PUBLIC_CDN_URL=https://cdn-dev.everyonecook.cloud # AWS Cognito Configuration NEXT_PUBLIC_COGNITO_USER_POOL_ID=ap-southeast-1_XXXXXXXXX NEXT_PUBLIC_COGNITO_CLIENT_ID=xxxxxxxxxxxxxxxxxxxxx NEXT_PUBLIC_COGNITO_REGION=ap-southeast-1 # Environment NEXT_PUBLIC_ENV=development Important: These variables must be configured in Amplify Console \u0026gt; Environment Variables.\nDeployment Configuration Domain Configuration Environment Frontend Domain Backend API CDN Dev dev.everyonecook.cloud api-dev.everyonecook.cloud cdn-dev.everyonecook.cloud Staging staging.everyonecook.cloud api-staging.everyonecook.cloud cdn-staging.everyonecook.cloud Prod everyonecook.cloud api.everyonecook.cloud cdn.everyonecook.cloud Amplify Configuration Build Settings:\nNode.js version: 18.x (auto-detected) Build timeout: 15 minutes Build image: Amazon Linux 2023 Cache: node_modules + .next/cache Deployment Settings:\nAuto-deploy: Enabled (on Git push) Branch: main (prod), dev (development) Build mode: Server-side rendering (SSR) Integration with Other Stacks Dependencies Frontend requires outputs from:\nDNS Stack (Phase 1):\nRoute 53 Hosted Zone ID Domain name configuration Certificate Stack (Phase 1.5):\nACM Certificate cho custom domain (CloudFront - us-east-1) Amplify s·∫Ω t·ª± ƒë·ªông provision certificate Auth Stack (Phase 3):\nCOGNITO_USER_POOL_ID: User Pool ID COGNITO_CLIENT_ID: App Client ID COGNITO_REGION: AWS Region Backend Stack (Phase 4):\nAPI_URL: API Gateway custom domain API endpoints configuration Core Stack (Phase 2):\nCDN_URL: CloudFront distribution domain S3 bucket for image uploads Cross-Stack References Frontend uses environment variables to connect with backend:\n// services/api.ts const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL; // From Backend Stack const CDN_URL = process.env.NEXT_PUBLIC_CDN_URL; // From Core Stack // lib/auth.ts const cognitoConfig = { userPoolId: process.env.NEXT_PUBLIC_COGNITO_USER_POOL_ID, // From Auth Stack userPoolClientId: process.env.NEXT_PUBLIC_COGNITO_CLIENT_ID, // From Auth Stack region: process.env.NEXT_PUBLIC_COGNITO_REGION, }; Deployment Process Prerequisites Before deploying the frontend, ensure the following are completed:\n‚úÖ DNS Stack deployed (Route 53 Hosted Zone) ‚úÖ Core Stack deployed (S3 + CloudFront CDN) ‚úÖ Auth Stack deployed (Cognito User Pool) ‚úÖ Backend Stack deployed (API Gateway + Lambda) ‚úÖ GitLab repository configured ‚úÖ AWS Amplify connected to GitLab Deployment Steps Frontend is deployed through Amplify Console, NOT through CDK.\nFor deployment details, see: 5.10 Deploy to Amplify\nSummary of steps:\nCreate Amplify App via AWS Console Connect GitLab repository (everyonecook) Configure build settings (amplify.yml) Set environment variables (Cognito, API, CDN URLs) Configure custom domain (dev.everyonecook.cloud) Deploy automatically on Git push ‚ö†Ô∏è Note: After successful deployment, you need to:\n‚úÖ Verify DNS records in Route 53 ‚úÖ Test SSL certificate ‚úÖ Verify custom domain is working ‚úÖ Test authentication flow with Cognito Verification 1. Check Amplify Console üì∏ Screenshot Required: AWS Console \u0026gt; Amplify \u0026gt; App Overview\nVerify:\nBuild status: Success Deployment status: Live Custom domain: Active SSL certificate: Issued Screenshot: Amplify Console showing successful deployment\n2. Check Route 53 DNS üì∏ Screenshot Required: AWS Console \u0026gt; Route 53 \u0026gt; Hosted Zone\nVerify DNS records:\ndev.everyonecook.cloud A ‚Üí Amplify CDN\rwww.dev.everyonecook.cloud CNAME ‚Üí Amplify CDN Screenshot: Route 53 showing Amplify DNS records\n3. Test Frontend Application Access URL:\n# Via custom domain https://dev.everyonecook.cloud # Via Amplify default domain https://main.d1234567890.amplifyapp.com Test Features:\nHomepage loads successfully HTTPS certificate valid User registration works Login with Cognito API calls to backend Images load from CDN üì∏ Screenshot Required: Browser showing frontend homepage with DevTools Network tab\nScreenshot: Frontend homepage loaded successfully\n4. Verify Environment Variables üì∏ Screenshot Required: Amplify Console \u0026gt; Environment Variables\nVerify all required variables:\nNEXT_PUBLIC_API_URL=https://api-dev.everyonecook.cloud\rNEXT_PUBLIC_CDN_URL=https://cdn-dev.everyonecook.cloud\rNEXT_PUBLIC_COGNITO_USER_POOL_ID=ap-southeast-1_XXXXXXXXX\rNEXT_PUBLIC_COGNITO_CLIENT_ID=xxxxxxxxxxxxxxxxxxxxx\rNEXT_PUBLIC_COGNITO_REGION=ap-southeast-1 Screenshot: Amplify environment variables configured\nBest Practices 1. Environment Management ‚úÖ Use separate Amplify apps for dev/staging/prod ‚úÖ Configure environment variables in Amplify Console ‚ö†Ô∏è DO NOT commit .env.production to Git ‚úÖ Use .env.example to document required variables 2. Build Optimization ‚úÖ Enable caching: node_modules + .next/cache ‚úÖ Use output: 'standalone' for smaller bundle ‚úÖ Optimize images: AVIF, WebP formats ‚úÖ Enable gzip compression 3. Security ‚úÖ Set security headers (HSTS, CSP, X-Frame-Options) ‚úÖ Use HTTPS only (enforce via Amplify) ‚úÖ Validate environment variables at build time ‚ö†Ô∏è Do not expose sensitive data in client code 4. Monitoring ‚úÖ Monitor build logs in Amplify Console ‚úÖ Set up build notifications (email, Slack) ‚úÖ Check CloudWatch metrics for CDN ‚úÖ Monitor error rates and performance Summary Frontend Stack configuration highlights:\n‚úÖ Next.js 15 SSR application\n‚úÖ AWS Amplify hosting with automatic deployment\n‚úÖ GitLab CI/CD integration\n‚úÖ Custom domain with Route 53 + ACM\n‚úÖ Environment variables management\n‚úÖ Security headers and optimization\nüîó Next Step: Deploy to Amplify (5.10) - Detailed deployment process\nReference AWS Amplify Documentation: https://docs.aws.amazon.com/amplify/ Next.js Deployment: https://nextjs.org/docs/deployment Frontend Source: everyonecook/frontend/ Build Config: everyonecook/frontend/amplify.yml "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.07-deploy-backend/",
	"title": "Deploy Backend Services",
	"tags": [],
	"description": "",
	"content": "T·ªïng quan Sau khi deploy infrastructure v·ªõi CDK, b·∫°n c·∫ßn deploy Lambda code l√™n AWS. D·ª± √°n EveryoneCook cung c·∫•p automated deployment script ƒë·ªÉ build, package v√† deploy t·∫•t c·∫£ Lambda functions.\nKi·∫øn tr√∫c Backend Lambda Modules (7 functions):\napi-router - API Gateway routing v·ªõi JWT validation auth-user - Authentication \u0026amp; User Management social - Posts, Comments, Reactions, Friends, Notifications recipe-ai - Recipes \u0026amp; AI Features (Bedrock) ai-worker - Async AI processing worker admin - Admin Dashboard \u0026amp; Content Moderation upload - File Upload v·ªõi S3 Presigned URLs Lambda Layer:\nshared-dependencies - Shared npm packages (aws-sdk, uuid, etc.) Cognito Triggers (Auth Stack):\nPre-Signup, Post-Confirmation, Post-Authentication, Pre-Authentication, Custom Message Deployment Process 1. Build Lambda Layer (shared dependencies)\r2. Build TypeScript modules ‚Üí JavaScript\r3. Validate dist folders (check for issues)\r4. Prepare deployment packages\r5. Deploy via CDK ho·∫∑c Direct Lambda Update\r6. Verify deployments\r7. Check CloudWatch logs Option A: Full Deployment (Recommended - First Time) Full deployment s·ª≠ d·ª•ng CDK ƒë·ªÉ deploy to√†n b·ªô infrastructure v√† Lambda code.\nB∆∞·ªõc 1: Navigate to Project # Navigate to everyonecook root cd D:\\Project_AWS\\everyonecook B∆∞·ªõc 2: Run Full Deployment Script # Full deployment cho dev environment .\\deploy\\deploy-backend.ps1 -Environment dev # Ho·∫∑c ng·∫Øn g·ªçn (default l√† dev) .\\deploy\\deploy-backend.ps1 Script s·∫Ω th·ª±c hi·ªán:\nSTEP 0: Building Lambda Layer\nClean previous builds Install production dependencies v√†o layers/shared-dependencies/nodejs/ Layer size: ~15-20 MB STEP 1: Building Lambda modules\nBuild auth triggers (Pre-Signup, Post-Confirmation, etc.) Build t·∫•t c·∫£ 7 Lambda modules Clean dist v√† tsconfig.tsbuildinfo ƒë·ªÉ force fresh compile Compile TypeScript ‚Üí JavaScript STEP 2: Validating dist folders\nCheck dist folder exists Detect node_modules trong dist (common issue) Check dist size (should be \u0026lt; 10 MB) Verify index.js exists Auto-repair n·∫øu ph√°t hi·ªán issues STEP 3: Preparing deployment packages\nClean previous artifacts Copy dist contents ‚Üí deployment folder Add build-info.json (timestamp, git commit) STEP 4: Deploy with CDK\nSynth CloudFormation templates Deploy EveryoneCook-dev-Backend stack Update Lambda functions Update Lambda Layer Update API Gateway Output m·∫´u:\n========================================\rBackend Deployment - dev\rWith Lambda Layers\r========================================\rSTEP 0: Building Lambda Layer...\rInstalling layer dependencies...\rLayer built: 18.45 MB\rSTEP 1: Building Lambda modules...\rBuilding auth triggers... OK\rBuilding api-router... OK\rBuilding auth-module... OK\rBuilding social-module... OK\rBuilding ai-module... OK\rBuilding admin-module... OK\rBuilding upload-module... OK\rSTEP 2: Validating dist folders...\rapi-router... OK (125 files, 1.2 MB)\rauth-module... OK (156 files, 1.5 MB)\rsocial-module... OK (189 files, 1.8 MB)\rai-module... OK (142 files, 1.3 MB)\radmin-module... OK (98 files, 0.9 MB)\rupload-module... OK (45 files, 0.4 MB)\rSTEP 3: Preparing deployment packages...\rPreparing api-router... Done\rPreparing auth-module... Done\rPreparing social-module... Done\rPreparing ai-module... Done\rPreparing admin-module... Done\rPreparing upload-module... Done\rSTEP 4: Deploying with CDK...\rSynthesizing CloudFormation templates...\rEveryoneCook-dev-Backend\rDeploying...\r‚úÖ Lambda Layer updated\r‚úÖ API Router function updated\r‚úÖ Auth User function updated\r‚úÖ Social function updated\r‚úÖ Recipe AI function updated\r‚úÖ AI Worker updated\r‚úÖ Admin function updated\r‚úÖ Upload function updated\rOutputs:\rApiUrl = https://xinq7xh300.execute-api.ap-southeast-1.amazonaws.com/v1/\rApiCustomDomain = https://api-dev.everyonecook.cloud\r========================================\rFULL DEPLOYMENT SUCCESSFUL!\r======================================== B∆∞·ªõc 3: Verify Deployment # List all Lambda functions aws lambda list-functions ` --query \u0026#39;Functions[?contains(FunctionName, `everyonecook-dev`)].{Name:FunctionName,Runtime:Runtime,Updated:LastModified}\u0026#39; ` --output table # Expected output: # -------------------------------------------------------- # | ListFunctions | # +------------------------------------------------------+ # | Name | Runtime | Updated | # +------------------------------------------------------+ # | everyonecook-dev-api-router | nodejs20.x | ... | # | everyonecook-dev-auth-user | nodejs20.x | ... | # | everyonecook-dev-social | nodejs20.x | ... | # | everyonecook-dev-recipe-ai | nodejs20.x | ... | # | everyonecook-dev-ai-worker | nodejs20.x | ... | # | everyonecook-dev-admin | nodejs20.x | ... | # | everyonecook-dev-upload | nodejs20.x | ... | # +------------------------------------------------------+ Option B: Fast Deployment (Lambda Code Only) N·∫øu ch·ªâ thay ƒë·ªïi Lambda code (kh√¥ng thay ƒë·ªïi infrastructure), d√πng fast deployment.\nB∆∞·ªõc 1: Lambda Only Deploy # Fast deploy - ch·ªâ update Lambda code .\\deploy\\deploy-backend.ps1 -Environment dev -LambdaOnly # Ho·∫∑c d√πng dedicated script .\\deploy\\force-update-lambdas.ps1 -Environment dev Faster deployment process:\nSTEP 0: Build Layer (ho·∫∑c skip)\rSTEP 1: Build modules\rSTEP 2: Validate dist\rSTEP 3: Prepare packages\rSTEP 4: Upload to Lambda (Fast Deploy)\r- Create ZIP files\r- Upload directly via aws lambda update-function-code\r- Update Layer ARN if changed\r- Skip CDK (faster) Th·ªùi gian:\nFull Deploy (CDK): ~5-8 minutes Lambda Only: ~2-3 minutes B∆∞·ªõc 2: Skip Options (Advanced) # Skip layer build (d√πng existing layer) .\\deploy\\deploy-backend.ps1 -Environment dev -SkipLayer # Skip module build (d√πng existing dist) .\\deploy\\deploy-backend.ps1 -Environment dev -SkipBuild # Combine options .\\deploy\\deploy-backend.ps1 -Environment dev -LambdaOnly -SkipLayer B∆∞·ªõc 4: Verify Lambda Functions 1. Check Function Configuration # Get API Router details aws lambda get-function ` --function-name everyonecook-dev-api-router ` --query \u0026#39;Configuration.{Runtime:Runtime,Handler:Handler,Timeout:Timeout,Memory:MemorySize,Layer:Layers[0].Arn}\u0026#39; # Expected output: # { # \u0026#34;Runtime\u0026#34;: \u0026#34;nodejs20.x\u0026#34;, # \u0026#34;Handler\u0026#34;: \u0026#34;services/api-router/dist/handlers/index.handler\u0026#34;, # \u0026#34;Timeout\u0026#34;: 30, # \u0026#34;Memory\u0026#34;: 512, # \u0026#34;Layer\u0026#34;: \u0026#34;arn:aws:lambda:ap-southeast-1:...:layer:everyonecook-shared-deps-dev:X\u0026#34; # } 2. Verify Code SHA256 (Code ƒë√£ update) # Check code hash aws lambda get-function ` --function-name everyonecook-dev-api-router ` --query \u0026#39;Configuration.CodeSha256\u0026#39; # SHA256 s·∫Ω thay ƒë·ªïi m·ªói khi code update 3. Check Environment Variables # Get environment variables aws lambda get-function-configuration ` --function-name everyonecook-dev-auth-user ` --query \u0026#39;Environment.Variables\u0026#39; # Expected: # { # \u0026#34;TABLE_NAME\u0026#34;: \u0026#34;EveryoneCook-dev\u0026#34;, # \u0026#34;REGION\u0026#34;: \u0026#34;ap-southeast-1\u0026#34;, # \u0026#34;USER_POOL_ID\u0026#34;: \u0026#34;ap-southeast-1_PKoL34PF0\u0026#34;, # ... # } B∆∞·ªõc 5: Test Lambda Functions 1. Test API Router (Health Check) # Invoke API Router v·ªõi test event aws lambda invoke ` --function-name everyonecook-dev-api-router ` --payload \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/health\u0026#34;,\u0026#34;headers\u0026#34;:{}}\u0026#39; ` response.json # Check response Get-Content response.json | ConvertFrom-Json # Expected: # { # \u0026#34;statusCode\u0026#34;: 200, # \u0026#34;body\u0026#34;: \u0026#34;{\\\u0026#34;status\\\u0026#34;:\\\u0026#34;healthy\\\u0026#34;,\\\u0026#34;timestamp\\\u0026#34;:\\\u0026#34;...\\\u0026#34;}\u0026#34; # } 2. Warm Up Functions (Tr√°nh Cold Start) # Warm up all functions $functions = @( \u0026#34;everyonecook-dev-api-router\u0026#34;, \u0026#34;everyonecook-dev-auth-user\u0026#34;, \u0026#34;everyonecook-dev-social\u0026#34;, \u0026#34;everyonecook-dev-recipe-ai\u0026#34;, \u0026#34;everyonecook-dev-admin\u0026#34;, \u0026#34;everyonecook-dev-upload\u0026#34; ) foreach ($func in $functions) { Write-Host \u0026#34;Warming up $func...\u0026#34; -ForegroundColor Cyan aws lambda invoke ` --function-name $func ` --payload \u0026#39;{\u0026#34;warmup\u0026#34;:true}\u0026#39; ` out.json | Out-Null } Write-Host \u0026#34;All functions warmed up!\u0026#34; -ForegroundColor Green B∆∞·ªõc 6: Check CloudWatch Logs 1. Tail Logs Real-time # Tail API Router logs aws logs tail /aws/lambda/everyonecook-dev-api-router --follow # View last 10 minutes aws logs tail /aws/lambda/everyonecook-dev-api-router --since 10m 2. Search for Errors # Search for errors in last hour $oneHourAgo = [DateTimeOffset]::Now.AddHours(-1).ToUnixTimeMilliseconds() aws logs filter-log-events ` --log-group-name /aws/lambda/everyonecook-dev-api-router ` --start-time $oneHourAgo ` --filter-pattern \u0026#34;ERROR\u0026#34; 3. Check All Lambda Logs # List all log groups aws logs describe-log-groups ` --log-group-name-prefix /aws/lambda/everyonecook-dev ` --query \u0026#39;logGroups[].logGroupName\u0026#39; B∆∞·ªõc 7: Verify API Gateway Integration 1. Get API Endpoint # Get API URL from CloudFormation $apiUrl = aws cloudformation describe-stacks ` --stack-name EveryoneCook-dev-Backend ` --query \u0026#39;Stacks[0].Outputs[?OutputKey==`ApiCustomDomain`].OutputValue\u0026#39; ` --output text Write-Host \u0026#34;API Endpoint: $apiUrl\u0026#34; # Output: https://api-dev.everyonecook.cloud 2. Test Health Endpoint # Test via API Gateway (real endpoint) $response = Invoke-RestMethod -Uri \u0026#34;$apiUrl/health\u0026#34; -Method Get $response | ConvertTo-Json # Expected: # { # \u0026#34;status\u0026#34;: \u0026#34;healthy\u0026#34;, # \u0026#34;timestamp\u0026#34;: \u0026#34;2025-12-09T...\u0026#34;, # \u0026#34;service\u0026#34;: \u0026#34;EveryoneCook API\u0026#34;, # \u0026#34;environment\u0026#34;: \u0026#34;dev\u0026#34; # } 3. Verify API Gateway Deployment # Get API ID $apiId = aws cloudformation describe-stacks ` --stack-name EveryoneCook-dev-Backend ` --query \u0026#39;Stacks[0].Outputs[?OutputKey==`ApiId`].OutputValue\u0026#39; ` --output text # List deployments aws apigateway get-deployments --rest-api-id $apiId # Get latest deployment aws apigateway get-deployment ` --rest-api-id $apiId ` --deployment-id (aws apigateway get-deployments ` --rest-api-id $apiId ` --query \u0026#39;items[0].id\u0026#39; ` --output text) B∆∞·ªõc 8: Verify Cognito Triggers Cognito triggers ƒë√£ ƒë∆∞·ª£c deploy v·ªõi Auth Stack. Verify:\n# List Cognito User Pool triggers $userPoolId = aws cloudformation describe-stacks ` --stack-name EveryoneCook-dev-Auth ` --query \u0026#39;Stacks[0].Outputs[?OutputKey==`UserPoolId`].OutputValue\u0026#39; ` --output text aws cognito-idp describe-user-pool ` --user-pool-id $userPoolId ` --query \u0026#39;UserPool.LambdaConfig\u0026#39; # Expected: # { # \u0026#34;PreSignUp\u0026#34;: \u0026#34;arn:aws:lambda:...:function:EveryoneCook-dev-PreSignup\u0026#34;, # \u0026#34;PostConfirmation\u0026#34;: \u0026#34;arn:aws:lambda:...:function:EveryoneCook-dev-PostConfirmation\u0026#34;, # \u0026#34;PostAuthentication\u0026#34;: \u0026#34;arn:aws:lambda:...:function:EveryoneCook-dev-PostAuthentication\u0026#34;, # \u0026#34;PreAuthentication\u0026#34;: \u0026#34;arn:aws:lambda:...:function:EveryoneCook-dev-PreAuthentication\u0026#34;, # \u0026#34;CustomMessage\u0026#34;: \u0026#34;arn:aws:lambda:...:function:EveryoneCook-dev-CustomMessage\u0026#34; # } B∆∞·ªõc 9: Verify SQS Workers 1. Check AI Worker # Get AI Worker function aws lambda get-function --function-name everyonecook-dev-ai-worker # Check event source mapping (SQS trigger) aws lambda list-event-source-mappings ` --function-name everyonecook-dev-ai-worker # Expected: Event source t·ª´ AI Queue 2. Test Worker v·ªõi SQS Message # Get AI Queue URL $queueUrl = aws sqs list-queues ` --queue-name-prefix everyonecook-dev-ai-queue ` --query \u0026#39;QueueUrls[0]\u0026#39; ` --output text # Send test message aws sqs send-message ` --queue-url $queueUrl ` --message-body \u0026#39;{\u0026#34;type\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;data\u0026#34;:\u0026#34;worker-verification\u0026#34;}\u0026#39; # Check worker logs aws logs tail /aws/lambda/everyonecook-dev-ai-worker --follow Deployment Checklist S·ª≠ d·ª•ng checklist n√†y ƒë·ªÉ verify deployment:\nBuild \u0026amp; Package Lambda Layer built successfully (~15-20 MB) All 7 modules compiled (TypeScript ‚Üí JavaScript) Dist folders validated (no node_modules, \u0026lt; 10 MB) Deployment packages created with build-info.json Lambda Functions All 7 Lambda functions deployed\nRuntime: nodejs20.x\nHandler paths correct\nTimeout: 30 seconds\nMemory: 512 MB (auth, social), 1024 MB (ai)\nLambda Layer attached to all functions\nEnvironment variables configured correctly\nCode SHA256 changed (code updated)\nCognito Triggers Pre-Signup trigger deployed Post-Confirmation trigger deployed Post-Authentication trigger deployed Pre-Authentication trigger deployed Custom Message trigger deployed API Gateway API Gateway deployed Custom domain configured: api-dev.everyonecook.cloud Health endpoint responding: GET /health CORS configured correctly Workers \u0026amp; Queues AI Worker deployed Event source mapping configured (SQS ‚Üí Lambda) SQS queues created (ai-queue, image-queue, analytics-queue, notification-queue) Worker can process test messages Verification All functions invoked successfully No errors in CloudWatch logs API Gateway returns 200 for health check Functions warmed up (no cold start) Troubleshooting Issue 1: Build Failed - TypeScript Compilation Error # Check TypeScript errors cd services/auth-module npx tsc --noEmit # Fix errors v√† rebuild npm run build Issue 2: Dist Folder Too Large # Check for node_modules in dist Get-ChildItem -Path services/*/dist/node_modules -Recurse # Script s·∫Ω auto-remove, ho·∫∑c manual: Remove-Item services/auth-module/dist/node_modules -Recurse -Force # Rebuild cd services/auth-module npm run build Issue 3: Lambda Update Failed # Check function state aws lambda get-function ` --function-name everyonecook-dev-auth-user ` --query \u0026#39;Configuration.{State:State,StateReason:StateReason}\u0026#39; # If state is \u0026#34;Failed\u0026#34;, check logs aws logs tail /aws/lambda/everyonecook-dev-auth-user --since 10m Issue 4: Function Timeout # Increase timeout (via CDK ho·∫∑c AWS CLI) aws lambda update-function-configuration ` --function-name everyonecook-dev-auth-user ` --timeout 60 # Ho·∫∑c update trong backend-stack.ts v√† redeploy Issue 5: Out of Memory # Increase memory aws lambda update-function-configuration ` --function-name everyonecook-dev-recipe-ai ` --memory-size 1024 # AI functions c·∫ßn 1024 MB cho Bedrock calls Issue 6: Layer Not Attached # Get layer ARN $layerArn = aws lambda list-layer-versions ` --layer-name everyonecook-shared-deps-dev ` --query \u0026#39;LayerVersions[0].LayerVersionArn\u0026#39; ` --output text # Attach layer manually aws lambda update-function-configuration ` --function-name everyonecook-dev-auth-user ` --layers $layerArn Issue 7: Environment Variables Missing # Check current env vars aws lambda get-function-configuration ` --function-name everyonecook-dev-auth-user ` --query \u0026#39;Environment.Variables\u0026#39; # Update manually (ho·∫∑c via CDK) aws lambda update-function-configuration ` --function-name everyonecook-dev-auth-user ` --environment \u0026#34;Variables={TABLE_NAME=EveryoneCook-dev,REGION=ap-southeast-1}\u0026#34; Performance Monitoring 1. Lambda Metrics (CloudWatch) # Get invocation count (last 1 hour) $startTime = (Get-Date).AddHours(-1).ToString(\u0026#34;yyyy-MM-ddTHH:mm:ss\u0026#34;) $endTime = (Get-Date).ToString(\u0026#34;yyyy-MM-ddTHH:mm:ss\u0026#34;) aws cloudwatch get-metric-statistics ` --namespace AWS/Lambda ` --metric-name Invocations ` --dimensions Name=FunctionName,Value=everyonecook-dev-api-router ` --start-time $startTime ` --end-time $endTime ` --period 300 ` --statistics Sum 2. Error Rate # Get error count aws cloudwatch get-metric-statistics ` --namespace AWS/Lambda ` --metric-name Errors ` --dimensions Name=FunctionName,Value=everyonecook-dev-api-router ` --start-time $startTime ` --end-time $endTime ` --period 300 ` --statistics Sum 3. Duration (Average \u0026amp; P99) # Get average duration aws cloudwatch get-metric-statistics ` --namespace AWS/Lambda ` --metric-name Duration ` --dimensions Name=FunctionName,Value=everyonecook-dev-api-router ` --start-time $startTime ` --end-time $endTime ` --period 300 ` --statistics Average,Maximum 4. Concurrent Executions # Check concurrent executions aws cloudwatch get-metric-statistics ` --namespace AWS/Lambda ` --metric-name ConcurrentExecutions ` --dimensions Name=FunctionName,Value=everyonecook-dev-api-router ` --start-time $startTime ` --end-time $endTime ` --period 300 ` --statistics Maximum Best Practices 1. Deployment Strategy Development:\n# Fast iteration - Lambda Only .\\deploy\\deploy-backend.ps1 -LambdaOnly Staging/Production:\n# Full deployment with CDK .\\deploy\\deploy-backend.ps1 -Environment prod # Verify thoroughly before proceeding 2. Rollback Strategy # Get previous version aws lambda list-versions-by-function ` --function-name everyonecook-dev-auth-user # Rollback to version X aws lambda update-alias ` --function-name everyonecook-dev-auth-user ` --name LIVE ` --function-version X 3. Blue-Green Deployment # Deploy to new version .\\deploy\\deploy-backend.ps1 -Environment dev # Test new version # If OK, traffic shift complete # If issues, rollback alias 4. Monitoring Alerts # Create CloudWatch alarm for errors aws cloudwatch put-metric-alarm ` --alarm-name everyonecook-dev-api-router-errors ` --alarm-description \u0026#34;Alert on Lambda errors\u0026#34; ` --metric-name Errors ` --namespace AWS/Lambda ` --statistic Sum ` --period 300 ` --evaluation-periods 1 ` --threshold 10 ` --comparison-operator GreaterThanThreshold ` --dimensions Name=FunctionName,Value=everyonecook-dev-api-router Performance Benchmarks Expected Deployment Times:\nOperation Time Notes Build Layer 30-60s npm install production deps Build Modules 20-40s TypeScript compilation (7 modules) Validate \u0026amp; Package 10-20s ZIP creation CDK Deploy 3-5 min CloudFormation update Lambda Only 1-2 min Direct function update Expected Lambda Performance:\nFunction Cold Start Warm Memory Timeout api-router 800-1200ms 50-100ms 512 MB 30s auth-user 600-900ms 80-150ms 512 MB 30s social 700-1000ms 100-200ms 512 MB 30s recipe-ai 1500-2500ms 200-500ms 1024 MB 60s ai-worker 2000-3000ms 300-800ms 1024 MB 300s admin 600-800ms 100-150ms 512 MB 30s upload 400-600ms 50-80ms 256 MB 15s Advanced: CI/CD Integration ƒê·ªÉ t·ª± ƒë·ªông h√≥a deployment trong GitLab CI/CD:\n# .gitlab-ci.yml deploy-backend: stage: deploy script: - cd everyonecook - .\\deploy\\deploy-backend.ps1 -Environment $CI_ENVIRONMENT_NAME -LambdaOnly only: - main environment: name: production Summary Trong lab n√†y, b·∫°n ƒë√£:\n‚úÖ Deploy Lambda Functions: 7 modules + 5 Cognito triggers\n‚úÖ Deploy Lambda Layer: Shared dependencies\n‚úÖ Configure API Gateway: Custom domain integration\n‚úÖ Setup SQS Workers: Async processing\n‚úÖ Verify Deployment: Health checks, logs, metrics\n‚úÖ Performance Tuning: Warm up functions, optimize cold start\nKey Achievements:\nAutomated deployment v·ªõi PowerShell script Full CDK deployment ho·∫∑c fast Lambda-only update Comprehensive validation v√† error handling CloudWatch monitoring v√† alerting Production-ready Lambda configuration Next Steps Backend ƒë√£ deployed th√†nh c√¥ng! Ti·∫øp theo:\n‚úÖ Test Endpoints: Verify t·∫•t c·∫£ API endpoints ‚Üí 5.08 - Test Endpoints üìù Version Control: Push code to GitLab ‚Üí 5.09 - Push to GitLab üöÄ Deploy Frontend: Next.js application üîç Monitor: CloudWatch dashboards v√† alerts Proceed to: 5.08 - Test Endpoints End-to-End\n# Test get posts aws lambda invoke \\ --function-name EveryoneCook-dev-SocialModule \\ --payload \u0026#39;{ \u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;:\u0026#34;/social/posts\u0026#34;, \u0026#34;headers\u0026#34;:{\u0026#34;Authorization\u0026#34;:\u0026#34;Bearer test-token\u0026#34;}, \u0026#34;requestContext\u0026#34;:{\u0026#34;authorizer\u0026#34;:{\u0026#34;claims\u0026#34;:{\u0026#34;sub\u0026#34;:\u0026#34;test-user-id\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;testuser\u0026#34;}}} }\u0026#39; \\ response.json cat response.json Step 5: Check CloudWatch Logs 1. View Recent Logs\n# Tail Auth Module logs aws logs tail /aws/lambda/EveryoneCook-dev-AuthModule --follow # Or view last 10 minutes aws logs tail /aws/lambda/EveryoneCook-dev-AuthModule --since 10m 2. Search for Errors\n# Search for errors in last hour aws logs filter-log-events \\ --log-group-name /aws/lambda/EveryoneCook-dev-AuthModule \\ --start-time $(date -d \u0026#39;1 hour ago\u0026#39; +%s)000 \\ --filter-pattern \u0026#34;ERROR\u0026#34; 3. Check Lambda Insights\n# Get Lambda metrics aws cloudwatch get-metric-statistics \\ --namespace AWS/Lambda \\ --metric-name Invocations \\ --dimensions Name=FunctionName,Value=EveryoneCook-dev-AuthModule \\ --start-time $(date -u -d \u0026#39;1 hour ago\u0026#39; +%Y-%m-%dT%H:%M:%S) \\ --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \\ --period 300 \\ --statistics Sum Screenshot: CloudWatch Logs showing Lambda execution\nStep 6: Deploy Lambda Triggers Lambda triggers ƒë√£ ƒë∆∞·ª£c deploy v·ªõi Auth Stack, verify:\n# Check Post-Confirmation trigger aws lambda get-function \\ --function-name EveryoneCook-dev-PostConfirmationTrigger # Test trigger (will be invoked automatically on user confirmation) Step 7: Deploy Search Sync Worker 1. Deploy Worker\n# Worker ƒë∆∞·ª£c deploy v·ªõi Backend Stack # Verify deployment aws lambda get-function \\ --function-name EveryoneCook-dev-SearchSyncWorker 2. Test Worker with SQS\n# Get SearchIndex queue URL QUEUE_URL=$(aws sqs list-queues \\ --queue-name-prefix EveryoneCook-dev-SearchIndexQueue \\ | jq -r \u0026#39;.QueueUrls[0]\u0026#39;) # Send test message aws sqs send-message \\ --queue-url $QUEUE_URL \\ --message-body \u0026#39;{ \u0026#34;eventName\u0026#34;: \u0026#34;INSERT\u0026#34;, \u0026#34;tableName\u0026#34;: \u0026#34;recipes\u0026#34;, \u0026#34;keys\u0026#34;: {\u0026#34;PK\u0026#34;: \u0026#34;USER#testuser\u0026#34;, \u0026#34;SK\u0026#34;: \u0026#34;RECIPE#test-123\u0026#34;}, \u0026#34;newImage\u0026#34;: {\u0026#34;title\u0026#34;: \u0026#34;Test Recipe\u0026#34;, \u0026#34;cuisine\u0026#34;: \u0026#34;Vietnamese\u0026#34;} }\u0026#39; # Check worker logs aws logs tail /aws/lambda/EveryoneCook-dev-SearchSyncWorker --follow Step 8: Update API Gateway API Gateway t·ª± ƒë·ªông update khi deploy Backend Stack, verify:\n# Get API Gateway deployment API_ID=$(aws cloudformation describe-stacks \\ --stack-name EveryoneCook-dev-Backend \\ --query \u0026#39;Stacks[0].Outputs[?OutputKey==`ApiId`].OutputValue\u0026#39; \\ --output text) # List deployments aws apigateway get-deployments --rest-api-id $API_ID # Get latest deployment aws apigateway get-deployment \\ --rest-api-id $API_ID \\ --deployment-id $(aws apigateway get-deployments \\ --rest-api-id $API_ID \\ --query \u0026#39;items[0].id\u0026#39; \\ --output text) Step 9: Warm Up Lambda Functions Tr√°nh cold start cho requests ƒë·∫ßu ti√™n:\n# Invoke all functions once for func in APIRouter AuthModule SocialModule RecipeAIModule AdminModule UploadModule SearchSyncWorker; do echo \u0026#34;Warming up $func...\u0026#34; aws lambda invoke \\ --function-name EveryoneCook-dev-$func \\ --payload \u0026#39;{\u0026#34;warmup\u0026#34;:true}\u0026#39; \\ /dev/null done Step 10: Verify End-to-End 1. Test Health Endpoint\n# Test via API Gateway curl https://api.everyonecook.cloud/health # Should return: {\u0026#34;status\u0026#34;:\u0026#34;healthy\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;...\u0026#34;} 2. Test with Postman\nImport Postman collection:\n{ \u0026#34;info\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;EveryoneCook API\u0026#34;, \u0026#34;schema\u0026#34;: \u0026#34;https://schema.getpostman.com/json/collection/v2.1.0/collection.json\u0026#34; }, \u0026#34;item\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Health Check\u0026#34;, \u0026#34;request\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://api.everyonecook.cloud/health\u0026#34; } } ] } Deployment Checklist Preparation script completed successfully All Lambda functions updated Function status: Active Test invocations successful CloudWatch logs showing executions No errors in logs Lambda triggers working Search Sync Worker processing messages API Gateway updated Health endpoint responding Functions warmed up Troubleshooting Issue: Lambda update fails\n# Check function state aws lambda get-function \\ --function-name EveryoneCook-dev-AuthModule \\ --query \u0026#39;Configuration.State\u0026#39; # If state is \u0026#34;Failed\u0026#34;, check StateReasonCode aws lambda get-function \\ --function-name EveryoneCook-dev-AuthModule \\ --query \u0026#39;Configuration.StateReasonCode\u0026#39; Issue: Function timeout\n# Increase timeout aws lambda update-function-configuration \\ --function-name EveryoneCook-dev-AuthModule \\ --timeout 30 Issue: Out of memory\n# Increase memory aws lambda update-function-configuration \\ --function-name EveryoneCook-dev-AuthModule \\ --memory-size 512 Issue: Environment variables missing\n# Update environment variables aws lambda update-function-configuration \\ --function-name EveryoneCook-dev-AuthModule \\ --environment Variables={TABLE_NAME=EveryoneCook-dev,REGION=us-east-1} Performance Monitoring Check Lambda metrics:\n# Invocations aws cloudwatch get-metric-statistics \\ --namespace AWS/Lambda \\ --metric-name Invocations \\ --dimensions Name=FunctionName,Value=EveryoneCook-dev-AuthModule \\ --start-time $(date -u -d \u0026#39;1 hour ago\u0026#39; +%Y-%m-%dT%H:%M:%S) \\ --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \\ --period 300 \\ --statistics Sum # Errors aws cloudwatch get-metric-statistics \\ --namespace AWS/Lambda \\ --metric-name Errors \\ --dimensions Name=FunctionName,Value=EveryoneCook-dev-AuthModule \\ --start-time $(date -u -d \u0026#39;1 hour ago\u0026#39; +%Y-%m-%dT%H:%M:%S) \\ --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \\ --period 300 \\ --statistics Sum # Duration aws cloudwatch get-metric-statistics \\ --namespace AWS/Lambda \\ --metric-name Duration \\ --dimensions Name=FunctionName,Value=EveryoneCook-dev-AuthModule \\ --start-time $(date -u -d \u0026#39;1 hour ago\u0026#39; +%Y-%m-%dT%H:%M:%S) \\ --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \\ --period 300 \\ --statistics Average,Maximum Next Steps Once backend is deployed and verified, proceed to Test Endpoints End-to-End to test the complete application flow.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/1.7-week7/",
	"title": "Week 7 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 7 Objectives: Containerization: Master the containerization of applications using Docker and deployment on EC2. Container Orchestration: Deploy and manage scalable containerized applications using Amazon ECS (Elastic Container Service). DevOps \u0026amp; Automation: Implement CI/CD Pipelines (AWS CodePipeline, CodeBuild) for automated deployments to EC2 and ECS. Storage Solutions: Integrate on-premises environments with cloud storage using File Storage Gateway and FSx for Windows. Advanced Database Architecture: Deep dive into Amazon DynamoDB design patterns, indexing strategies, and data modeling for high-performance applications. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 Application Containerization (Docker) - Install Docker on EC2 \u0026amp; Local Machine. - Build Docker images for a sample application (Frontend/Backend). - Use Docker Compose for multi-container orchestration. - Push images to Amazon ECR (Elastic Container Registry). 20/10/2025 20/10/2025 https://000015.awsstudygroup.com/ 3 Container Orchestration (Amazon ECS) - Create ECS Cluster (Fargate/EC2 Launch Type). - Define Task Definitions and Services. - Configure Application Load Balancer (ALB) for traffic distribution. - Implement Service Discovery with AWS Cloud Map. 21/10/2025 21/10/2025 https://000016.awsstudygroup.com/ 4 CI/CD for Containers - Setup AWS CodePipeline triggering from GitHub/GitLab. - Configure AWS CodeBuild to build and push Docker images. - Automate deployment to ECS Clusters. - Implement Monitoring with Container Insights and Logging with FireLens. 22/10/2025 22/10/2025 https://000017.awsstudygroup.com/ 5 CI/CD for EC2 \u0026amp; Hybrid Storage - CodePipeline for EC2: Automate deployments using CodeDeploy agent. - Storage Gateway: Configure File Gateway to mount S3 buckets as NFS shares. - Amazon FSx: Deploy fully managed Windows File Server and mount via SMB. 23/10/2025 23/10/2025 https://000023.awsstudygroup.com/ Self-Study on FSx/Storage Gateway 6 Advanced DynamoDB Architecture - Data Modeling: Design Single Table Design patterns. - Performance Tuning: Work with Partition Keys, Sort Keys, and Capacity Units (RCU/WCU). - Advanced Features: Implement Global Secondary Indexes (GSI), DynamoDB Streams, and Global Tables. 24/10/2025 24/10/2025 https://000039.awsstudygroup.com/ Week 7 Achievements Containerization \u0026amp; Orchestration Successfully \u0026ldquo;dockerized\u0026rdquo; a monolithic application, decoupling it from the underlying infrastructure. Deployed a highly available container cluster using Amazon ECS, utilizing Task Definitions to define resource requirements. Configured Service Discovery to allow microservices within the cluster to communicate via logical names instead of IP addresses. Implemented Application Load Balancer to distribute public traffic to dynamic container targets. DevOps \u0026amp; CI/CD Automation Built a robust CI/CD Pipeline using AWS CodePipeline and CodeBuild. Achieved Continuous Deployment: Code changes pushed to the repository automatically trigger a build, image creation, and rolling update to the ECS service without downtime. Integrated comprehensive monitoring using CloudWatch Container Insights to track CPU/Memory utilization of tasks. Centralized container logs using FireLens for easier debugging and analysis. Hybrid Storage Implementation Bridged the gap between on-premises protocols and cloud storage. Configured File Storage Gateway to allow legacy applications to write to S3 using standard NFS protocols. Deployed Amazon FSx for Windows File Server, providing a fully managed, native Windows file system with Active Directory integration. High-Performance Database Design Mastered NoSQL concepts with Amazon DynamoDB. Optimized database performance by designing efficient Partition and Sort Keys. Implemented Global Secondary Indexes (GSI) to support diverse access patterns without duplicating data tables. Explored DynamoDB Streams for event-driven architectures (triggering Lambda functions on database changes). "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/7-feedback/",
	"title": "Sharing and Feedback",
	"tags": [],
	"description": "",
	"content": "Overall Evaluation 1. Working Environment\nThe working environment is professional, supportive, and highly conducive to continuous learning. Team members maintain a friendly, respectful attitude and are always willing to help whenever assistance is needed. The workspace is well-organized and comfortable, which contributes positively to productivity. Implementing more team-building or social activities could further strengthen internal engagement and collaboration.\n2. Support from Mentor / Team Admin\nMy mentor provided clear and structured guidance throughout the internship while encouraging me to explore independent solutions before stepping in with direct support. The admin team was also attentive and efficient, especially when handling documentation and administrative procedures. Their combined efforts played an important role in ensuring a smooth and productive learning experience.\n3. Relevance of Work to Academic Major\nThe assigned tasks were closely aligned with the subjects I studied at university. At the same time, I was exposed to new tools, workflows, and practical knowledge that extended beyond classroom learning. This combination helped reinforce my academic foundation while expanding real-world technical experience.\n4. Learning \u0026amp; Skill Development Opportunities\nThe internship allowed me to gain hands-on experience with project coordination tools, collaborative workflows, and professional communication. My mentor frequently shared insights from real industry scenarios, giving me a clearer picture of potential career paths and long-term development goals.\n5. Company Culture \u0026amp; Team Spirit\nThe company fosters a positive and respectful culture. Team members collaborate openly and work diligently while maintaining a welcoming atmosphere. During high-priority tasks, the entire team‚Äîregardless of position or seniority‚Äîworked together effectively. This created a strong sense of belonging and made the experience even more meaningful for me as an intern.\n6. Internship Policies / Benefits\nThe internship policies are supportive, offering fair allowances and flexibility when needed. Additionally, the opportunity to join internal training sessions added significant value and enhanced my overall learning experience.\nAdditional Questions 1. What did you find most satisfying during your internship?\nThe most rewarding aspect was being able to work in a highly professional yet supportive environment. I especially appreciated my mentor‚Äôs guidance‚Äîclear, structured, and encouraging independence. This balance helped me develop both technical skills and professional maturity.\n2. What aspects should the company improve for future interns?\nNo additional comments beyond what has been mentioned earlier.\n3. Would you recommend this internship to a friend? Why or why not?\nYes, I would definitely recommend it. The internship offers a comprehensive learning experience that combines meaningful tasks, strong mentorship, and a positive workplace culture. It provides real opportunities for interns to develop practical skills and grow professionally.\nSuggestions \u0026amp; Expectations Do you have any suggestions to enhance the internship experience?\nNo additional comments beyond the points noted above.\nWould you be interested in continuing with the program in the future?\nNo additional comments.\nAny additional comments:\nNo additional comments.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.04-configure-stacks/5.4.7-observability-stack/",
	"title": "5.4.7 Observability Stack",
	"tags": [],
	"description": "",
	"content": " Observability Stack - Monitoring \u0026amp; Alerting Overview The Observability Stack is the Phase 7 monitoring layer of the EveryoneCook infrastructure. It provides comprehensive monitoring, alerting, and visualization for all deployed stacks through CloudWatch dashboards, alarms, and SNS notifications.\nDeployment Order: This stack MUST be deployed LAST, after all other stacks (DNS, Certificate, Core, Auth, Backend, Frontend) are deployed.\n‚ö†Ô∏è Environment Note: This guide focuses on Development (dev) environment deployment. For staging/production deployments, alarm thresholds and monitoring intervals may be different.\nKey Responsibilities Create CloudWatch Dashboards for all stack layers Configure CloudWatch Alarms for critical metrics Setup SNS Topic for alarm notifications Create Composite Alarm for overall system health Monitor API Gateway, Lambda, DynamoDB, S3, CloudFront, and Cognito Track cost and billing metrics What This Stack Includes CloudWatch Dashboards (4 dashboards):\nCore Dashboard: DynamoDB, S3, CloudFront metrics Auth Dashboard: Cognito authentication metrics Backend Dashboard: API Gateway, Lambda, SQS metrics Overview Dashboard: Aggregated system health view CloudWatch Alarms (15+ alarms):\nAPI Gateway: 5XX errors, 4XX errors, latency Lambda: Error rate, throttles, duration DynamoDB: Read/write throttles, latency S3: 4XX/5XX errors SQS: DLQ messages, queue age Cost: Daily spending warnings Notification System:\nSNS Topic for alarm notifications Email subscriptions for alerts Composite alarm for system health Architecture ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ Observability Stack (Phase 7 - Dev Environment) ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ SNS Topic (Alarm Notifications) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Topic Name: EveryoneCook-dev-Alarms ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Email Subscription: team@everyonecook.cloud ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Protocol: Email (requires confirmation) ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚ñº (Alarm Actions) ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ CloudWatch Alarms (15+ alarms) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ API Gateway Alarms: ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ 5XX Error Rate \u0026gt; 5% (Critical) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ 4XX Error Rate \u0026gt; 20% (Warning) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ P99 Latency \u0026gt; 3s (Warning) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ Lambda Alarms: ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Error Rate \u0026gt; 5% (Critical) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Throttles \u0026gt; 10 (Critical) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ P99 Duration \u0026gt; 10s (Warning) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ DynamoDB Alarms: ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Read Throttles \u0026gt; 10 (Critical) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Write Throttles \u0026gt; 10 (Critical) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ P99 Latency \u0026gt; 100ms (Warning) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ S3 Alarms: ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ 4XX Error Rate \u0026gt; 5% (Warning) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ 5XX Errors \u0026gt; 0 (Critical) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ SQS Alarms: ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ DLQ Messages \u0026gt; 0 (Critical) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Message Age \u0026gt; 5 minutes (Warning) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ Cost Alarms: ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Daily Cost \u0026gt; $50 (Warning) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Daily Cost \u0026gt; $100 (Critical) ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚ñº ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ Composite Alarm (System Health) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Name: EveryoneCook-dev-SystemHealth ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Triggers: ANY critical alarm fires ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Action: Send SNS notification ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\r‚îÇ ‚îÇ CloudWatch Dashboards (4 dashboards) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 1. Core Dashboard (EveryoneCook-dev-Core): ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ DynamoDB: Read/Write capacity, throttles, latency ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ S3: Requests, errors, bytes transferred ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ CloudFront: Requests, error rates, bytes downloaded ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 2. Auth Dashboard (EveryoneCook-dev-Auth): ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Cognito: Sign-ups, sign-ins ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Cognito: Failed authentications ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 3. Backend Dashboard (EveryoneCook-dev-Backend): ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ API Gateway: Requests, latency (P50/P95/P99) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ API Gateway: 4XX/5XX errors ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Lambda: Invocations, duration, errors, throttles ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ SQS: Messages sent, visible, oldest age ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ ‚îÇ 4. Overview Dashboard (EveryoneCook-dev-Overview): ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ System Health: Environment info, region ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Key Metrics: API requests, latency, Lambda stats ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Error Trends: API 5XX, Lambda errors (last hour) ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îú‚îÄ Cost Tracking: Estimated daily cost, 7-day trend ‚îÇ ‚îÇ\r‚îÇ ‚îÇ ‚îî‚îÄ Alarm Status: Composite alarm widget ‚îÇ ‚îÇ\r‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ\r‚îÇ Monitors\r‚ñº\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚ñº ‚ñº ‚ñº\rCore Stack Auth Stack Backend Stack\r(DynamoDB, (Cognito) (API Gateway,\rS3, CDN) Lambda, SQS) Stack Configuration File Structure infrastructure/lib/stacks/\r‚îî‚îÄ‚îÄ observability-stack.ts # Observability Stack implementation (1175 lines) Code Implementation Highlights File: infrastructure/lib/stacks/observability-stack.ts\n1. SNS Topic for Alarms /** * Create SNS Topic for CloudWatch Alarms * Task 7.4.2 - Step 1 */ private createAlarmTopic(): sns.Topic { const topic = new sns.Topic(this, \u0026#39;AlarmTopic\u0026#39;, { topicName: `EveryoneCook-${this.config.environment}-Alarms`, displayName: \u0026#39;Everyone Cook CloudWatch Alarms\u0026#39;, }); // Add email subscription for alarm notifications topic.addSubscription( new sns_subscriptions.EmailSubscription(this.config.contact.email) ); return topic; } Configuration: Email subscription requires confirmation via AWS SNS.\n2. API Gateway Alarms // API Gateway: High 5XX Error Rate (Critical) const api5xxAlarm = new cloudwatch.Alarm(this, \u0026#39;API-5XX-Critical\u0026#39;, { alarmName: `EveryoneCook-${this.config.environment}-API-5XX-Critical`, alarmDescription: \u0026#39;API Gateway 5XX error rate \u0026gt; 5% in 5 minutes\u0026#39;, metric: new cloudwatch.Metric({ namespace: \u0026#39;AWS/ApiGateway\u0026#39;, metricName: \u0026#39;5XXError\u0026#39;, dimensionsMap: { ApiName: apiName }, statistic: \u0026#39;Sum\u0026#39;, period: cdk.Duration.minutes(5), }), threshold: 5, evaluationPeriods: 2, comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD, treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING, }); api5xxAlarm.addAlarmAction(alarmAction); // API Gateway: High Latency (Warning) const apiLatencyAlarm = new cloudwatch.Alarm(this, \u0026#39;API-Latency-High\u0026#39;, { alarmName: `EveryoneCook-${this.config.environment}-API-Latency-High`, alarmDescription: \u0026#39;API Gateway P99 latency \u0026gt; 3s in 5 minutes\u0026#39;, metric: new cloudwatch.Metric({ namespace: \u0026#39;AWS/ApiGateway\u0026#39;, metricName: \u0026#39;Latency\u0026#39;, dimensionsMap: { ApiName: apiName }, statistic: \u0026#39;p99\u0026#39;, period: cdk.Duration.minutes(5), }), threshold: 3000, // 3 seconds in milliseconds evaluationPeriods: 2, comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD, }); 3. Lambda Alarms // Lambda: High Error Rate (Critical) const lambdaErrorAlarm = new cloudwatch.Alarm(this, \u0026#39;Lambda-Error-Rate\u0026#39;, { alarmName: `EveryoneCook-${this.config.environment}-Lambda-Error-Rate`, alarmDescription: \u0026#39;Lambda error rate \u0026gt; 5% in 5 minutes\u0026#39;, metric: new cloudwatch.Metric({ namespace: \u0026#39;AWS/Lambda\u0026#39;, metricName: \u0026#39;Errors\u0026#39;, statistic: \u0026#39;Sum\u0026#39;, period: cdk.Duration.minutes(5), }), threshold: 5, evaluationPeriods: 2, comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD, }); // Lambda: Throttles (Critical) const lambdaThrottleAlarm = new cloudwatch.Alarm(this, \u0026#39;Lambda-Throttle\u0026#39;, { alarmName: `EveryoneCook-${this.config.environment}-Lambda-Throttle`, alarmDescription: \u0026#39;Lambda throttles \u0026gt; 10 in 5 minutes\u0026#39;, metric: new cloudwatch.Metric({ namespace: \u0026#39;AWS/Lambda\u0026#39;, metricName: \u0026#39;Throttles\u0026#39;, statistic: \u0026#39;Sum\u0026#39;, period: cdk.Duration.minutes(5), }), threshold: 10, evaluationPeriods: 1, }); 4. DynamoDB Alarms // DynamoDB: Read Throttles (Critical) const dynamoReadThrottleAlarm = new cloudwatch.Alarm(this, \u0026#39;DynamoDB-Read-Throttle\u0026#39;, { alarmName: `EveryoneCook-${this.config.environment}-DynamoDB-Read-Throttle`, alarmDescription: \u0026#39;DynamoDB read throttles \u0026gt; 10 in 5 minutes\u0026#39;, metric: new cloudwatch.Metric({ namespace: \u0026#39;AWS/DynamoDB\u0026#39;, metricName: \u0026#39;ReadThrottleEvents\u0026#39;, dimensionsMap: { TableName: dynamoTableName }, statistic: \u0026#39;Sum\u0026#39;, period: cdk.Duration.minutes(5), }), threshold: 10, evaluationPeriods: 2, }); // DynamoDB: High Latency (Warning) const dynamoLatencyAlarm = new cloudwatch.Alarm(this, \u0026#39;DynamoDB-Latency-High\u0026#39;, { alarmName: `EveryoneCook-${this.config.environment}-DynamoDB-Latency-High`, alarmDescription: \u0026#39;DynamoDB P99 latency \u0026gt; 100ms in 5 minutes\u0026#39;, metric: new cloudwatch.Metric({ namespace: \u0026#39;AWS/DynamoDB\u0026#39;, metricName: \u0026#39;SuccessfulRequestLatency\u0026#39;, dimensionsMap: { TableName: dynamoTableName, Operation: \u0026#39;Query\u0026#39;, }, statistic: \u0026#39;p99\u0026#39;, period: cdk.Duration.minutes(5), }), threshold: 100, // 100ms evaluationPeriods: 3, }); 5. Composite Alarm /** * Create Composite Alarm for overall system health * Task 7.4.2 - Step 2 */ private createCompositeAlarm(alarms: cloudwatch.IAlarm[]): cloudwatch.CompositeAlarm { // Filter critical alarms only const criticalAlarms = alarms.filter( (alarm) =\u0026gt; alarm.alarmName.includes(\u0026#39;Critical\u0026#39;) || alarm.alarmName.includes(\u0026#39;Throttle\u0026#39;) ); const compositeAlarm = new cloudwatch.CompositeAlarm(this, \u0026#39;SystemHealth\u0026#39;, { compositeAlarmName: `EveryoneCook-${this.config.environment}-SystemHealth`, alarmDescription: \u0026#39;Overall system health - triggers if any critical alarm fires\u0026#39;, alarmRule: cloudwatch.AlarmRule.anyOf( ...criticalAlarms.map((alarm) =\u0026gt; cloudwatch.AlarmRule.fromAlarm(alarm, cloudwatch.AlarmState.ALARM) ) ), }); compositeAlarm.addAlarmAction(new cloudwatch_actions.SnsAction(this.alarmTopic)); return compositeAlarm; } 6. Core Dashboard /** * Create Core Dashboard (DynamoDB, S3, CloudFront) */ private createCoreDashboard(props: ObservabilityStackProps): cloudwatch.Dashboard { const dashboard = new cloudwatch.Dashboard(this, \u0026#39;CoreDashboard\u0026#39;, { dashboardName: `EveryoneCook-${this.config.environment}-Core`, }); // DynamoDB Metrics dashboard.addWidgets( new cloudwatch.GraphWidget({ title: \u0026#39;DynamoDB - Read/Write Capacity\u0026#39;, left: [ new cloudwatch.Metric({ namespace: \u0026#39;AWS/DynamoDB\u0026#39;, metricName: \u0026#39;ConsumedReadCapacityUnits\u0026#39;, dimensionsMap: { TableName: dynamoTableName }, statistic: \u0026#39;Sum\u0026#39;, period: cdk.Duration.minutes(5), }), new cloudwatch.Metric({ namespace: \u0026#39;AWS/DynamoDB\u0026#39;, metricName: \u0026#39;ConsumedWriteCapacityUnits\u0026#39;, dimensionsMap: { TableName: dynamoTableName }, statistic: \u0026#39;Sum\u0026#39;, period: cdk.Duration.minutes(5), }), ], width: 12, }), new cloudwatch.GraphWidget({ title: \u0026#39;DynamoDB - Throttles\u0026#39;, left: [ new cloudwatch.Metric({ namespace: \u0026#39;AWS/DynamoDB\u0026#39;, metricName: \u0026#39;ReadThrottleEvents\u0026#39;, dimensionsMap: { TableName: dynamoTableName }, statistic: \u0026#39;Sum\u0026#39;, period: cdk.Duration.minutes(5), }), new cloudwatch.Metric({ namespace: \u0026#39;AWS/DynamoDB\u0026#39;, metricName: \u0026#39;WriteThrottleEvents\u0026#39;, dimensionsMap: { TableName: dynamoTableName }, statistic: \u0026#39;Sum\u0026#39;, period: cdk.Duration.minutes(5), }), ], width: 12, }) ); // S3 and CloudFront metrics... return dashboard; } 7. Overview Dashboard /** * Create Overview Dashboard (Aggregated view) */ private createOverviewDashboard(props: ObservabilityStackProps): cloudwatch.Dashboard { const dashboard = new cloudwatch.Dashboard(this, \u0026#39;OverviewDashboard\u0026#39;, { dashboardName: `EveryoneCook-${this.config.environment}-Overview`, }); // System Health Header dashboard.addWidgets( new cloudwatch.TextWidget({ markdown: `# Everyone Cook - System Overview\\n\\n**Environment:** ${this.config.environment}\\n\\n**Region:** ${this.region}`, width: 24, height: 2, }) ); // Key Metrics: API, Lambda, DynamoDB, S3 // Cost Tracking // Alarm Status Widget return dashboard; } Deployment Guide Prerequisites Before deploying the Observability Stack, ensure:\nAll other stacks deployed:\nDNS Stack (Phase 1) Certificate Stack (Phase 1.5) Core Stack (Phase 2) Auth Stack (Phase 3) Backend Stack (Phase 4) Frontend Stack (Phase 6 - Amplify) Stack exports available:\naws cloudformation list-exports --region ap-southeast-1 Expected exports:\nEveryoneCook-dev-Core-TableName EveryoneCook-dev-Core-ContentBucketName EveryoneCook-dev-Core-DistributionId EveryoneCook-dev-Auth-UserPoolId EveryoneCook-dev-Backend-ApiName Email configured:\nValid email in infrastructure/config/dev.ts Email will receive SNS subscription confirmation Step 1: Review Configuration File: infrastructure/config/dev.ts\nexport const devConfig: EnvironmentConfig = { environment: \u0026#39;dev\u0026#39;, region: \u0026#39;ap-southeast-1\u0026#39;, // Email for alarm notifications contact: { email: \u0026#39;your-email@example.com\u0026#39;, // ‚ö†Ô∏è Update this phone: \u0026#39;+1234567890\u0026#39;, }, // Monitoring settings (already configured) monitoring: { enableDetailedMonitoring: true, retainLogs: true, logRetentionDays: 7, enableXRay: false, // Disabled for dev to save costs }, }; ‚ö†Ô∏è Important: Update the email address to receive alarm notifications.\nStep 2: Synthesize CloudFormation Template Navigate to infrastructure directory:\ncd D:\\Project_AWS\\everyonecook\\infrastructure Synthesize the Observability Stack:\nnpm run synth Expected Output (1175 lines):\n‚ú® Synthesis time: 3.5s\rResources:\r[+] AWS::SNS::Topic AlarmTopic\r[+] AWS::SNS::Subscription AlarmTopic/EmailSubscription\r[+] AWS::CloudWatch::Alarm API-5XX-Critical\r[+] AWS::CloudWatch::Alarm API-4XX-Warning\r[+] AWS::CloudWatch::Alarm API-Latency-High\r[+] AWS::CloudWatch::Alarm Lambda-Error-Rate\r[+] AWS::CloudWatch::Alarm Lambda-Throttle\r[+] AWS::CloudWatch::Alarm Lambda-Duration-High\r[+] AWS::CloudWatch::Alarm DynamoDB-Read-Throttle\r[+] AWS::CloudWatch::Alarm DynamoDB-Write-Throttle\r[+] AWS::CloudWatch::Alarm DynamoDB-Latency-High\r[+] AWS::CloudWatch::Alarm S3-4XX-Warning\r[+] AWS::CloudWatch::Alarm S3-5XX-Critical\r[+] AWS::CloudWatch::Alarm SQS-DLQ-Messages\r[+] AWS::CloudWatch::Alarm SQS-Queue-Age\r[+] AWS::CloudWatch::Alarm Cost-Warning\r[+] AWS::CloudWatch::Alarm Cost-Critical\r[+] AWS::CloudWatch::CompositeAlarm SystemHealth\r[+] AWS::CloudWatch::Dashboard CoreDashboard\r[+] AWS::CloudWatch::Dashboard AuthDashboard\r[+] AWS::CloudWatch::Dashboard BackendDashboard\r[+] AWS::CloudWatch::Dashboard OverviewDashboard\rOutputs:\r- AlarmTopicArn\r- CompositeAlarmName\r- CoreDashboardName\r- AuthDashboardName\r- BackendDashboardName\r- OverviewDashboardName Screenshot: CDK synth output showing all Observability Stack resources\nStep 3: Review Generated Template Open the generated CloudFormation template:\ncode infrastructure/cdk.out/EveryoneCook-dev-Observability.template.json Screenshot: Generated CloudFormation template showing SNS Topic, 15+ Alarms, Composite Alarm, and 4 Dashboards\nStep 4: Deploy Observability Stack Deploy using CDK:\nnpx cdk deploy EveryoneCook-dev-Observability --require-approval never Expected Deployment Time: 2-3 minutes\nDeployment Output:\nEveryoneCook-dev-Observability: deploying...\rEveryoneCook-dev-Observability: creating CloudFormation changeset...\rEveryoneCook-dev-Observability\rOutputs:\rEveryoneCook-dev-Observability.AlarmTopicArn = arn:aws:sns:ap-southeast-1:123456789012:EveryoneCook-dev-Alarms\rEveryoneCook-dev-Observability.CompositeAlarmName = EveryoneCook-dev-SystemHealth\rEveryoneCook-dev-Observability.CoreDashboardName = EveryoneCook-dev-Core\rEveryoneCook-dev-Observability.AuthDashboardName = EveryoneCook-dev-Auth\rEveryoneCook-dev-Observability.BackendDashboardName = EveryoneCook-dev-Backend\rEveryoneCook-dev-Observability.OverviewDashboardName = EveryoneCook-dev-Overview\rStack ARN:\rarn:aws:cloudformation:ap-southeast-1:123456789012:stack/EveryoneCook-dev-Observability/...\r‚ú® Deployment time: 2m 15s Verification Step 1: Verify CloudFormation Stack Navigate to CloudFormation Console:\nAWS Console ‚Üí CloudFormation ‚Üí Stacks Verify Stack:\nStack Name: EveryoneCook-dev-Observability Status: CREATE_COMPLETE ‚úÖ Resources: 24 resources created Screenshot: CloudFormation stack with CREATE_COMPLETE status and 24 resources\nScreenshot: CloudFormation Outputs tab showing all 6 outputs\nStep 2: Verify CloudWatch Alarms Navigate to CloudWatch Console ‚Üí Alarms:\nAWS Console ‚Üí CloudWatch ‚Üí All alarms Verify Alarms Created (15+ alarms):\nAlarm Name Type Metric Threshold Status EveryoneCook-dev-API-5XX-Critical Critical API 5XX Errors \u0026gt; 5 OK EveryoneCook-dev-API-4XX-Warning Warning API 4XX Errors \u0026gt; 20 OK EveryoneCook-dev-API-Latency-High Warning API P99 Latency \u0026gt; 3000ms OK EveryoneCook-dev-Lambda-Error-Rate Critical Lambda Errors \u0026gt; 5 OK EveryoneCook-dev-Lambda-Throttle Critical Lambda Throttles \u0026gt; 10 OK EveryoneCook-dev-Lambda-Duration-High Warning Lambda P99 Duration \u0026gt; 10000ms OK EveryoneCook-dev-DynamoDB-Read-Throttle Critical DynamoDB Read Throttles \u0026gt; 10 OK EveryoneCook-dev-DynamoDB-Write-Throttle Critical DynamoDB Write Throttles \u0026gt; 10 OK EveryoneCook-dev-DynamoDB-Latency-High Warning DynamoDB P99 Latency \u0026gt; 100ms OK EveryoneCook-dev-S3-4XX-Warning Warning S3 4XX Errors \u0026gt; 5% OK EveryoneCook-dev-S3-5XX-Critical Critical S3 5XX Errors \u0026gt; 0 OK EveryoneCook-dev-SQS-DLQ-Messages Critical SQS DLQ Messages \u0026gt; 0 OK EveryoneCook-dev-SQS-Queue-Age Warning SQS Message Age \u0026gt; 300s OK EveryoneCook-dev-Cost-Warning Warning Daily Cost \u0026gt; $50 OK EveryoneCook-dev-Cost-Critical Critical Daily Cost \u0026gt; $100 OK Verify Composite Alarm:\nName: EveryoneCook-dev-SystemHealth Type: Composite Rule: ANY critical alarm ‚Üí ALARM Status: OK ‚úÖ Screenshot: CloudWatch Alarms console showing all 15+ alarms with OK status\nScreenshot: Composite alarm details for system health monitoring\nStep 3: Verify CloudWatch Dashboards Navigate to CloudWatch Console ‚Üí Dashboards:\nAWS Console ‚Üí CloudWatch ‚Üí Dashboards Verify Dashboards Created (5 dashboards):\n1. Core Dashboard (EveryoneCook-dev-Core) Open the dashboard and verify widgets:\nDynamoDB Widgets:\nRead/Write Capacity graph Throttles graph Latency (P99) graph Table Size metric S3 Widgets:\nRequests graph Errors (4XX/5XX) graph CloudFront Widgets:\nRequests graph Error Rate (4XX/5XX) graph Bytes Downloaded graph Screenshot: Core Dashboard showing DynamoDB, S3, and CloudFront metrics\n2. Auth Dashboard (EveryoneCook-dev-Auth) Cognito Widgets:\nSign-ups graph Sign-ins graph Failed Authentications graph Screenshot: Auth Dashboard showing Cognito authentication metrics\n3. Backend Dashboard (EveryoneCook-dev-Backend) API Gateway Widgets:\nRequests graph Latency (P50/P95/P99) graph 4XX Errors graph 5XX Errors graph Lambda Widgets:\nInvocations graph Duration (P99) graph Errors graph Throttles graph SQS Widgets:\nMessages Sent graph Messages Visible graph Oldest Message Age graph Screenshot: Backend Dashboard showing API Gateway, Lambda, and SQS metrics\n4. Overview Dashboard (EveryoneCook-dev-Overview) System Health Section:\nHeader with environment info Region information Key Metrics:\nAPI Requests (5m) - Single value widget API P99 Latency - Single value widget Lambda Invocations (5m) - Single value widget Lambda Errors (5m) - Single value widget DynamoDB Read/Write Throttles - Single value widgets S3 Requests and Errors - Single value widgets Trends:\nError Rates graph (API 5XX, Lambda Errors) Cost Tracking:\nEstimated Daily Cost - Single value widget Cost Trend (7 days) - Graph widget Alarm Status:\nComposite Alarm widget showing system health Screenshot: Overview Dashboard with system health, key metrics, error trends, and cost tracking\nCost Breakdown Monthly Costs (Development) Service Resource Quantity Unit Cost Total CloudWatch Alarms Standard alarms 15 $0.10/alarm $1.50 CloudWatch Alarms Composite alarm 1 $0.50/alarm $0.50 CloudWatch Dashboards Dashboards (\u0026gt;3) 1 $3.00/dashboard $3.00 CloudWatch Metrics Standard resolution Included Free $0.00 SNS Email notifications \u0026lt;1000 Free tier $0.00 CloudWatch Logs 7-day retention ~5 GB $0.50/GB $2.50 Total $7.50/month Free Tier Benefits:\nFirst 3 dashboards: Free First 10 alarms: Free (covered) First 1M API requests to CloudWatch: Free SNS email (first 1000): Free Next Steps After deploying the Observability Stack:\nConfirm Email Subscription: Check inbox and confirm SNS subscription\nReview Dashboards: Familiarize yourself with all 4 dashboards\nTest Alarms: Trigger a test alarm to verify notifications\nMonitor Costs: Check daily cost tracking in Overview Dashboard\n‚è≠Ô∏è Deploy Frontend: Continue to 5.10 Deploy to Amplify\n‚è≠Ô∏è Test End-to-End: Test complete application flow and monitor metrics\nüìä Review Metrics: After 24 hours, review all dashboards for baseline metrics\nSummary You have successfully deployed the Observability Stack with:\n1 SNS Topic for alarm notifications\n15+ CloudWatch Alarms for critical metrics\n1 Composite Alarm for overall system health\n4 CloudWatch Dashboards for monitoring\nEmail Notifications configured and confirmed\nKey Achievements:\nComplete visibility into system health Proactive alerting for critical issues Cost tracking and optimization Centralized monitoring dashboards Total Resources: 24 CloudFormation resources\nDeployment Time: ~2-3 minutes\nMonthly Cost: ~$7.50 (dev environment)\nüéâ Congratulations! You have completed all infrastructure stack deployments. Your EveryoneCook platform now has comprehensive monitoring and observability.\nNext: 5.10 Deploy to Amplify to deploy the Next.js frontend application.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.08-test-endpoints/",
	"title": "Test Endpoints End-to-End",
	"tags": [],
	"description": "",
	"content": "T·ªïng quan Sau khi deploy backend th√†nh c√¥ng, b·∫°n c·∫ßn test t·∫•t c·∫£ API endpoints ƒë·ªÉ ƒë·∫£m b·∫£o h·ªá th·ªëng ho·∫°t ƒë·ªông ƒë√∫ng t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi. Workshop n√†y h∆∞·ªõng d·∫´n chi ti·∫øt c√°ch test t·ª´ng module c·ªßa h·ªá th·ªëng EveryoneCook.\nKi·∫øn tr√∫c API D·ª± √°n EveryoneCook s·ª≠ d·ª•ng API Router Pattern v·ªõi c√°c th√†nh ph·∫ßn:\nAPI Gateway: REST API v·ªõi custom domain api-dev.everyonecook.cloud API Router Lambda: Routing requests t·ªõi c√°c module Lambda 5 Module Lambda: auth-user-lambda: Authentication \u0026amp; User Management social-lambda: Posts, Comments, Reactions, Friends, Notifications recipe-ai-lambda: Recipes \u0026amp; AI Features admin-lambda: Admin Dashboard \u0026amp; Content Moderation upload-lambda: File Upload v·ªõi S3 Presigned URLs 4 SQS Queues: Async processing (AI, Image, Analytics, Notifications) WAF: Web Application Firewall b·∫£o v·ªá API Lu·ªìng Test 1. L·∫•y API Endpoint\r2. Test Health Check (Public)\r3. Test User Registration \u0026amp; Verification\r4. Test User Login \u0026amp; Get JWT Token\r5. Test Profile Management\r6. Test Social Features (Posts, Friends, Notifications)\r7. Test Recipe Management\r8. Test AI Features (Recipe Generation, Translation)\r9. Test File Upload (S3 + CloudFront)\r10. Test Admin Features (n·∫øu c√≥ quy·ªÅn admin) B∆∞·ªõc 1: L·∫•y API Endpoint 1. L·∫•y API URL t·ª´ CloudFormation Outputs\n# Get API endpoint t·ª´ Backend Stack $API_ENDPOINT = aws cloudformation describe-stacks ` --stack-name EveryoneCook-dev-Backend ` --query \u0026#39;Stacks[0].Outputs[?OutputKey==`ApiCustomDomain`].OutputValue\u0026#39; ` --output text Write-Host \u0026#34;API Endpoint: $API_ENDPOINT\u0026#34; # Output: https://api-dev.everyonecook.cloud 2. Ho·∫∑c l·∫•y t·ª´ file outputs.json\n# ƒê·ªçc t·ª´ infrastructure/outputs.json cd D:\\Project_AWS\\everyonecook\\infrastructure $outputs = Get-Content outputs.json | ConvertFrom-Json $API_ENDPOINT = $outputs.\u0026#39;EveryoneCook-dev-Backend\u0026#39;.ApiCustomDomain Write-Host \u0026#34;API Endpoint: $API_ENDPOINT\u0026#34; 3. Setup bi·∫øn m√¥i tr∆∞·ªùng\n# Set API endpoint cho PowerShell session $API_ENDPOINT = \u0026#34;https://api-dev.everyonecook.cloud\u0026#34; $HEADERS_JSON = @{\u0026#34;Content-Type\u0026#34;=\u0026#34;application/json\u0026#34;} Write-Host \u0026#34;Environment configured:\u0026#34; Write-Host \u0026#34; API Endpoint: $API_ENDPOINT\u0026#34; B∆∞·ªõc 2: Test Health Check (Public) Health check endpoint kh√¥ng c·∫ßn authentication.\n1. Test v·ªõi PowerShell\n# Test health endpoint $response = Invoke-RestMethod -Uri \u0026#34;$API_ENDPOINT/health\u0026#34; -Method Get $response | ConvertTo-Json # Expected Output: # { # \u0026#34;status\u0026#34;: \u0026#34;healthy\u0026#34;, # \u0026#34;timestamp\u0026#34;: \u0026#34;2025-12-09T10:30:00.000Z\u0026#34;, # \u0026#34;service\u0026#34;: \u0026#34;EveryoneCook API\u0026#34;, # \u0026#34;environment\u0026#34;: \u0026#34;dev\u0026#34; # } 2. Test v·ªõi curl (n·∫øu c√≥ WSL ho·∫∑c Git Bash)\ncurl -X GET \u0026#34;$API_ENDPOINT/health\u0026#34; | jq 3. Verify API Router ho·∫°t ƒë·ªông\n# Check API Router Lambda logs aws logs tail /aws/lambda/everyonecook-dev-api-router --follow ‚úÖ Expected Result: Status 200, response JSON c√≥ \u0026quot;status\u0026quot;: \u0026quot;healthy\u0026quot;\nB∆∞·ªõc 3: Test User Registration 1. L·∫•y User Pool Client ID\n# Get Cognito User Pool Client ID $CLIENT_ID = aws cloudformation describe-stacks ` --stack-name EveryoneCook-dev-Auth ` --query \u0026#39;Stacks[0].Outputs[?OutputKey==`UserPoolClientId`].OutputValue\u0026#39; ` --output text Write-Host \u0026#34;User Pool Client ID: $CLIENT_ID\u0026#34; 2. Register User m·ªõi\n# ƒêƒÉng k√Ω user v·ªõi Cognito (kh√¥ng qua API - tr·ª±c ti·∫øp v·ªõi Cognito) $username = \u0026#34;testuser_$(Get-Random -Maximum 9999)\u0026#34; $email = \u0026#34;test_$username@example.com\u0026#34; $password = \u0026#34;TestPassword123!\u0026#34; aws cognito-idp sign-up ` --client-id $CLIENT_ID ` --username $username ` --password $password ` --user-attributes ` Name=email,Value=$email ` Name=given_name,Value=\u0026#34;Test User\u0026#34; Write-Host \u0026#34;User registered: $username\u0026#34; Write-Host \u0026#34;Email: $email\u0026#34; Write-Host \u0026#34;Password: $password\u0026#34; 3. Verify Pre-Signup Trigger (Lambda Cognito Trigger)\n# Check logs c·ªßa Pre-Signup trigger aws logs tail /aws/lambda/EveryoneCook-dev-PreSignup --since 5m ‚úÖ Expected:\nCognito tr·∫£ v·ªÅ success message Pre-Signup trigger logs kh√¥ng c√≥ error B∆∞·ªõc 4: Verify Email \u0026amp; Confirm User 1. L·∫•y Confirmation Code\n# Trong m√¥i tr∆∞·ªùng dev, c√≥ th·ªÉ l·∫•y code t·ª´ email ho·∫∑c d√πng admin command # C√°ch 1: Check email (n·∫øu d√πng real email) # C√°ch 2: Admin confirm (cho testing) aws cognito-idp admin-confirm-sign-up ` --user-pool-id ap-southeast-1_PKoL34PF0 ` --username $username Write-Host \u0026#34;User confirmed: $username\u0026#34; 2. Verify Post-Confirmation Trigger\nPost-Confirmation trigger s·∫Ω t·ª± ƒë·ªông t·∫°o user profile trong DynamoDB.\n# Check DynamoDB - User profile ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông aws dynamodb get-item ` --table-name EveryoneCook-dev ` --key \u0026#34;{\\\u0026#34;PK\\\u0026#34;:{\\\u0026#34;S\\\u0026#34;:\\\u0026#34;USER#$username\\\u0026#34;},\\\u0026#34;SK\\\u0026#34;:{\\\u0026#34;S\\\u0026#34;:\\\u0026#34;PROFILE\\\u0026#34;}}\u0026#34; # Expected: User profile v·ªõi c√°c fields: # - userId (Cognito sub ID) # - email # - fullName # - createdAt # - updatedAt 3. Check Post-Confirmation Lambda logs\naws logs tail /aws/lambda/EveryoneCook-dev-PostConfirmation --since 5m ‚úÖ Expected: User profile ƒë∆∞·ª£c t·∫°o trong DynamoDB table\nB∆∞·ªõc 5: Test User Login \u0026amp; Get JWT Token 1. Login ƒë·ªÉ l·∫•y JWT tokens\n# Sign in v·ªõi Cognito $authResult = aws cognito-idp initiate-auth ` --client-id $CLIENT_ID ` --auth-flow USER_PASSWORD_AUTH ` --auth-parameters USERNAME=$username,PASSWORD=$password ` | ConvertFrom-Json # Extract tokens $ID_TOKEN = $authResult.AuthenticationResult.IdToken $ACCESS_TOKEN = $authResult.AuthenticationResult.AccessToken $REFRESH_TOKEN = $authResult.AuthenticationResult.RefreshToken Write-Host \u0026#34;Login successful!\u0026#34; Write-Host \u0026#34;ID Token length: $($ID_TOKEN.Length)\u0026#34; 2. Verify Post-Authentication Trigger\nPost-Authentication trigger update lastLoginAt trong DynamoDB.\n# Check lastLoginAt updated aws dynamodb get-item ` --table-name EveryoneCook-dev ` --key \u0026#34;{\\\u0026#34;PK\\\u0026#34;:{\\\u0026#34;S\\\u0026#34;:\\\u0026#34;USER#$username\\\u0026#34;},\\\u0026#34;SK\\\u0026#34;:{\\\u0026#34;S\\\u0026#34;:\\\u0026#34;PROFILE\\\u0026#34;}}\u0026#34; ` --projection-expression \u0026#34;lastLoginAt\u0026#34; 3. Setup Authorization Header\n# Create headers with JWT token $HEADERS_AUTH = @{ \u0026#34;Content-Type\u0026#34; = \u0026#34;application/json\u0026#34; \u0026#34;Authorization\u0026#34; = \u0026#34;Bearer $ID_TOKEN\u0026#34; } ‚úÖ Expected: Login th√†nh c√¥ng, nh·∫≠n ƒë∆∞·ª£c JWT tokens\nB∆∞·ªõc 6: Test Profile Management Endpoint: /users/me, /users/profile\n1. Get Current User Profile\n# GET /users/me $response = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/users/me\u0026#34; ` -Method Get ` -Headers $HEADERS_AUTH $response | ConvertTo-Json -Depth 5 # Expected Response: # { # \u0026#34;userId\u0026#34;: \u0026#34;...\u0026#34;, # \u0026#34;username\u0026#34;: \u0026#34;testuser_1234\u0026#34;, # \u0026#34;email\u0026#34;: \u0026#34;test_testuser_1234@example.com\u0026#34;, # \u0026#34;fullName\u0026#34;: \u0026#34;Test User\u0026#34;, # \u0026#34;birthday\u0026#34;: null, # \u0026#34;gender\u0026#34;: null, # \u0026#34;country\u0026#34;: null, # \u0026#34;createdAt\u0026#34;: \u0026#34;2025-12-09T10:30:00.000Z\u0026#34;, # \u0026#34;lastLoginAt\u0026#34;: \u0026#34;2025-12-09T11:00:00.000Z\u0026#34; # } 2. Update Profile (Onboarding)\n# PUT /users/profile - Complete onboarding $profileUpdate = @{ birthday = \u0026#34;1990-01-01\u0026#34; gender = \u0026#34;male\u0026#34; country = \u0026#34;Vietnam\u0026#34; bio = \u0026#34;Test user for EveryoneCook platform\u0026#34; } | ConvertTo-Json $response = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/users/profile\u0026#34; ` -Method Put ` -Headers $HEADERS_AUTH ` -Body $profileUpdate $response | ConvertTo-Json 3. Get Privacy Settings\n# GET /users/profile/privacy $privacy = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/users/profile/privacy\u0026#34; ` -Method Get ` -Headers $HEADERS_AUTH $privacy | ConvertTo-Json 4. Update Privacy Settings\n# PUT /users/profile/privacy $privacyUpdate = @{ profileVisibility = \u0026#34;public\u0026#34; showEmail = $false showBirthday = $false allowFriendRequests = $true } | ConvertTo-Json Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/users/profile/privacy\u0026#34; ` -Method Put ` -Headers $HEADERS_AUTH ` -Body $privacyUpdate ‚úÖ Expected: Profile ƒë∆∞·ª£c update th√†nh c√¥ng trong DynamoDB\nB∆∞·ªõc 7: Test Social Features - Posts Endpoints: /posts, /posts/{postId}\n1. Create Post\n# POST /posts $newPost = @{ content = \u0026#34;My first post on EveryoneCook! Testing the platform üç≥\u0026#34; visibility = \u0026#34;public\u0026#34; type = \u0026#34;text\u0026#34; } | ConvertTo-Json $postResponse = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/posts\u0026#34; ` -Method Post ` -Headers $HEADERS_AUTH ` -Body $newPost $POST_ID = $postResponse.postId Write-Host \u0026#34;Created Post ID: $POST_ID\u0026#34; $postResponse | ConvertTo-Json 2. Get All Posts (Feed)\n# GET /posts - Get all posts $posts = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/posts?limit=10\u0026#34; ` -Method Get ` -Headers $HEADERS_AUTH Write-Host \u0026#34;Found $($posts.items.Count) posts\u0026#34; $posts.items | ConvertTo-Json -Depth 3 3. Get Specific Post\n# GET /posts/{postId} $post = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/posts/$POST_ID\u0026#34; ` -Method Get ` -Headers $HEADERS_AUTH $post | ConvertTo-Json 4. Like Post\n# POST /posts/{postId}/like Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/posts/$POST_ID/like\u0026#34; ` -Method Post ` -Headers $HEADERS_AUTH Write-Host \u0026#34;Post liked successfully\u0026#34; 5. Add Comment\n# POST /posts/{postId}/comments $comment = @{ content = \u0026#34;Great post! üëç\u0026#34; } | ConvertTo-Json $commentResponse = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/posts/$POST_ID/comments\u0026#34; ` -Method Post ` -Headers $HEADERS_AUTH ` -Body $comment $COMMENT_ID = $commentResponse.commentId Write-Host \u0026#34;Comment ID: $COMMENT_ID\u0026#34; 6. Get Post Comments\n# GET /posts/{postId}/comments $comments = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/posts/$POST_ID/comments\u0026#34; ` -Method Get ` -Headers $HEADERS_AUTH $comments | ConvertTo-Json -Depth 3 ‚úÖ Expected: Posts, likes, comments ƒë∆∞·ª£c l∆∞u trong DynamoDB\nB∆∞·ªõc 8: Test Social Features - Friends Endpoints: /friends/*\n1. Search Users\n# GET /users/search?q=test $users = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/users/search?q=test\u0026amp;limit=10\u0026#34; ` -Method Get ` -Headers $HEADERS_AUTH $users | ConvertTo-Json 2. Send Friend Request (c·∫ßn 2 users)\n# POST /friends/{userId}/request # Gi·∫£ s·ª≠ c√≥ USER_ID c·ªßa user kh√°c $TARGET_USER_ID = \u0026#34;another-user-id\u0026#34; Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/friends/$TARGET_USER_ID/request\u0026#34; ` -Method Post ` -Headers $HEADERS_AUTH Write-Host \u0026#34;Friend request sent\u0026#34; 3. Get Friend Requests\n# GET /friends/requests $requests = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/friends/requests\u0026#34; ` -Method Get ` -Headers $HEADERS_AUTH $requests | ConvertTo-Json ‚úÖ Expected: Friend requests ƒë∆∞·ª£c t·∫°o v·ªõi status \u0026ldquo;pending\u0026rdquo;\nB∆∞·ªõc 9: Test Recipe Management Endpoints: /recipes, /recipes/{recipeId}\n1. Create Recipe\n# POST /recipes $newRecipe = @{ title = \u0026#34;Ph·ªü B√≤ H√† N·ªôi\u0026#34; description = \u0026#34;Traditional Vietnamese beef noodle soup\u0026#34; ingredients = @( @{ name = \u0026#34;beef bones\u0026#34;; amount = \u0026#34;2\u0026#34;; unit = \u0026#34;kg\u0026#34; } @{ name = \u0026#34;rice noodles\u0026#34;; amount = \u0026#34;500\u0026#34;; unit = \u0026#34;g\u0026#34; } @{ name = \u0026#34;ginger\u0026#34;; amount = \u0026#34;1\u0026#34;; unit = \u0026#34;piece\u0026#34; } @{ name = \u0026#34;star anise\u0026#34;; amount = \u0026#34;3\u0026#34;; unit = \u0026#34;pieces\u0026#34; } ) instructions = @( \u0026#34;Boil beef bones for 2-3 hours to make broth\u0026#34; \u0026#34;Add spices (ginger, star anise, cinnamon) and simmer\u0026#34; \u0026#34;Prepare rice noodles separately\u0026#34; \u0026#34;Serve noodles with broth and garnish with herbs\u0026#34; ) cuisine = \u0026#34;Vietnamese\u0026#34; difficulty = \u0026#34;medium\u0026#34; prepTime = 30 cookTime = 180 servings = 4 } | ConvertTo-Json -Depth 5 $recipeResponse = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/recipes\u0026#34; ` -Method Post ` -Headers $HEADERS_AUTH ` -Body $newRecipe $RECIPE_ID = $recipeResponse.recipeId Write-Host \u0026#34;Created Recipe ID: $RECIPE_ID\u0026#34; $recipeResponse | ConvertTo-Json -Depth 5 2. Get User\u0026rsquo;s Recipes\n# GET /users/{userId}/recipes $userId = $authResult.AuthenticationResult.AccessToken | ForEach-Object { [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(($_.Split(\u0026#39;.\u0026#39;)[1]))) } | ConvertFrom-Json | Select-Object -ExpandProperty sub $recipes = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/users/$userId/recipes\u0026#34; ` -Method Get ` -Headers $HEADERS_AUTH $recipes | ConvertTo-Json -Depth 3 3. Search Recipes\n# POST /recipes/search $searchQuery = @{ query = \u0026#34;ph·ªü\u0026#34; filters = @{ cuisine = \u0026#34;Vietnamese\u0026#34; difficulty = \u0026#34;medium\u0026#34; } limit = 10 } | ConvertTo-Json $searchResults = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/recipes/search\u0026#34; ` -Method Post ` -Headers $HEADERS_AUTH ` -Body $searchQuery $searchResults | ConvertTo-Json -Depth 3 ‚úÖ Expected: Recipes ƒë∆∞·ª£c l∆∞u trong DynamoDB v·ªõi proper structure\nB∆∞·ªõc 10: Test AI Features (Bedrock) Endpoints: /recipes/generate-ai, /ai/nutrition, /dictionary/{ingredient}\n1. Generate Recipe with AI\n# POST /recipes/generate-ai $aiRequest = @{ ingredients = @(\u0026#34;chicken\u0026#34;, \u0026#34;rice\u0026#34;, \u0026#34;vegetables\u0026#34;, \u0026#34;fish sauce\u0026#34;) cuisine = \u0026#34;Vietnamese\u0026#34; dietaryRestrictions = @(\u0026#34;gluten-free\u0026#34;) servings = 4 difficulty = \u0026#34;medium\u0026#34; } | ConvertTo-Json Write-Host \u0026#34;Generating recipe with AI... (this takes 5-10 seconds)\u0026#34; $aiRecipe = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/recipes/generate-ai\u0026#34; ` -Method Post ` -Headers $HEADERS_AUTH ` -Body $aiRequest $aiRecipe | ConvertTo-Json -Depth 5 # Expected: AI-generated recipe with Vietnamese ingredient names # Uses Amazon Bedrock Claude model 2. Get Nutrition Analysis\n# POST /ai/nutrition $nutritionRequest = @{ ingredients = @( @{ name = \u0026#34;chicken breast\u0026#34;; amount = \u0026#34;200\u0026#34;; unit = \u0026#34;g\u0026#34; } @{ name = \u0026#34;rice\u0026#34;; amount = \u0026#34;100\u0026#34;; unit = \u0026#34;g\u0026#34; } ) } | ConvertTo-Json $nutrition = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/ai/nutrition\u0026#34; ` -Method Post ` -Headers $HEADERS_AUTH ` -Body $nutritionRequest $nutrition | ConvertTo-Json 3. Translate Ingredient (Vietnamese Dictionary)\n# GET /dictionary/{ingredient} $translation = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/dictionary/tomato\u0026#34; ` -Method Get ` -Headers $HEADERS_AUTH Write-Host \u0026#34;Translation: $($translation.vietnamese)\u0026#34; # Expected: { \u0026#34;ingredient\u0026#34;: \u0026#34;tomato\u0026#34;, \u0026#34;vietnamese\u0026#34;: \u0026#34;c√† chua\u0026#34; } ‚úÖ Expected:\nAI recipe generation m·∫•t 5-10 gi√¢y Response c√≥ Vietnamese ingredient names Bedrock Lambda ƒë∆∞·ª£c invoke B∆∞·ªõc 11: Test File Upload (S3 + CloudFront) Endpoint: /upload/presigned-url\n1. Request Presigned URL\n# POST /upload/presigned-url $uploadRequest = @{ fileType = \u0026#34;avatar\u0026#34; fileName = \u0026#34;test-avatar.jpg\u0026#34; contentType = \u0026#34;image/jpeg\u0026#34; fileSize = 1024000 # 1MB } | ConvertTo-Json $uploadResponse = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/upload/presigned-url\u0026#34; ` -Method Post ` -Headers $HEADERS_AUTH ` -Body $uploadRequest $PRESIGNED_URL = $uploadResponse.url $UPLOAD_KEY = $uploadResponse.key Write-Host \u0026#34;Presigned URL: $PRESIGNED_URL\u0026#34; Write-Host \u0026#34;Upload Key: $UPLOAD_KEY\u0026#34; 2. Upload File to S3\n# Create test image file $testImage = \u0026#34;D:\\test-avatar.jpg\u0026#34; # (T·∫°o file test image ho·∫∑c d√πng file c√≥ s·∫µn) # Upload file using presigned URL Invoke-RestMethod ` -Uri $PRESIGNED_URL ` -Method Put ` -InFile $testImage ` -ContentType \u0026#34;image/jpeg\u0026#34; Write-Host \u0026#34;File uploaded to S3 successfully\u0026#34; 3. Access via CloudFront CDN\n# Get CloudFront distribution domain $CDN_DOMAIN = \u0026#34;d2shrpzup69rju.cloudfront.net\u0026#34; # T·ª´ outputs.json # Access file via CloudFront $fileUrl = \u0026#34;https://$CDN_DOMAIN/$UPLOAD_KEY\u0026#34; Invoke-WebRequest -Uri $fileUrl -Method Head # Check caching headers # First request: X-Cache: Miss from cloudfront # Second request: X-Cache: Hit from cloudfront ‚úÖ Expected: File ƒë∆∞·ª£c upload l√™n S3 v√† serve qua CloudFront\nB∆∞·ªõc 12: Test Admin Features (Requires Admin Role) Endpoints: /admin/*\n1. Get System Stats\n# GET /admin/stats $stats = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/admin/stats\u0026#34; ` -Method Get ` -Headers $HEADERS_AUTH $stats | ConvertTo-Json # Expected (n·∫øu c√≥ admin role): # { # \u0026#34;totalUsers\u0026#34;: 123, # \u0026#34;totalPosts\u0026#34;: 456, # \u0026#34;totalRecipes\u0026#34;: 789, # \u0026#34;activeUsers\u0026#34;: 45 # } 2. Get All Users\n# GET /admin/users $allUsers = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/admin/users?limit=20\u0026#34; ` -Method Get ` -Headers $HEADERS_AUTH $allUsers | ConvertTo-Json 3. Get Reported Posts\n# GET /admin/posts/reported $reportedPosts = Invoke-RestMethod ` -Uri \u0026#34;$API_ENDPOINT/admin/posts/reported\u0026#34; ` -Method Get ` -Headers $HEADERS_AUTH $reportedPosts | ConvertTo-Json ‚ö†Ô∏è Note: Admin endpoints require user c√≥ group \u0026ldquo;Admins\u0026rdquo; trong Cognito User Pool\nB∆∞·ªõc 13: Verify Async Processing (SQS Queues) 1. Check SQS Queues\n# List all queues aws sqs list-queues --queue-name-prefix everyonecook-dev # Get AI Queue attributes $AI_QUEUE_URL = \u0026#34;https://sqs.ap-southeast-1.amazonaws.com/616580903213/everyonecook-dev-ai-queue\u0026#34; aws sqs get-queue-attributes ` --queue-url $AI_QUEUE_URL ` --attribute-names ApproximateNumberOfMessages,ApproximateNumberOfMessagesNotVisible 2. Monitor Worker Lambdas\n# Check Image Processing Worker logs aws logs tail /aws/lambda/everyonecook-dev-image-worker --follow # Check AI Worker logs (for recipe generation) aws logs tail /aws/lambda/everyonecook-dev-ai-worker --follow ‚úÖ Expected: Messages ƒë∆∞·ª£c process b·ªüi worker Lambdas\nTesting Checklist S·ª≠ d·ª•ng checklist n√†y ƒë·ªÉ track progress:\nPublic Endpoints GET /health - Health check responds GET /status - Status check responds Authentication \u0026amp; User Management User registration v·ªõi Cognito works Email verification/confirmation works User login successful, nh·∫≠n JWT tokens GET /users/me - Get current user profile PUT /users/profile - Update profile GET /users/profile/privacy - Get privacy settings PUT /users/profile/privacy - Update privacy settings Social Features POST /posts - Create post GET /posts - Get posts feed GET /posts/{postId} - Get specific post POST /posts/{postId}/like - Like post POST /posts/{postId}/comments - Add comment GET /posts/{postId}/comments - Get comments POST /friends/{userId}/request - Send friend request GET /friends/requests - Get friend requests GET /notifications - Get notifications Recipe Management POST /recipes - Create recipe GET /recipes - Get all recipes GET /recipes/{recipeId} - Get specific recipe POST /recipes/search - Search recipes AI Features POST /recipes/generate-ai - AI recipe generation (Bedrock) POST /ai/nutrition - Nutrition analysis GET /dictionary/{ingredient} - Ingredient translation File Upload POST /upload/presigned-url - Get presigned URL Upload file to S3 using presigned URL Access file via CloudFront CDN Verify CloudFront caching (Miss ‚Üí Hit) Admin Features (if admin) GET /admin/stats - Get system stats GET /admin/users - List all users GET /admin/posts/reported - Get reported content Infrastructure All Lambda functions execute without errors SQS queues process messages correctly CloudWatch logs show proper execution DynamoDB items created correctly WAF rules protecting API Gateway Performance Benchmarks Expected Response Times:\nEndpoint Expected Time Notes GET /health \u0026lt; 50ms Direct response POST /auth/login \u0026lt; 200ms Cognito validation GET /users/me \u0026lt; 100ms DynamoDB single query POST /posts \u0026lt; 300ms DynamoDB write + notifications GET /posts \u0026lt; 500ms DynamoDB query with pagination POST /recipes/generate-ai 5-10 seconds Bedrock AI generation POST /upload/presigned-url \u0026lt; 100ms S3 presigned URL generation POST /recipes/search \u0026lt; 200ms DynamoDB GSI query Troubleshooting Common Issues 1. 401 Unauthorized # Verify JWT token not expired $ID_TOKEN = \u0026#34;your-token-here\u0026#34; $parts = $ID_TOKEN.Split(\u0026#39;.\u0026#39;) $payload = [System.Text.Encoding]::UTF8.GetString( [System.Convert]::FromBase64String($parts[1]) ) | ConvertFrom-Json $exp = [DateTimeOffset]::FromUnixTimeSeconds($payload.exp).DateTime Write-Host \u0026#34;Token expires at: $exp\u0026#34; # If expired, login again 2. 403 Forbidden (WAF Block) # Check WAF logs aws wafv2 get-web-acl ` --name EveryoneCook-API-WAF-dev ` --scope REGIONAL ` --region ap-southeast-1 # Check if IP blocked 3. 500 Internal Server Error # Check Lambda function logs aws logs tail /aws/lambda/everyonecook-dev-api-router --follow aws logs tail /aws/lambda/everyonecook-dev-social --follow # Check DynamoDB table aws dynamodb describe-table --table-name EveryoneCook-dev 4. Slow AI Recipe Generation # Check Bedrock model availability aws bedrock list-foundation-models --region us-east-1 # Check AI Queue aws sqs get-queue-attributes ` --queue-url $AI_QUEUE_URL ` --attribute-names All Next Steps Sau khi test th√†nh c√¥ng t·∫•t c·∫£ endpoints:\n‚úÖ Verify Infrastructure: T·∫•t c·∫£ AWS resources ho·∫°t ƒë·ªông ƒë√∫ng üìä Monitor CloudWatch: Check metrics v√† logs üîí Security Review: Verify WAF rules v√† Cognito auth üìù Document API: Update API documentation n·∫øu c·∫ßn üöÄ Deploy Frontend: Proceed to frontend deployment üì¶ Version Control: Commit code v√† push to GitLab (next step) Proceed to: 5.09 - Push to GitLab\n2. Confirm User\n# Confirm user with code aws cognito-idp confirm-sign-up \\ --client-id $CLIENT_ID \\ --username testuser \\ --confirmation-code 123456 3. Verify Post-Confirmation Trigger\n# Check if user profile was created in DynamoDB aws dynamodb get-item \\ --table-name EveryoneCook-dev \\ --key \u0026#39;{\u0026#34;PK\u0026#34;:{\u0026#34;S\u0026#34;:\u0026#34;USER#testuser\u0026#34;},\u0026#34;SK\u0026#34;:{\u0026#34;S\u0026#34;:\u0026#34;PROFILE\u0026#34;}}\u0026#39; # Should return user profile with: # - PK: USER#testuser # - SK: PROFILE # - userId: cognito-sub-id # - email: test@example.com # - fullName: Test User # - birthday: null # - gender: null # - country: null Step 5: Test User Login 1. Sign In\n# Sign in to get tokens TOKENS=$(aws cognito-idp initiate-auth \\ --client-id $CLIENT_ID \\ --auth-flow USER_PASSWORD_AUTH \\ --auth-parameters USERNAME=testuser,PASSWORD=TestPassword123!) # Extract tokens ACCESS_TOKEN=$(echo $TOKENS | jq -r \u0026#39;.AuthenticationResult.AccessToken\u0026#39;) ID_TOKEN=$(echo $TOKENS | jq -r \u0026#39;.AuthenticationResult.IdToken\u0026#39;) REFRESH_TOKEN=$(echo $TOKENS | jq -r \u0026#39;.AuthenticationResult.RefreshToken\u0026#39;) echo \u0026#34;ID Token: $ID_TOKEN\u0026#34; 2. Verify Post-Authentication Trigger\n# Check if lastLoginAt was updated aws dynamodb get-item \\ --table-name EveryoneCook-dev \\ --key \u0026#39;{\u0026#34;PK\u0026#34;:{\u0026#34;S\u0026#34;:\u0026#34;USER#testuser\u0026#34;},\u0026#34;SK\u0026#34;:{\u0026#34;S\u0026#34;:\u0026#34;PROFILE\u0026#34;}}\u0026#39; \\ --projection-expression \u0026#34;lastLoginAt\u0026#34; Step 6: Test Profile Management 1. Get Profile\n# Get user profile curl -X GET \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ $API_ENDPOINT/auth/profile # Expected: User profile data 2. Update Profile\n# Update profile (onboarding) curl -X PUT \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;birthday\u0026#34;: \u0026#34;1990-01-01\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;US\u0026#34; }\u0026#39; \\ $API_ENDPOINT/auth/profile # Expected: Updated profile 3. Verify Update in DynamoDB\n# Check updated profile aws dynamodb get-item \\ --table-name EveryoneCook-dev \\ --key \u0026#39;{\u0026#34;PK\u0026#34;:{\u0026#34;S\u0026#34;:\u0026#34;USER#testuser\u0026#34;},\u0026#34;SK\u0026#34;:{\u0026#34;S\u0026#34;:\u0026#34;PROFILE\u0026#34;}}\u0026#39; # Should show birthday, gender, country updated Step 7: Test Social Features 1. Create Post\n# Create a post POST_RESPONSE=$(curl -X POST \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;content\u0026#34;: \u0026#34;My first post on EveryoneCook!\u0026#34;, \u0026#34;visibility\u0026#34;: \u0026#34;public\u0026#34; }\u0026#39; \\ $API_ENDPOINT/social/posts) POST_ID=$(echo $POST_RESPONSE | jq -r \u0026#39;.postId\u0026#39;) echo \u0026#34;Created post: $POST_ID\u0026#34; 2. Get Posts Feed\n# Get posts curl -X GET \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ $API_ENDPOINT/social/posts # Expected: Array of posts including the one just created 3. Like Post\n# Like the post curl -X POST \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ $API_ENDPOINT/social/posts/$POST_ID/like # Expected: Success message 4. Comment on Post\n# Add comment curl -X POST \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;content\u0026#34;:\u0026#34;Great post!\u0026#34;}\u0026#39; \\ $API_ENDPOINT/social/posts/$POST_ID/comment # Expected: Comment created Step 8: Test Recipe Features 1. Create Recipe\n# Create a recipe RECIPE_RESPONSE=$(curl -X POST \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;title\u0026#34;: \u0026#34;Pho Bo (Vietnamese Beef Noodle Soup)\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Traditional Vietnamese beef noodle soup\u0026#34;, \u0026#34;ingredients\u0026#34;: [ {\u0026#34;name\u0026#34;: \u0026#34;beef bones\u0026#34;, \u0026#34;amount\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;kg\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;rice noodles\u0026#34;, \u0026#34;amount\u0026#34;: \u0026#34;500\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;g\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;ginger\u0026#34;, \u0026#34;amount\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;piece\u0026#34;} ], \u0026#34;instructions\u0026#34;: [ \u0026#34;Boil beef bones for 2 hours\u0026#34;, \u0026#34;Add spices and simmer\u0026#34;, \u0026#34;Prepare noodles and serve\u0026#34; ], \u0026#34;cuisine\u0026#34;: \u0026#34;Vietnamese\u0026#34;, \u0026#34;difficulty\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;prepTime\u0026#34;: 30, \u0026#34;cookTime\u0026#34;: 120 }\u0026#39; \\ $API_ENDPOINT/recipes) RECIPE_ID=$(echo $RECIPE_RESPONSE | jq -r \u0026#39;.recipeId\u0026#39;) echo \u0026#34;Created recipe: $RECIPE_ID\u0026#34; 2. Get Recipes\n# Get all recipes curl -X GET \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ $API_ENDPOINT/recipes # Expected: Array of recipes 3. Get Recipe by ID\n# Get specific recipe curl -X GET \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ $API_ENDPOINT/recipes/$RECIPE_ID # Expected: Recipe details Step 9: Test AI Features 1. Generate Recipe with AI\n# Generate recipe using Bedrock curl -X POST \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;ingredients\u0026#34;: [\u0026#34;chicken\u0026#34;, \u0026#34;rice\u0026#34;, \u0026#34;vegetables\u0026#34;], \u0026#34;cuisine\u0026#34;: \u0026#34;Vietnamese\u0026#34;, \u0026#34;dietaryRestrictions\u0026#34;: [\u0026#34;gluten-free\u0026#34;], \u0026#34;servings\u0026#34;: 4 }\u0026#39; \\ $API_ENDPOINT/ai/generate-recipe # Expected: AI-generated recipe (takes 5-10 seconds) # Response includes Vietnamese ingredient names 2. Translate Ingredient\n# Translate ingredient to Vietnamese curl -X POST \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;ingredient\u0026#34;: \u0026#34;tomato\u0026#34;, \u0026#34;targetLanguage\u0026#34;: \u0026#34;vi\u0026#34; }\u0026#39; \\ $API_ENDPOINT/ai/translate # Expected: {\u0026#34;translation\u0026#34;: \u0026#34;c√† chua\u0026#34;, \u0026#34;confidence\u0026#34;: 0.99} Step 10: Test File Upload 1. Request Pre-signed URL\n# Get pre-signed URL for avatar upload UPLOAD_RESPONSE=$(curl -X POST \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;fileType\u0026#34;: \u0026#34;avatar\u0026#34;, \u0026#34;fileName\u0026#34;: \u0026#34;avatar.jpg\u0026#34;, \u0026#34;contentType\u0026#34;: \u0026#34;image/jpeg\u0026#34;, \u0026#34;fileSize\u0026#34;: 1024000 }\u0026#39; \\ $API_ENDPOINT/upload/presigned-url) PRESIGNED_URL=$(echo $UPLOAD_RESPONSE | jq -r \u0026#39;.url\u0026#39;) UPLOAD_KEY=$(echo $UPLOAD_RESPONSE | jq -r \u0026#39;.key\u0026#39;) echo \u0026#34;Pre-signed URL: $PRESIGNED_URL\u0026#34; echo \u0026#34;Upload Key: $UPLOAD_KEY\u0026#34; 2. Upload File to S3\n# Create test image echo \u0026#34;Test image content\u0026#34; \u0026gt; test-avatar.jpg # Upload using pre-signed URL curl -X PUT \\ -H \u0026#34;Content-Type: image/jpeg\u0026#34; \\ --upload-file test-avatar.jpg \\ \u0026#34;$PRESIGNED_URL\u0026#34; # Expected: 200 OK 3. Mark Upload Complete\n# Notify backend that upload is complete curl -X POST \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#34;{\\\u0026#34;key\\\u0026#34;:\\\u0026#34;$UPLOAD_KEY\\\u0026#34;}\u0026#34; \\ $API_ENDPOINT/upload/complete # Expected: Success message 4. Access via CloudFront\n# Access file via CloudFront CDN curl -I https://cdn.everyonecook.cloud/$UPLOAD_KEY # First request: X-Cache: Miss from cloudfront # Second request: X-Cache: Hit from cloudfront Step 11: Test Search (OpenSearch) If OpenSearch is enabled:\n# Search recipes with Vietnamese query curl -X POST \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;query\u0026#34;: \u0026#34;ph·ªü b√≤\u0026#34;, \u0026#34;filters\u0026#34;: { \u0026#34;cuisine\u0026#34;: \u0026#34;Vietnamese\u0026#34;, \u0026#34;difficulty\u0026#34;: \u0026#34;medium\u0026#34; }, \u0026#34;limit\u0026#34;: 10 }\u0026#39; \\ $API_ENDPOINT/ai/search # Expected: Array of matching recipes # Vietnamese analyzer handles: \u0026#34;ph·ªü b√≤\u0026#34; = \u0026#34;pho bo\u0026#34; = \u0026#34;beef noodle soup\u0026#34; Step 12: Test Admin Features 1. List Users (Admin Only)\n# Get all users (requires admin role) curl -X GET \\ -H \u0026#34;Authorization: Bearer $ID_TOKEN\u0026#34; \\ $API_ENDPOINT/admin/users # Expected: Array of users or 403 Forbidden if not admin Step 13: Verify Async Processing 1. Check SQS Queue Processing\n# Send message to SearchIndex queue QUEUE_URL=$(aws sqs list-queues \\ --queue-name-prefix EveryoneCook-dev-SearchIndexQueue \\ | jq -r \u0026#39;.QueueUrls[0]\u0026#39;) aws sqs send-message \\ --queue-url $QUEUE_URL \\ --message-body \u0026#34;{ \\\u0026#34;eventName\\\u0026#34;: \\\u0026#34;INSERT\\\u0026#34;, \\\u0026#34;tableName\\\u0026#34;: \\\u0026#34;recipes\\\u0026#34;, \\\u0026#34;keys\\\u0026#34;: {\\\u0026#34;PK\\\u0026#34;: \\\u0026#34;USER#testuser\\\u0026#34;, \\\u0026#34;SK\\\u0026#34;: \\\u0026#34;RECIPE#$RECIPE_ID\\\u0026#34;}, \\\u0026#34;newImage\\\u0026#34;: { \\\u0026#34;title\\\u0026#34;: \\\u0026#34;Pho Bo\\\u0026#34;, \\\u0026#34;ingredients\\\u0026#34;: [\\\u0026#34;beef\\\u0026#34;, \\\u0026#34;noodles\\\u0026#34;], \\\u0026#34;cuisine\\\u0026#34;: \\\u0026#34;Vietnamese\\\u0026#34; } }\u0026#34; # Check worker logs aws logs tail /aws/lambda/EveryoneCook-dev-SearchSyncWorker --follow Testing Checklist Health check responds User registration works Email verification works User login successful Profile CRUD operations work Posts can be created Posts can be liked Comments can be added Recipes can be created AI recipe generation works Ingredient translation works File upload to S3 works CloudFront serves files Search works (if OpenSearch enabled) SQS queues process messages All Lambda functions execute without errors Performance Benchmarks Expected Response Times:\nHealth check: \u0026lt; 50ms User login: \u0026lt; 200ms Get profile: \u0026lt; 100ms Create post: \u0026lt; 300ms Get posts feed: \u0026lt; 500ms AI recipe generation: 5-10 seconds File upload (pre-signed URL): \u0026lt; 100ms Search query: \u0026lt; 200ms Next Steps Once all tests pass, proceed to Push to GitLab to version control your code and set up CI/CD.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/1.8-week8/",
	"title": "Week 8 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 8 Objectives: Cost Optimization: Master cost-saving pricing models such as Savings Plans and Reserved Instances (RI) for EC2 and RDS. Resource Optimization: Use AWS Compute Optimizer and CloudWatch to identify and right-size resources. Cost Management \u0026amp; Visualization: Analyze detailed cost reports using AWS Cost Explorer and understand data transfer costs. Knowledge Assessment: Complete a midterm exam simulating the AWS Certified Solutions Architect certification. Tasks to be carried out this week: Day Task Start Date Completion Date Reference Material 2 Cost Saving Models - Learn and differentiate between Savings Plans (Compute/EC2) and Reserved Instances. - Analyze Savings Plan Recommendations. - Practice purchasing Savings Plans and Reserved DB Instances. 10/27/2025 10/27/2025 https://000042.awsstudygroup.com/ 3 Resource Optimization (Right Sizing) - Install CloudWatch Agent to collect memory (RAM) metrics. - Configure IAM Role for CloudWatch and Compute Optimizer. - Use AWS Compute Optimizer to receive recommendations for optimal instance types. - Apply EC2 Resource Optimization Best Practices. 10/28/2025 10/28/2025 https://000032.awsstudygroup.com/ 4 Basic Cost Visualization \u0026amp; Analysis - Use Cost Explorer to view costs by Service and Account. - Monitor Coverage and Utilization of Savings Plan/RI. - Analyze infrastructure Elasticity. 10/29/2025 10/29/2025 https://000034.awsstudygroup.com/ 5 Advanced Cost Analysis \u0026amp; Review - Create Custom Reports for EC2. - Analyze Data Transfer costs. - Additional Research: Set up AWS Cost \u0026amp; Usage Report (CUR) and query with Amazon Athena (Theory). - Systematize knowledge from the past 8 weeks to prepare for the exam. 10/30/2025 10/30/2025 https://000034.awsstudygroup.com/ SAA Knowledge Review 6 Midterm Exam - Complete the AWS Certified Solutions Architect - Associate (SAA-C03) practice exam. - Format: 65 multiple-choice questions / 130 minutes. - Content covered: IAM, VPC, EC2, S3, RDS, HA/Scaling, Cost Optimization. - Evaluate results and review knowledge gaps. 10/31/2025 10/31/2025 AWS SAA Practice Exam Week 8 Achievements Cost Optimization Strategy Mastered the differences between Savings Plans (more flexible) and Reserved Instances (traditional), enabling informed purchasing decisions for each workload type. Learned to use the Recommendations tool to identify optimal cost commitment levels based on usage history. Successfully applied Reserved Instances to RDS databases to reduce long-term operational costs. System Resource Optimization Successfully deployed CloudWatch Agent to collect custom metrics (such as Memory usage) that CloudWatch doesn\u0026rsquo;t provide by default, enabling accurate instance performance assessment. Used AWS Compute Optimizer to identify over-provisioned or under-provisioned resources and performed appropriate Right Sizing adjustments. Cloud Financial Management (FinOps) Mastered AWS Cost Explorer to visualize cash flow and usage costs by day, month, or specific services. Created Custom Reports to track Data Transfer costs - a hidden cost that is often overlooked. Understood how to monitor Savings Plan/RI effectiveness through Coverage and Utilization charts. Competency Assessment (Midterm) Completed the AWS Certified Solutions Architect simulation exam. Reviewed all foundational knowledge across the 4 main pillars: Compute, Storage, Networking, and Database. Identified weak points that need improvement in the following weeks (e.g., Hybrid Cloud scenarios or Advanced Networking). "
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.09-push-gitlab/",
	"title": "Push to GitLab",
	"tags": [],
	"description": "",
	"content": "Overview Sau khi test th√†nh c√¥ng, b·∫°n s·∫Ω push code l√™n GitLab ƒë·ªÉ version control v√† chu·∫©n b·ªã cho CI/CD.\nStep 1: Initialize Git Repository 1. Check Git Status\n# Navigate to project root cd /path/to/everyonecook-dev # Check if Git is already initialized git status # If not initialized: git init 2. Configure Git\n# Set your name and email git config user.name \u0026#34;Your Name\u0026#34; git config user.email \u0026#34;your.email@example.com\u0026#34; # Verify configuration git config --list Step 2: Create .gitignore 1. Create .gitignore File\n# Create .gitignore cat \u0026gt; .gitignore \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # Dependencies node_modules/ package-lock.json yarn.lock # Build outputs dist/ build/ *.js.map *.d.ts.map cdk.out/ .next/ # Environment variables .env .env.local .env.*.local # AWS *.pem *.key cloudfront-private-key.pem # Deployment packages *.zip deployment/ # Logs logs/ *.log npm-debug.log* yarn-debug.log* yarn-error.log* # IDE .vscode/ .idea/ *.swp *.swo *~ # OS .DS_Store Thumbs.db # Test coverage coverage/ .nyc_output/ # Temporary files tmp/ temp/ *.tmp # CDK cdk.context.json outputs.json # TypeScript *.tsbuildinfo EOF Step 3: Stage and Commit Files 1. Add Files to Staging\n# Add all files git add . # Check what will be committed git status 2. Create Initial Commit\n# Commit with message git commit -m \u0026#34;Initial commit: EveryoneCook infrastructure and backend\u0026#34; # Verify commit git log --oneline Screenshot: Terminal showing initial commit\nStep 4: Create GitLab Repository 1. Login to GitLab\nGo to https://gitlab.com/ and login\n2. Create New Project\nClick \u0026ldquo;New project\u0026rdquo; Choose \u0026ldquo;Create blank project\u0026rdquo; Project name: everyonecook Visibility: Private (recommended) Initialize with README: No (we already have code) Click \u0026ldquo;Create project\u0026rdquo; Screenshot: GitLab showing new project created\nGit Workflow Summary 1. Create feature branch from dev\rgit checkout -b feature/new-feature\r2. Make changes and commit\rgit add .\rgit commit -m \u0026#34;Description\u0026#34;\r3. Push to GitLab\rgit push -u origin feature/new-feature\r4. Create merge request on GitLab\rfeature/new-feature ‚Üí dev\r5. Review, test, and merge\r6. Deploy to dev environment\r(manual trigger in GitLab CI/CD)\r7. Test in dev environment\r8. Merge dev ‚Üí main for production\r9. Deploy to production\r(manual trigger in GitLab CI/CD)\r10. Tag release\rgit tag -a v1.0.0 -m \u0026#34;Release\u0026#34; Best Practices Commit Messages:\nfeat: Add user authentication\rfix: Fix login bug\rdocs: Update README\rstyle: Format code\rrefactor: Refactor user service\rtest: Add unit tests\rchore: Update dependencies Branch Naming:\nfeature/add-notifications\rbugfix/fix-login-error\rhotfix/critical-security-patch\rrelease/v1.0.0 Troubleshooting Issue: Authentication failed\n# Use personal access token instead of password # Generate token: GitLab ‚Üí Settings ‚Üí Access Tokens # Use token as password when pushing Issue: Large files rejected\n# Check file size git ls-files -z | xargs -0 du -h | sort -h # Remove large files from history git filter-branch --tree-filter \u0026#39;rm -f large-file.zip\u0026#39; HEAD Issue: Merge conflicts\n# Update your branch git checkout feature/your-feature git fetch origin git merge origin/dev # Resolve conflicts in files # Then commit git add . git commit -m \u0026#34;Resolve merge conflicts\u0026#34; git push Next Steps Once code is pushed to GitLab, proceed to Deploy to Amplify to deploy your frontend application.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/1.9-week9/",
	"title": "Week 9 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 9 Objectives Strengthen backend fundamentals: API design, authentication, database schemas. Learn core AWS backend services: API Gateway, Lambda, DynamoDB, Cognito. Build the first version of project backend architecture. Practice secure API development and proper request/response handling. Tasks to be carried out this week Day Task Start Date Completion Date Reference Material 2 Study REST API design, HTTP methods, and backend workflow. - Design initial API endpoints for the system. 03/11/2025 03/11/2025 AWS Study Group 3 Learn API Gateway basics. - Create routes, methods, request validation, and logging. 04/11/2025 04/11/2025 AWS Study Group 4 Learn AWS Lambda. - Build and deploy simple CRUD Lambda functions. - Test using event triggers. 05/11/2025 05/11/2025 AWS Study Group 5 Study DynamoDB. - Design table schema. - Perform CRUD operations. 06/11/2025 06/11/2025 AWS Study Group 6 Learn Cognito Authentication. - User Pool basics. - Link Cognito authorization with API Gateway routes. 07/11/2025 07/11/2025 AWS Study Group Week 9 Achievements 1. Improved Understanding of Backend Architecture I gained a strong foundational understanding of how backend systems are structured, including layered architecture, modular design, and how APIs communicate with databases and authentication services. This gave me a clearer picture of how to build scalable and maintainable backend systems.\n2. Designed and Documented Initial API Endpoints I successfully created the first version of the API specification, defining routes, request bodies, response formats, and error handling structures. This helped standardize communication between the backend and other system components.\n3. Implemented API Gateway Routing and Configuration I configured API Gateway to handle HTTP requests, apply method-level settings, enable CORS, attach logging, and prepare integrations for Lambda. This taught me how to connect external requests to internal processing logic securely and efficiently.\n4. Built Serverless Functions with AWS Lambda Using Lambda, I implemented initial backend logic using a serverless approach. I learned how to manage cold starts, structure handler functions, and troubleshoot event inputs and outputs. This provided practical experience in running code without managing servers.\n5. Designed and Queried DynamoDB Tables I learned how DynamoDB organizes data using partition keys and sort keys. I practiced writing queries, scans, and item updates, gaining confidence in managing NoSQL data models within cloud environments.\n6. Integrated Authentication Using Cognito This week, I set up a Cognito User Pool and integrated token-based authentication into API Gateway. I developed an understanding of how identity management and secure access control operate in serverless backend systems.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.10-deploy-amplify/",
	"title": "Deploy to Amplify",
	"tags": [],
	"description": "",
	"content": "Overview B∆∞·ªõc cu·ªëi c√πng l√† deploy frontend Next.js 15 l√™n AWS Amplify v·ªõi t√≠ch h·ª£p GitLab ƒë·ªÉ t·ª± ƒë·ªông deploy khi c√≥ code m·ªõi.\nStep 1: Prepare Frontend Code 1. Check Frontend Structure\ncd frontend # Check package.json cat package.json # Should show Next.js 15 2. Test Frontend Locally\n# Install dependencies npm install # Run development server npm run dev # Open http://localhost:3000 3. Build Frontend\n# Build for production npm run build # Test production build npm start Step 2: Create Amplify App 1. Go to AWS Amplify Console\nOpen AWS Console Search for \u0026ldquo;Amplify\u0026rdquo; Click \u0026ldquo;Get started\u0026rdquo; or \u0026ldquo;New app\u0026rdquo; 2. Connect to GitLab\nChoose \u0026ldquo;Host web app\u0026rdquo; Select \u0026ldquo;GitLab\u0026rdquo; Click \u0026ldquo;Connect branch\u0026rdquo; Authorize AWS Amplify to access GitLab Screenshot: Amplify showing GitLab connection\n3. Select Repository\nChoose repository: everyonecook Choose branch: main (or dev for development) Click \u0026ldquo;Next\u0026rdquo; Step 3: Configure Build Settings 1. App Name\nApp name: everyonecook-frontend 2. Build Settings\nAmplify auto-detects Next.js, but verify:\nversion: 1 applications: - frontend: phases: preBuild: commands: - export HUSKY=0 - npm install --legacy-peer-deps --ignore-scripts build: commands: - echo \u0026#34;=== Creating .env.production from Amplify env vars ===\u0026#34; - rm -f .env.production - env | grep -e NEXT_PUBLIC_ \u0026gt; .env.production || true - echo \u0026#34;=== .env.production content ===\u0026#34; - cat .env.production - echo \u0026#34;=== Building frontend ===\u0026#34; - npm run build artifacts: baseDirectory: .next files: - \u0026#39;**/*\u0026#39; cache: paths: - node_modules/**/* - .next/cache/**/* appRoot: frontend 3. Advanced Settings\nAdd environment variables:\nNEXT_PUBLIC_API_URL=https://api.everyonecook.cloud\rNEXT_PUBLIC_CDN_URL=https://cdn.everyonecook.cloud\rNEXT_PUBLIC_USER_POOL_ID=us-east-1_ABC123\rNEXT_PUBLIC_USER_POOL_CLIENT_ID=abc123def456\rNEXT_PUBLIC_REGION=us-east-1 Screenshot: Amplify environment variables configuration\nStep 4: Deploy Frontend 1. Start Deployment\nClick \u0026ldquo;Save and deploy\u0026rdquo;\nAmplify will:\nClone repository from GitLab Install dependencies Build Next.js app Deploy to CDN Provision domain 2. Monitor Deployment\nWatch deployment progress:\nProvision Build Deploy Verify 3. Wait for Completion\nDeployment takes 5-10 minutes.\nScreenshot: Amplify showing successful deployment\nStep 5: Configure Custom Domain 1. Add Custom Domain\nGo to Amplify app ‚Üí Domain management Click \u0026ldquo;Add domain\u0026rdquo; Enter domain: everyonecook.cloud Amplify will auto-configure: Root domain: everyonecook.cloud WWW subdomain: www.everyonecook.cloud 2. DNS Configuration\nAmplify automatically creates DNS records in Route 53:\neveryonecook.cloud ‚Üí A record ‚Üí Amplify\rwww.everyonecook.cloud ‚Üí CNAME ‚Üí Amplify 3. SSL Certificate\nAmplify automatically provisions SSL certificate via ACM.\n4. Wait for DNS Propagation\nTakes 5-15 minutes.\nScreenshot: Amplify showing custom domain configured\nStep 6: Verify Deployment 1. Access Frontend\n# Via Amplify domain curl -I https://main.d1234567890.amplifyapp.com # Via custom domain curl -I https://everyonecook.cloud # Should return 200 OK 2. Test Frontend Features\nOpen https://everyonecook.cloud in browser Test user registration Test login Test creating posts Test creating recipes Test AI features Screenshot: Browser showing EveryoneCook frontend live\nBest Practices Use Environment Variables: Never hardcode API URLs Enable Auto-Deploy: Automatic deployments on push Multiple Environments: Separate dev and prod Monitor Performance: Use Amplify metrics Set Up Notifications: Get alerted on build failures Use Custom Domain: Professional appearance Enable HTTPS: Always use SSL Configure Headers: Security headers for protection Next Steps Congratulations! Your application is now fully deployed:\n‚úÖ Infrastructure on AWS ‚úÖ Backend APIs running ‚úÖ Frontend on Amplify ‚úÖ Code on GitLab ‚úÖ CI/CD configured Proceed to Cleanup when you\u0026rsquo;re done testing, or start using your application!\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/1.10-week10/",
	"title": "Week 10 Worklog ",
	"tags": [],
	"description": "",
	"content": "Week 10 Objectives Deepen backend security practices and understand identity flows in cloud environments. Strengthen AWS Cognito integration and apply token-based authentication. Implement secure data handling with DynamoDB (validation, access patterns, indexes). Practice API Gateway authorizers, throttling, and rate limiting. Start connecting backend functions into a complete end-to-end workflow. Tasks to be carried out this week Day Task Start Date Completion Date Reference Material 2 Study authentication/authorization flows (JWT, Access Token, ID Token). - Review OWASP API security. 10/11/2025 10/11/2025 AWS Study Group 3 Deep dive into Cognito User Pool and Identity Pool. - Implement login, signup, refresh token flow. 11/11/2025 11/11/2025 AWS Study Group 4 Implement Lambda Authorizer and attach it to API Gateway routes. - Add permission policies. 12/11/2025 12/11/2025 AWS Study Group 5 Strengthen DynamoDB integration: - Add secondary indexes. - Improve validation \u0026amp; error handling. 13/11/2025 13/11/2025 AWS Study Group 6 Build end-to-end testing: - Client ‚Üí API Gateway ‚Üí Lambda ‚Üí DynamoDB ‚Üí Response. 14/11/2025 14/11/2025 AWS Study Group Week 10 Achievements 1. Gained Deeper Understanding of Authentication \u0026amp; Token Security I learned in detail how JWT tokens work, how access/ID/refresh tokens differ, and how secure authentication is implemented in serverless applications. I also studied common attack vectors in API security and how to mitigate them using best practices.\n2. Successfully Implemented Cognito Authentication Flows This week, I configured Cognito to support signup, login, multi-factor authentication (optional), and token refreshing. I tested these flows using CLI and Postman, ensuring the backend can securely identify and authorize users.\n3. Integrated Lambda Authorizer with API Gateway I created a custom Lambda Authorizer to validate tokens sent from the client. This allowed me to enforce fine-grained access control and protect backend routes from unauthorized access. This step also increased my confidence with IAM policies and API Gateway security layers.\n4. Enhanced DynamoDB Architecture Using Secondary Indexes I implemented Global Secondary Indexes (GSI) to optimize queries and reduce latency for more complex data access patterns. I also improved error handling and input validation to ensure stable and predictable database behavior.\n5. Completed End-to-End Backend Workflow Testing By the end of the week, I completed full request lifecycle testing:\nClient request ‚Üí API Gateway ‚Üí Lambda ‚Üí DynamoDB ‚Üí API response.\nI verified that authentication, database operations, and serverless execution flow work together smoothly.\n6. Improved Overall Backend Code Structure and Maintainability I refactored Lambda functions to follow cleaner architecture principles, separating business logic, validation, and database operations. This makes future development easier and reduces potential bugs.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/5-workshop/5.11-cleanup/",
	"title": "Cleanup",
	"tags": [],
	"description": "",
	"content": "Overview When you complete the workshop and no longer want to continue using it, delete all resources to avoid incurring charges.\n‚ö†Ô∏è Warning: This process cannot be undone. All data will be permanently deleted.\nCleanup Order Must delete in reverse order of deployment:\n1. Amplify App (Frontend)\r2. Observability Stack\r3. Backend Stack\r4. Auth Stack\r5. Core Stack\r6. Certificate Stack\r7. DNS Stack\r8. CDK Bootstrap (optional) Step 1: Delete Amplify App 1. Delete via Console\nGo to AWS Amplify Console Select your app Click \u0026ldquo;Actions\u0026rdquo; ‚Üí \u0026ldquo;Delete app\u0026rdquo; Type app name to confirm Click \u0026ldquo;Delete\u0026rdquo; 2. Delete via CLI\n# Get app ID APP_ID=$(aws amplify list-apps \\ --query \u0026#39;apps[?name==`everyonecook-frontend`].appId\u0026#39; \\ --output text) # Delete app aws amplify delete-app --app-id $APP_ID Step 2: Empty S3 Buckets S3 buckets must be emptied before deletion:\n# List all EveryoneCook buckets aws s3 ls | grep everyonecook # Empty each bucket (4 buckets) aws s3 rm s3://everyonecook-content-dev-xxxxx --recursive aws s3 rm s3://everyonecook-logs-dev-xxxxx --recursive aws s3 rm s3://everyonecook-emails-dev-xxxxx --recursive aws s3 rm s3://everyonecook-cdn-logs-dev-xxxxx --recursive # Or use PowerShell script $buckets = aws s3 ls | Select-String \u0026#34;everyonecook\u0026#34; | ForEach-Object { $_.ToString().Split()[-1] } foreach ($bucket in $buckets) { Write-Host \u0026#34;Emptying bucket: $bucket\u0026#34; aws s3 rm \u0026#34;s3://$bucket\u0026#34; --recursive } Step 3: Delete CDK Stacks 1. Delete Observability Stack\ncd infrastructure # Delete Observability stack npx cdk destroy EveryoneCook-dev-Observability --context environment=dev # Type \u0026#39;y\u0026#39; to confirm 2. Delete Backend Stack\n# Delete Backend stack npx cdk destroy EveryoneCook-dev-Backend --context environment=dev # Type \u0026#39;y\u0026#39; to confirm 3. Delete Auth Stack\n# Delete Auth stack npx cdk destroy EveryoneCook-dev-Auth --context environment=dev # Type \u0026#39;y\u0026#39; to confirm 4. Delete Core Stack\n# Delete Core stack (takes 15-20 minutes due to CloudFront) npx cdk destroy EveryoneCook-dev-Core --context environment=dev # Type \u0026#39;y\u0026#39; to confirm 5. Delete Certificate Stack\n# Delete Certificate stack npx cdk destroy EveryoneCook-dev-Certificate --context environment=dev # Type \u0026#39;y\u0026#39; to confirm 6. Delete DNS Stack (Optional)\n# Delete DNS stack (only if you don\u0026#39;t need the domain) npx cdk destroy EveryoneCook-dev-DNS --context environment=dev # Type \u0026#39;y\u0026#39; to confirm Step 4: Verify All Stacks Deleted # List remaining stacks aws cloudformation list-stacks \\ --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE \\ --query \u0026#39;StackSummaries[?contains(StackName, `EveryoneCook-dev`)].StackName\u0026#39; # Should return empty array Step 5: Delete CDK Bootstrap (Optional) ‚ö†Ô∏è Only do this if you\u0026rsquo;re done with CDK completely:\n# Delete CDK bootstrap stack aws cloudformation delete-stack --stack-name CDKToolkit # Empty and delete CDK assets bucket BUCKET_NAME=$(aws s3 ls | grep cdk | awk \u0026#39;{print $3}\u0026#39;) aws s3 rm s3://$BUCKET_NAME --recursive aws s3 rb s3://$BUCKET_NAME Step 6: Delete GitLab Repository (Optional) 1. Archive Repository\nGo to GitLab ‚Üí Settings ‚Üí General Scroll to \u0026ldquo;Advanced\u0026rdquo; Click \u0026ldquo;Archive project\u0026rdquo; 2. Delete Repository\nGo to GitLab ‚Üí Settings ‚Üí General Scroll to \u0026ldquo;Advanced\u0026rdquo; Click \u0026ldquo;Delete project\u0026rdquo; Type project name to confirm Click \u0026ldquo;Yes, delete project\u0026rdquo; Step 7: Verify Complete Cleanup 1. Check CloudFormation\naws cloudformation list-stacks \\ --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE \\ | grep EveryoneCook # Should return nothing 2. Check S3\naws s3 ls | grep everyonecook # Should return nothing 3. Check Lambda\naws lambda list-functions | grep EveryoneCook # Should return nothing 4. Check DynamoDB\naws dynamodb list-tables | grep EveryoneCook # Should return nothing 5. Check API Gateway\naws apigateway get-rest-apis | grep EveryoneCook # Should return nothing 6. Check Cognito\naws cognito-idp list-user-pools --max-results 10 | grep EveryoneCook # Should return nothing 7. Check CloudFront\naws cloudfront list-distributions | grep EveryoneCook # Should return nothing 8. Check OpenSearch\naws opensearch list-domain-names | grep everyonecook # Should return nothing 9. Check Amplify\naws amplify list-apps | grep everyonecook # Should return nothing Cost After Cleanup Immediate:\nMost resources: $0/month Route 53 Hosted Zone: $0.50/month (if kept) KMS keys: Scheduled for deletion (7-30 days), no charge during waiting period After 30 days:\nEverything: $0/month (if DNS stack also deleted) Troubleshooting Cleanup Issue: S3 bucket deletion fails\n# Force empty and delete aws s3 rb s3://bucket-name --force Issue: CloudFormation stack stuck\n# Check stack events aws cloudformation describe-stack-events \\ --stack-name EveryoneCook-dev-Core \\ --max-items 20 # If stuck, skip failed resources aws cloudformation delete-stack \\ --stack-name EveryoneCook-dev-Core \\ --retain-resources ResourceLogicalId Issue: CloudFront distribution can\u0026rsquo;t be deleted\n# Disable distribution first DIST_ID=$(aws cloudfront list-distributions \\ --query \u0026#34;DistributionList.Items[?Comment==\u0026#39;EveryoneCook-dev\u0026#39;].Id\u0026#34; \\ --output text) # Get ETag ETAG=$(aws cloudfront get-distribution --id $DIST_ID \\ --query \u0026#34;ETag\u0026#34; --output text) # Disable distribution aws cloudfront update-distribution \\ --id $DIST_ID \\ --if-match $ETAG \\ --distribution-config file://disabled-config.json # Wait 15-20 minutes, then delete aws cloudfront delete-distribution --id $DIST_ID --if-match $ETAG Issue: DynamoDB table has deletion protection\n# Disable deletion protection aws dynamodb update-table \\ --table-name EveryoneCook-dev \\ --no-deletion-protection-enabled # Then delete stack Final Verification # Check AWS billing aws ce get-cost-and-usage \\ --time-period Start=2024-01-01,End=2024-01-31 \\ --granularity MONTHLY \\ --metrics BlendedCost # Should show decreasing costs Cleanup Checklist Amplify app deleted All S3 buckets emptied and deleted Observability stack deleted Backend stack deleted Auth stack deleted Core stack deleted Certificate stack deleted DNS stack deleted (optional) CDK bootstrap deleted (optional) GitLab repository archived/deleted (optional) No remaining CloudFormation stacks No remaining Lambda functions No remaining DynamoDB tables No remaining S3 buckets No remaining CloudFront distributions No remaining Cognito user pools Billing shows $0 or minimal cost Conclusion You have completed the EveryoneCook workshop! You have learned:\nInfrastructure as Code with AWS CDK\nServerless Architecture with Lambda and API Gateway\nDynamoDB Single Table Design with username-based PK\nOpenSearch with Vietnamese analyzer\nCloudFront CDN with Origin Access Control\nCognito Authentication with Lambda triggers\nBedrock AI integration\nGitLab version control and CI/CD\nAWS Amplify frontend deployment\nCloudWatch monitoring and X-Ray tracing\nTotal deployed:\n7 CDK stacks 100+ AWS resources 6 Lambda modules + 1 worker Full-stack application CI/CD pipeline Production-ready infrastructure Thank you for completing the workshop! üéâ\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/1.11-week11/",
	"title": "Week 11 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 11 Objectives Start integrating frontend with backend authenticated APIs. Strengthen API Gateway and Lambda error handling strategy. Implement frontend token storage and refresh token logic. Build reusable API client wrapper (Axios/Fetch) with interceptors. Improve logging, debugging and CloudWatch insights usage. Complete full-stack functionality from UI ‚Üí Gateway ‚Üí Lambda ‚Üí Database. Tasks to be carried out this week Day Task Start Date Completion Date Reference Material 2 Connect frontend to Cognito auth endpoints. - Implement login, signup UI flows. 17/11/2025 17/11/2025 AWS Study Group 3 Implement secure token storage \u0026amp; token refresh mechanism. - Add interceptors in API client. 18/11/2025 18/11/2025 AWS Study Group 4 Integrate frontend with API Gateway authenticated routes. - Validate Lambda Authorizer flow. 19/11/2025 19/11/2025 AWS Study Group 5 Build a global error handling layer (frontend + backend). - Improve API response consistency. 20/11/2025 20/11/2025 AWS Study Group 6 Strengthen monitoring using CloudWatch Logs \u0026amp; Metrics. - Debug end-to-end flow. 21/11/2025 21/11/2025 AWS Study Group Week 11 Achievements 1. Completed Frontend Authentication Integration This week, I successfully connected the frontend application to Cognito, enabling user signup, login, and logout directly from the UI. I ensured token retrieval and user session management work properly.\n2. Implemented Secure Token Storage \u0026amp; Auto Refresh I set up secure token storage using browser memory and added an automatic token refresh flow. I also implemented Axios/Fetch interceptors to attach access tokens on every request.\n3. Integrated Frontend with Protected Backend APIs The frontend can now communicate with protected API Gateway routes using JWT tokens. This validates the entire authentication pipeline from UI ‚Üí Client ‚Üí Gateway ‚Üí Lambda ‚Üí DynamoDB.\n4. Built a Consistent Global Error-Handling System I standardized error responses in Lambda, updated API Gateway mappings, and built a global error handler on the frontend to show meaningful messages. This reduces debugging time and improves UX.\n5. Improved Logging \u0026amp; Monitoring with CloudWatch I analyzed Lambda logs, identified slow operations, and created CloudWatch Metrics filters to monitor request failures and latency. This improved my debugging workflow significantly.\n6. Achieved Full-Stack Authentication + Data Flow By the end of the week, I successfully executed end-to-end user actions: UI ‚Üí Authenticate ‚Üí Call API ‚Üí Lambda Logic ‚Üí DynamoDB ‚Üí Return response.\nEverything worked seamlessly with proper security \u0026amp; error-handling in place.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/1-worklog/1.12-week12/",
	"title": "Week 12 Worklog",
	"tags": [],
	"description": "",
	"content": "Week 12 Objectives Improve overall UI/UX and implement advanced state management. Connect frontend components to backend dynamic data in real time. Strengthen API input/output validation and ensure stable backend contracts. Create reusable UI components for forms, modals, and error states. Optimize network usage, caching logic, and reduce unnecessary API calls. Begin preparing full-stack feature for user actions and data updates. Tasks to be carried out this week Day Task Start Date Completion Date Reference Material 2 Implement global state management (Redux / Zustand / Context). - Add persistent user session. 24/11/2025 24/11/2025 AWS Study Group 3 Build reusable UI components: inputs, modals, loaders, notifications. 25/11/2025 25/11/2025 AWS Study Group 4 Integrate dynamic backend data into UI components. - Add data fetch + refresh logic. 26/11/2025 26/11/2025 AWS Study Group 5 Improve API validation \u0026amp; frontend form validation. - Ensure stable API contract \u0026amp; error messages. 27/11/2025 27/11/2025 AWS Study Group 6 Optimize frontend performance \u0026amp; caching. - Reduce duplicate API calls using memoization. 28/11/2025 28/11/2025 AWS Study Group Week 12 Achievements 1. Implemented Scalable Global State Management This week, I integrated a global state manager to coordinate authentication, UI state, and dynamic data. This helped unify session handling and reduce prop drilling.\n2. Built a Library of Reusable UI Components I created reusable components such as buttons, inputs, modals, loaders, skeletons, and notification toasts. This significantly improves consistency and speeds up future UI development.\n3. Successfully Integrated Backend Data Into UI I connected frontend elements to live backend data, ensuring views update correctly when users make changes. I also added auto-refresh and manual refresh options.\n4. Strengthened Validation \u0026amp; API Data Contracts I upgraded backend API validation (Lambda + API Gateway mapping) and added stronger frontend form validation, reducing user errors and ensuring cleaner, more predictable API responses.\n5. Optimized Performance \u0026amp; Reduced API Calls I implemented caching, memoization, and request deduplication. This reduces network load, speeds up UI interactions, and creates a smoother experience.\n6. Prepared Full-Stack Feature Enhancements By the end of the week, I completed the foundation needed to build complex full-stack features involving user actions, database updates, and responsive UI behavior.\n"
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://nvtruongops.github.io/fcj-workshop-template/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]